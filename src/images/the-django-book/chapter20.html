<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第二十章： 安全</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter19.html">| 上一章</a> |<a href="index.html">目  录</a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第二十章： 安全</h1><p class="cn" id="cn1">Internet并不安全。</p><p class="cn" id="cn2">现如今，每天都会出现新的安全问题。 我们目睹过病毒飞速地蔓延，大量被控制的肉鸡作为武器来攻击其他人，与垃圾邮件的永无止境的军备竞赛，以及许许多多站点被黑的报告。</p><p class="cn" id="cn3">作为Web开发人员，我们有责任来对抗这些黑暗的力量。每一个Web开发者都应该把安全看成是Web编程中的基础部分。不幸的是，要实现安全是困难的。</p><p class="cn" id="cn4">Django试图减轻这种难度。 它被设计为自动帮你避免一些web开发新手（甚至是老手）经常会犯的错误。 尽管如此，需要弄清楚，Django如何保护我们，以及我们可以采取哪些重要的方法来使得我们的代码更加安全。</p><p class="cn" id="cn5">首先，一个重要的前提： 我们并不打算给出web安全的一个详尽的说明，因此我们也不会详细地解释每一个薄弱环节。 在这里，我们会给出Django所面临的安全问题的一个大概。</p><div class="section" id="web"><span id="cn6"></span><h2 class="cn" id="cn6">Web安全现状</h2><p class="cn" id="cn7">如果你从这章中只学到了一件事情，那么它会是：</p><p class="cn" id="cn8">在任何条件下都不要相信浏览器端提交的数据。</p><p class="cn" id="cn9">你从不会知道HTTP连接的另一端会是谁。 可能是一个正常的用户，但是同样可能是一个寻找漏洞的邪恶的骇客。</p><p class="cn" id="cn10">从浏览器传过来的任何性质的数据，都需要近乎狂热地接受检查。 这包括用户数据（比如Web表单提交的内容）和带外数据（比如，HTTP头、cookies以及其他信息）。 要修改那些浏览器自动添加的元数据，是一件很容易的事。</p><p class="cn" id="cn11">在这一章所提到的所有的安全隐患都直接源自对传入数据的信任，并且在使用前不加处理。 你需要不断地问自己，这些数据从何而来。</p></div><div class="section" id="sql"><span id="cn12"></span><h2 class="cn" id="cn12">SQL注入</h2><p class="cn" id="cn13">SQL注入 是一个很常见的形式，在SQL注入中，攻击者改变web网页的参数（例如 <tt class="docutils literal"><span class="pre">GET</span></tt> /<tt class="docutils literal"><span class="pre">POST</span></tt> 数据或者URL地址），加入一些其他的SQL片段。 未加处理的网站会将这些信息在后台数据库直接运行。</p><p class="cn" id="cn14">这种危险通常在由用户输入构造SQL语句时产生。例如，假设我们要写一个函数，用来从通信录搜索页面收集一系列的联系信息。 为防止垃圾邮件发送器阅读系统中的email，我们将在提供email地址以前，首先强制用户输入用户名。</p><pre class="cn literal-block" id="cn16">def user_contacts(request):user = request.GET['username']sql = &quot;SELECT * FROM user_contacts WHERE username = '%s';&quot; % username# execute the SQL here...</pre><p class="cn" id="cn17">备注</p><p class="cn" id="cn18">在这个例子中，以及在以下所有的“不要这样做”的例子里，我们都去除了大量的代码，避免这些函数可以正常工作。 我们可不想这些例子被拿出去使用。</p><p class="cn" id="cn19">尽管，一眼看上去，这一点都不危险，实际上却不尽然。</p><p class="cn" id="cn20">首先，我们对于保护email列表所采取的措施，遇到精心构造的查询语句就会失效。 想象一下，如果攻击者在查询框中输入 <tt class="docutils literal"><span class="pre">&quot;'</span> <span class="pre">OR</span> <span class="pre">'a'='a&quot;</span></tt> 。 此时，查询的字符串会构造如下：</p><pre class="cn literal-block" id="cn22">SELECT * FROM user_contacts WHERE username = '' OR 'a' = 'a';</pre><p class="cn" id="cn23">由于我们允许不安全的SQL语句出现在字符串中，攻击者加入 <tt class="docutils literal"><span class="pre">OR</span></tt> 子句，使得每一行数据都被返回。</p><p class="cn" id="cn24">事实上，这是最温和的攻击方式。 如果攻击者提交了 <tt class="docutils literal"><span class="pre">&quot;';</span> <span class="pre">DELETE</span> <span class="pre">FROM</span> <span class="pre">user_contacts</span> <span class="pre">WHERE</span> <span class="pre">'a'</span> <span class="pre">=</span> <span class="pre">'a'&quot;</span></tt> ，我们最终将得到这样的查询：</p><pre class="cn literal-block" id="cn26">SELECT * FROM user_contacts WHERE username = ''; DELETE FROM user_contacts WHERE 'a' = 'a';</pre><p class="cn" id="cn27">哦！我们整个通信录名单去哪儿了？ 我们整个通讯录会被立即删除</p><div class="section" id="id2"><span id="cn28"></span><h3 class="cn" id="cn28">解决方案</h3><p class="cn" id="cn29">尽管这个问题很阴险，并且有时很难发现，解决方法却很简单：绝不信任用户提交的数据，并且在传递给SQL语句时，总是转义它。</p><p class="cn" id="cn30">Django的数据库API帮你做了。 它会根据你所使用的数据库服务器（例如PostSQL或者MySQL）的转换规则，自动转义特殊的SQL参数。</p><p class="cn" id="cn31">举个例子，在下面这个API调用中：</p><pre class="cn literal-block" id="cn33">foo.get_list(bar__exact=&quot;' OR 1=1&quot;)</pre><p class="cn" id="cn34">Django会自动进行转义，得到如下表达：</p><pre class="cn literal-block" id="cn36">SELECT * FROM foos WHERE bar = '\' OR 1=1'</pre><p class="cn" id="cn37">完全无害。</p><p class="cn" id="cn38">这被运用到了整个Django的数据库API中，只有一些例外：</p><ul class="simple"><li class="cn" id="cn39"><p class="first cn" id="cn39">传给 <tt class="docutils literal"><span class="pre">extra()</span></tt> 方法的 <tt class="docutils literal"><span class="pre">where</span></tt> 参数。 (参考 附录 C。) 这个参数故意设计成可以接受原始的SQL。</p></li></ul><ul class="simple"><li class="cn" id="cn40"><p class="first cn" id="cn40">使用底层数据库API的查询。 (详见第十章)</p></li></ul><p class="cn" id="cn41">以上列举的每一个示例都能够很容易的让您的应用得到保护。 在每一个示例中，为了避免字符串被篡改而使用 <em>绑定参数</em> 来代替。这样，本节开始的例子应该写成这样：</p><pre class="cn literal-block" id="cn43">from django.db import connectiondef user_contacts(request):user = request.GET['username']sql = &quot;SELECT * FROM user_contacts WHERE username = %s&quot;cursor = connection.cursor()cursor.execute(sql, [user])# ... do something with the results</pre><p class="cn" id="cn44">底层 <tt class="docutils literal"><span class="pre">execute</span></tt> 方法采用了一个SQL字符串作为其第二个参数，这个SQL字符串包含若干&#8217;%s&#8217;占位符，execute方法能够自动对传入列表中的参数进行转义和插入。你应该用* always* 这种方式构造自定义的SQL。</p><p class="cn" id="cn45">不幸的是，您并不是在SQL中能够处处都使用绑定参数，绑定参数不能够作为标识符（如表或列名等）。 因此，如果您需要这样做&#8212;我是说&#8212;动态构建 <tt class="docutils literal"><span class="pre">POST</span></tt> 变量中的数据库表的列表的话，您需要在您的代码中来对这些数据库表的名字进行转义。Django提供了一个函数， <tt class="docutils literal"><span class="pre">django.db.backend.quote_name</span></tt> ，这个函数能够根据当前数据库引用结构对这些标识符进行转义。</p></div></div><div class="section" id="xss"><span id="cn46"></span><h2 class="cn" id="cn46">跨站点脚本 (XSS)</h2><p class="cn" id="cn47">在Web应用中， <em>跨站点脚本</em> (XSS)有时在被渲染成HTML之前，不能恰当地对用户提交的内容进行转义。 这使得攻击者能够向你的网站页面插入通常以 <tt class="docutils literal"><span class="pre">&lt;script&gt;</span></tt> 标签形式的任意HTML代码。</p><p class="cn" id="cn48">攻击者通常利用XSS攻击来窃取cookie和会话信息，或者诱骗用户将其私密信息透漏给被人（又称 <em>钓鱼</em> ）。</p><p class="cn" id="cn49">这种类型的攻击能够采用多种不同的方式，并且拥有几乎无限的变体，因此我们还是只关注某个典型的例子吧。 让我们来想想这样一个极度简单的Hello World视图：</p><pre class="cn literal-block" id="cn51">from django.http import HttpResponsedef say_hello(request):name = request.GET.get('name', 'world')return HttpResponse('&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % name)</pre><p class="cn" id="cn52">这个视图只是简单的从GET参数中读取姓名然后将姓名传递给hello.html模板。 因此，如果我们访问 <tt class="docutils literal"><span class="pre">http://example.com/hello/?name=Jacob</span></tt> ，被呈现的页面将会包含一以下这些：</p><pre class="cn literal-block" id="cn54">&lt;h1&gt;Hello, Jacob!&lt;/h1&gt;</pre><p class="cn" id="cn55">但是，等等，如果我们访问 <tt class="docutils literal"><span class="pre">http://example.com/hello/?name=&lt;i&gt;Jacob&lt;/i&gt;</span></tt> 时又会发生什么呢？</p><pre class="cn literal-block" id="cn57">&lt;h1&gt;Hello, &lt;i&gt;Jacob&lt;/i&gt;!&lt;/h1&gt;</pre><p class="cn" id="cn58">当然，一个攻击者不会使用&lt;i&gt;标签开始的类似代码，他可能会用任意内容去包含一个完整的HTML集来劫持您的页面。 这种类型的攻击已经运用于虚假银行站点以诱骗用户输入个人信息，事实上这就是一种劫持XSS的形式，用以使用户向攻击者提供他们的银行帐户信息。</p><p class="cn" id="cn59">如果您将这些数据保存在数据库中，然后将其显示在您的站点上，那么问题就变得更严重了。 例如，一旦MySpace被发现这样的特点而能够轻易的被XSS攻击，后果不堪设想。 某个用户向他的简介中插入JavaScript，使得您在访问他的简介页面时自动将其加为您的好友，这样在几天之内，这个人就能拥有上百万的好友。 在几天的时间里，他拥有了数以百万的朋友。</p><p class="cn" id="cn60">现在，这种后果听起来还不那么恶劣，但是您要清楚——这个攻击者正设法将 <em>他</em> 的代码而不是MySpace的代码运行在 <em>您</em> 的计算机上。 这显然违背了假定信任——所有运行在MySpace上的代码应该都是MySpace编写的，而事实上却不如此。</p><p class="cn" id="cn61">MySpace是极度幸运的，因为这些恶意代码并没有自动删除访问者的帐户，没有修改他们的密码，也并没有使整个站点一团糟，或者出现其他因为这个弱点而导致的其他噩梦。</p><div class="section" id="id3"><span id="cn62"></span><h3 class="cn" id="cn62">解决方案</h3><p class="cn" id="cn63">解决方案是简单的： 总是转义可能来自某个用户的任何内容。</p><p class="cn" id="cn64">为了防止这种情况，Django的模板系统自动转义所有的变量值。让我们来看看如果我们使用模板系统重写我们的例子会发生什么</p><pre class="cn literal-block" id="cn66"># views.pyfrom django.shortcuts import render_to_responsedef say_hello(request):name = request.GET.get('name', 'world')return render_to_response('hello.html', {'name': name})# hello.html&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;</pre><p class="cn" id="cn67">这样，一个到`` <a class="reference external" href="http://example.com/hello">http://example.com/hello</a>/name=Jacob`` 的请求将导致下面的页面：</p><pre class="cn literal-block" id="cn69">&lt;h1&gt;Hello, &amp;lt;i&amp;gt;Jacob&amp;lt;/i&amp;gt;!&lt;/h1&gt;</pre><p class="cn" id="cn70">我们在第四章涵盖了Django的自动转义，一起想办法将其关闭。 甚至，如果Django真的新增了这些特性，您也应该习惯性的问自己，一直以来，这些数据都来自于哪里呢？ 没有哪个自动解决方案能够永远保护您的站点百分之百的不会受到XSS攻击。</p></div></div><div class="section" id="id4"><span id="cn71"></span><h2 class="cn" id="cn71">伪造跨站点请求</h2><p class="cn" id="cn72">伪造跨站点请求(CSRF)发生在当某个恶意Web站点诱骗用户不知不觉的从一个信任站点下载某个URL之时，这个信任站点已经被通过信任验证，因此恶意站点就利用了这个被信任状态。</p><p class="cn" id="cn73">Django拥有内建工具来防止这种攻击。 包括攻击本身及其使用的工具都在有详细介绍。<a class="reference external" href="chapter16.html">16章</a></p></div><div class="section" id="id5"><span id="cn74"></span><h2 class="cn" id="cn74">会话伪造/劫持</h2><p class="cn" id="cn75">这不是某个特定的攻击，而是对用户会话数据的通用类攻击。 这种攻击可以采取多种形式：</p><blockquote><p class="cn" id="cn76"><em>中间人</em> 攻击：检索所在有线（无线）网络，监听会话数据。</p><p class="cn" id="cn77"><em>伪造会话</em> ：攻击者利用会话ID（可能是通过中间人攻击来获得）将自己伪装成另一个用户。</p><p class="cn" id="cn78">这两种攻击的一个例子可以是在一间咖啡店里的某个攻击者利用店内的无线网络来捕获某个会话cookie，然后她就可以利用那个cookie来假冒原始用户。 她便可以使该cookie来模拟原始用户。</p><p class="cn" id="cn79"><em>伪造cookie</em> ：就是指某个攻击者覆盖了在某个cookie中本应该是只读的数据。 ` 第十四章 &lt;chapter14.html&gt;`__ 详细介绍了cookies如何工作，以及要点之一的是，它在你不知道的情况下无视浏览器和恶意用户私自改变cookies。</p><p class="cn" id="cn80">Web站点以 <tt class="docutils literal"><span class="pre">IsLoggedIn=1</span></tt> 或者 <tt class="docutils literal"><span class="pre">LoggedInAsUser=jacob</span></tt> 这样的方式来保存cookie由来已久，使用这样的cookie是再简单不过的了。</p><p class="cn" id="cn81">一个更微妙的层面上，然而，相信在cookies中存储的任意信息绝对不是一个好主意。 你永远不知道谁一直在作怪。</p><p class="cn" id="cn82"><em>会话滞留</em> ：攻击者诱骗用户设置或者重设置该用户的会话ID。</p><p class="cn" id="cn83">例如，PHP允许在URL（如 <tt class="docutils literal"><span class="pre">http://example.com/?PHPSESSID=fa90197ca25f6ab40bb1374c510d7a32</span></tt> 等）中传递会话标识符。攻击者欺骗用户点击一个硬编码会话ID的链接，这回导致用户转到那个会话。</p><p class="cn" id="cn84">会话滞留已经运用在钓鱼攻击中，以诱骗用户在攻击者拥有的账号里输入其个人信息。 他可以稍后登陆账户并且检索数据。</p><p class="cn" id="cn85"><em>会话中毒</em> ：攻击者通过用户提交设置会话数据的Web表单向该用户会话中注入潜在危险数据。</p><p class="cn" id="cn86">一个经典的例子就是一个站点在某个cookie中存储了简单的用户偏好（比如一个页面背景颜色）。 攻击者可以诱骗用户点击一个链接来提交背景颜色，实际上包含了一个XSS攻击。 如果颜色没有转义，那么就可以再把恶意代码注入到用户环境中。</p></blockquote><div class="section" id="id6"><span id="cn87"></span><h3 class="cn" id="cn87">解决方案</h3><p class="cn" id="cn88">有许多基本准则能够保护您不受到这些攻击：</p><blockquote><p class="cn" id="cn89">不要在URL中包含任何session信息。</p><p class="cn" id="cn90">Django的session框架（参见` 第十四章 &lt;chapter14.html&gt;`__ ）根本不会容许session包含在URL中。</p><p class="cn" id="cn91">不要直接在cookie中保存数据。 相反，存储一个在后台映射到session数据存储的session ID。</p><p class="cn" id="cn92">如果使用Django内置的session框架（即 <tt class="docutils literal"><span class="pre">request.session</span></tt> ），它会自动进行处理。 这个session框架仅在cookie中存储一个session ID，所有的session数据将会被存储在数据库中。</p><p class="cn" id="cn93">如果需要在模板中显示session数据，要记得对其进行转义。 可参考之前的XSS部分，对所有用户提交的数据和浏览器提交的数据进行转义。 对于session信息，应该像用户提交的数据一样对其进行处理。</p><p class="cn" id="cn94">任何可能的地方都要防止攻击者进行session欺骗。</p><p class="cn" id="cn95">尽管去探测究竟是谁劫持了会话ID是几乎不可能的事儿，Django还是内置了保护措施来抵御暴力会话攻击。 会话ID被存在哈希表里（取代了序列数字），这样就阻止了暴力攻击，并且如果一个用户去尝试一个不存在的会话那么她总是会得到一个新的会话ID，这样就阻止了会话滞留。</p></blockquote><p class="cn" id="cn96">请注意，以上没有一种准则和工具能够阻止中间人攻击。 这些类型的攻击是几乎不可能被探测的。 如果你的站点允许登陆用户去查看任意敏感数据的话，你应该 <em>总是</em> 通过HTTPS来提供网站服务。此外，如果你的站点使用SSL，你应该将 <tt class="docutils literal"><span class="pre">SESSION_COOKIE_SECURE</span></tt> 设置为 <tt class="docutils literal"><span class="pre">True</span></tt> ，这样就能够使Django只通过HTTPS发送会话cookie。</p></div></div><div class="section" id="id7"><span id="cn97"></span><h2 class="cn" id="cn97">邮件头部注入</h2><p class="cn" id="cn98"><em>邮件头部注入</em> ：SQL注入的兄弟，是一种通过劫持发送邮件的Web表单的攻击方式。 攻击者能够利用这种技术来通过你的邮件服务器发送垃圾邮件。 在这种攻击面前，任何方式的来自Web表单数据的邮件头部构筑都是非常脆弱的。</p><p class="cn" id="cn99">让我们看看在我们许多网站中发现的这种攻击的形式。 通常这种攻击会向硬编码邮件地址发送一个消息，因此，第一眼看上去并不显得像面对垃圾邮件那么脆弱。</p><p class="cn" id="cn100">但是，大多数表单都允许用户输入自己的邮件主题（同时还有from地址，邮件体，有时还有部分其他字段）。 这个主题字段被用来构建邮件消息的主题头部。</p><p class="cn" id="cn101">如果那个邮件头部在构建邮件信息时没有被转义，那么攻击者可以提交类似 <tt class="docutils literal"><span class="pre">&quot;hello\ncc:spamvictim&#64;example.com&quot;</span></tt> （这里的 <tt class="docutils literal"><span class="pre">&quot;\n&quot;</span></tt> 是换行符）的东西。 这有可能使得所构建的邮件头部变成：</p><pre class="cn literal-block" id="cn103">To: hardcoded&#64;example.comSubject: hellocc: spamvictim&#64;example.com</pre><p class="cn" id="cn104">就像SQL注入那样，如果我们信任了用户提供的主题行，那样同样也会允许他构建一个头部恶意集，他也就能够利用联系人表单来发送垃圾邮件。</p><div class="section" id="id8"><span id="cn105"></span><h3 class="cn" id="cn105">解决方案</h3><p class="cn" id="cn106">我们能够采用与阻止SQL注入相同的方式来阻止这种攻击： 总是校验或者转义用户提交的内容。</p><p class="cn" id="cn107">Django内建邮件功能（在 <tt class="docutils literal"><span class="pre">django.core.mail</span></tt> 中）根本不允许在用来构建邮件头部的字段中存在换行符（表单，收件地址，还有主题）。 如果您试图使用 <tt class="docutils literal"><span class="pre">django.core.mail.send_mail</span></tt> 来处理包含换行符的主题时，Django将会抛出BadHeaderError异常。</p><p class="cn" id="cn108">如果你没有使用Django内建邮件功能来发送邮件，那么你需要确保包含在邮件头部的换行符能够引发错误或者被去掉。 你或许想仔细阅读 <tt class="docutils literal"><span class="pre">django.core.mail</span></tt> 中的 <tt class="docutils literal"><span class="pre">SateMIMEText</span></tt> 类来看看Django是如何做到这一点的。</p></div></div><div class="section" id="id9"><span id="cn109"></span><h2 class="cn" id="cn109">目录遍历</h2><p class="cn" id="cn110"><em>目录遍历</em> ：是另外一种注入方式的攻击，在这种攻击中，恶意用户诱骗文件系统代码对Web服务器不应该访问的文件进行读取和/或写入操作。</p><p class="cn" id="cn111">例子可以是这样的，某个视图试图在没有仔细对文件进行防毒处理的情况下从磁盘上读取文件：</p><pre class="cn literal-block" id="cn113">def dump_file(request):filename = request.GET[&quot;filename&quot;]filename = os.path.join(BASE_PATH, filename)content = open(filename).read()# ...</pre><p class="cn" id="cn114">尽管一眼看上去，视图通过 <tt class="docutils literal"><span class="pre">BASE_PATH</span></tt> （通过使用 <tt class="docutils literal"><span class="pre">os.path.join</span></tt> ）限制了对于文件的访问，但如果攻击者使用了包含 <tt class="docutils literal"><span class="pre">..</span></tt> （两个句号，父目录的一种简写形式）的文件名，她就能够访问到 <tt class="docutils literal"><span class="pre">BASE_PATH</span></tt> 目录结构以上的文件。对她来说，发现究竟使用几个点号只是时间问题，比如这样：<tt class="docutils literal"><span class="pre">../../../../../etc/passwd</span></tt>。</p><p class="cn" id="cn115">任何不做适当转义地读取文件操作，都可能导致这样的问题。 允许 <em>写</em> 操作的视图同样容易发生问题，而且结果往往更加可怕。</p><p class="cn" id="cn116">这个问题的另一种表现形式，出现在根据URL和其他的请求信息动态地加载模块。 一个众所周知的例子来自于Ruby on Rails。 在2006年上半年之前，Rails使用类似于 <tt class="docutils literal"><span class="pre">http://example.com/person/poke/1</span></tt> 这样的URL直接加载模块和调用函数。 结果是，精心构造的URL，可以自动地调用任意的代码，包括数据库的清空脚本。</p><div class="section" id="id10"><span id="cn117"></span><h3 class="cn" id="cn117">解决方案</h3><p class="cn" id="cn118">如果你的代码需要根据用户的输入来读写文件，你就需要确保，攻击者不能访问你所禁止访问的目录。</p><p class="cn" id="cn119">备注</p><p class="cn" id="cn120">不用多说，你 <em>永远</em> 不要在编写可以读取任何位置上的文件的代码！</p><p class="cn" id="cn121">Django内置的静态内容视图是做转义的一个好的示例（在 <tt class="docutils literal"><span class="pre">django.views.static</span></tt> 中）。这是相关代码：</p><pre class="cn literal-block" id="cn123">import osimport posixpath# ...path = posixpath.normpath(urllib.unquote(path))newpath = ''for part in path.split('/'):if not part:# strip empty path componentscontinuedrive, part = os.path.splitdrive(part)head, part = os.path.split(part)if part in (os.curdir, os.pardir):# strip '.' and '..' in pathcontinuenewpath = os.path.join(newpath, part).replace('\\', '/')</pre><p class="cn" id="cn124">Django不读取文件（除非你使用 <tt class="docutils literal"><span class="pre">static.serve</span></tt> 函数，但也受到了上面这段代码的保护），因此这种危险对于核心代码的影响就要小得多。</p><p class="cn" id="cn125">更进一步，URLconf抽象层的使用，意味着不经过你明确的指定，Django <em>决不会</em> 装载代码。 通过创建一个URL来让Django装载没有在URLconf中出现的东西，是不可能发生的。</p></div></div><div class="section" id="id11"><span id="cn126"></span><h2 class="cn" id="cn126">暴露错误消息</h2><p class="cn" id="cn127">在开发过程中，通过浏览器检查错误和跟踪异常是非常有用的。 Django提供了漂亮且详细的debug信息，使得调试过程更加容易。</p><p class="cn" id="cn128">然而，一旦在站点上线以后，这些消息仍然被显示，它们就可能暴露你的代码或者是配置文件内容给攻击者。</p><p class="cn" id="cn129">还有，错误和调试消息对于最终用户而言是毫无用处的。 Django的理念是，站点的访问者永远不应该看到与应用相关的出错消息。 如果你的代码抛出了一个没有处理的异常，网站访问者不应该看到调试信息或者 <em>任何</em> 代码片段或者Python（面向开发者）出错消息。 访问者应该只看到友好的无法访问的页面。</p><p class="cn" id="cn130">当然，开发者需要在debug时看到调试信息。 因此，框架就要将这些出错消息显示给受信任的网站开发者，而要向公众隐藏。</p><div class="section" id="id12"><span id="cn131"></span><h3 class="cn" id="cn131">解决方案</h3><p class="cn" id="cn132">正如我们在第12章所提到的，Django的`` DEBUG`` 设置控制这些错误信息的显示。 当你准备部署时请确认把这个设置为：`` False`` 。</p><p class="cn" id="cn133">在Apache和mod_python下开发的人员，还要保证在Apache的配置文件中关闭 <tt class="docutils literal"><span class="pre">PythonDebug</span> <span class="pre">Off</span></tt> 选项，这个会在Django被加载以前去除出错消息。</p></div></div><div class="section" id="id13"><span id="cn134"></span><h2 class="cn" id="cn134">安全领域的总结</h2><p class="cn" id="cn135">我们希望关于安全问题的讨论，不会太让你感到恐慌。 Web是一个处处布满陷阱的世界，但是只要有一些远见，你就能拥有安全的站点。</p><p class="cn" id="cn136">永远记住，Web安全是一个不断发展的领域。如果你正在阅读这本书的停止维护的那些版本，请阅读最新版本的这个部分来检查最新发现的漏洞。 事实上，每周或者每月花点时间挖掘Web应用安全，并且跟上最新的动态是一个很好的主意。 花费很少，但是对你网站和用户的保护确是无价的。</p></div><div class="section" id="id14"><span id="cn137"></span><h2 class="cn" id="cn137">接下来？</h2><p class="cn" id="cn138">你已经完成了我们安排的程序。 以下的附录内容中包含了可能在你的Djang项目中用得上的引用资源.</p><p class="cn" id="cn139">在运行你的Django网站时，无论是为你或几个朋友的小网站，或者是下一个google，我们祝你好运。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter19.html">| 上一章</a> |<a href="index.html">目  录</a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>