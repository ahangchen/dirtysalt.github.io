<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十八章： 集成已有的数据库和应用</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter17.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter19.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第十八章： 集成已有的数据库和应用</h1><p class="cn" id="cn1">Django最适合于所谓的green-field开发，即从头开始的一个项目，正如你在一块还长着青草的未开垦的土地上从零开始建造一栋建筑一般。 然而，尽管Django偏爱从头开始的项目，将这个框架和以前遗留的数据库和应用相整合仍然是可能的。 本章就将介绍一些整合的技巧。</p><div class="section" id="id2"><span id="cn2"></span><h2 class="cn" id="cn2">与遗留数据库整合</h2><p class="cn" id="cn3">Django的数据库层从Python代码生成SQL schemas&#8212;但是对于遗留数据库，你已经拥有SQL schemas. 这种情况,你需要为已经存在的数据表创建model. 为此,Django自带了一个可以通过读取您的数据表结构来生成model的工具. 该辅助工具称为inspectdb,你可以通过执行<tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">inspectdb</span></tt>来调用它.</p><div class="section" id="inspectdb"><span id="cn4"></span><h3 class="cn" id="cn4">使用 <tt class="docutils literal"><span class="pre">inspectdb</span></tt></h3><p class="cn" id="cn5"><tt class="docutils literal"><span class="pre">inspectdb</span></tt>工具自省你配置文件指向的数据库，针对每一个表生成一个Django模型，然后将这些Python模型的代码显示在系统的标准输出里面。</p><p class="cn" id="cn6">下面是一个从头开始的针对一个典型的遗留数据库的整合过程。 两个前提条件是安装了Django和一个传统数据库。</p><blockquote><p class="cn" id="cn7">通过运行django-admin.py startproject mysite (这里 <tt class="docutils literal"><span class="pre">mysite</span></tt> 是你的项目的名字)建立一个Django项目。 好的，那我们在这个例子中就用这个 <tt class="docutils literal"><span class="pre">mysite</span></tt> 作为项目的名字。</p><p class="cn" id="cn8">编辑项目中的配置文件, <tt class="docutils literal"><span class="pre">mysite/settings.py</span></tt> ,告诉Django你的数据库连接参数和数据库名。 具体的说，要提供 <tt class="docutils literal"><span class="pre">DATABASE_NAME</span></tt> , <tt class="docutils literal"><span class="pre">DATABASE_ENGINE</span></tt> , <tt class="docutils literal"><span class="pre">DATABASE_USER</span></tt> , <tt class="docutils literal"><span class="pre">DATABASE_PASSWORD</span></tt> , <tt class="docutils literal"><span class="pre">DATABASE_HOST</span></tt> , 和 <tt class="docutils literal"><span class="pre">DATABASE_PORT</span></tt> 这些配置信息.。 (请注意其中的一些设置是可选的。 更多信息参见第5章)</p><p class="cn" id="cn9">通过运行 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">mysite/manage.py</span> <span class="pre">startapp</span> <span class="pre">myapp</span></tt> (这里 <tt class="docutils literal"><span class="pre">myapp</span></tt> 是你的应用的名字)创建一个Django应用。 这里我们使用<tt class="docutils literal"><span class="pre">myapp</span></tt> 做为应用名。</p><p class="cn" id="cn10">运行命令 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">mysite/manage.py</span> <span class="pre">inspectdb</span></tt>。这将检查<tt class="docutils literal"><span class="pre">DATABASE_NAME</span></tt> 数据库中所有的表并打印出为每张表生成的模型类。 看一看输出结果以了解inspectdb能做些什么。</p><p class="cn" id="cn11">将标准shell的输出重定向，保存输出到你的应用的 <tt class="docutils literal"><span class="pre">models.py</span></tt> 文件里：</p></blockquote><pre class="cn literal-block" id="cn13">python mysite/manage.py inspectdb &gt; mysite/myapp/models.py</pre><blockquote><p class="cn" id="cn14">编辑 <tt class="docutils literal"><span class="pre">mysite/myapp/models.py</span></tt> 文件以清理生成的 models 并且做一些必要的自定义。 针对这个，下一个节有些好的建议。</p></blockquote></div><div class="section" id="models"><span id="cn15"></span><h3 class="cn" id="cn15">清理生成的Models</h3><p class="cn" id="cn16">如你可能会预料到的，数据库自省不是完美的，你需要对产生的模型代码做些许清理。 这里提醒一点关于处理生成 models 的要点:</p><blockquote><p class="cn" id="cn17">数据库的每一个表都会被转化为一个model类 (也就是说，数据库的表和model 类之间是一对一的映射)。 这意味着你需要为多对多连接的表，重构其models 为 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> 的对象。</p><p class="cn" id="cn18">所生成的每一个model中的每个字段都拥有自己的属性，包括id主键字段。 但是，请注意，如果某个model没有主键的话，那么Django会自动为其增加一个id主键字段。 这样一来，你也许希望移除这样的代码行。</p></blockquote><pre class="cn literal-block" id="cn20">id = models.IntegerField(primary_key=True)</pre><blockquote><p class="cn" id="cn21">这样做并不是仅仅因为这些行是冗余的，而且如果当你的应用需要向这些表中增加新记录时，这些行会导致某些问题。</p><p class="cn" id="cn22">每一个字段类型，如CharField、DateField， 是通过查找数据库列类型如VARCHAR,DATE来确定的。如果inspectdb无法把某个数据库字段映射到model字段上，它会使用TextField字段进行代替，并且会在所生成model字段后面加入Python注释“该字段类型是猜的”。 对这要当心，如果必要的话，更改字段类型。</p><p class="cn" id="cn23">如果你的数据库中的某个字段在Django中找不到合适的对应物，你可以放心的略过它。 Django模型层不要求必须导入你数据库表中的每个列。</p><p class="cn" id="cn24">如果数据库中某个列的名字是Python的保留字（比如pass、class或者for等），inspectdb会在每个属性名后附加上_field，并将db_column属性设置为真实的字段名（也就是pass,class或者for等）。</p><p class="cn" id="cn25">例如，某张表中包含一个INT类型的列，其列名为for，那么所生成的model将会包含如下所示的一个字段：</p></blockquote><pre class="cn literal-block" id="cn27">for_field = models.IntegerField(db_column='for')</pre><blockquote><p class="cn" id="cn28"><tt class="docutils literal"><span class="pre">inspectdb</span></tt> 会在该字段后加注 <tt class="docutils literal"><span class="pre">‘字段重命名，因为它是一个Python保留字’</span></tt> 。</p><p class="cn" id="cn29">如果数据库中某张表引用了其他表（正如大多数数据库系统所做的那样），你需要适当的修改所生成model的顺序，以使得这种引用能够正确映射。 例如，model Book拥有一个针对于model Author的外键，那么后者应该先于前者被定义。如果你想创建一个指向尚未定义的model的关系，那么可以使用包含model名的字符串，而不是model对象本身。</p><p class="cn" id="cn30">对于PostgreSQL,MySQL和SQLite数据库系统，inspectdb能够自动检测出主键关系。 也就是说，它会在合适的位置插入primary_key=True。 而对于其他数据库系统，你必须为每一个model中至少一个字段插入这样的语句，因为Django的model要求必须拥有一个primary_key=True的字段。</p><p class="cn" id="cn31">外键检测仅对PostgreSQL，还有MySQL表中的某些特定类型生效。 至于其他数据库，外键字段将在假定其为INT列的情况下被自动生成为IntegerField。</p></blockquote></div></div><div class="section" id="id3"><span id="cn32"></span><h2 class="cn" id="cn32">与认证系统的整合</h2><p class="cn" id="cn33">将Django与其他现有认证系统的用户名和密码或者认证方法进行整合是可以办到的。</p><p class="cn" id="cn34">例如，你所在的公司也许已经安装了LDAP，并且为每一个员工都存储了相应的用户名和密码。 如果用户在LDAP和基于Django的应用上拥有独立的账号，那么这时无论对于网络管理员还是用户自己来说，都是一件很令人头痛的事儿。</p><p class="cn" id="cn35">为了解决这样的问题，Django认证系统能让您以插件方式与其他认证资源进行交互。 您可以覆盖Diango默认的基于数据库的模式，您还可以使用默认的系统与其他系统进行交互。</p><div class="section" id="id4"><span id="cn36"></span><h3 class="cn" id="cn36">指定认证后台</h3><p class="cn" id="cn37">在后台，Django维护了一个用于检查认证的后台列表。 当某个人调用 <tt class="docutils literal"><span class="pre">django.contrib.auth.authenticate()</span></tt> (如14章中所述)时，Django会尝试对其认证后台进行遍历认证。 如果第一个认证方法失败，Django会尝试认证第二个，以此类推，一直到尝试完。</p><p class="cn" id="cn38">认证后台列表在AUTHENTICATION_BACKENDS设置中进行指定。 它应该是指向知道如何认证的Python类的Python路径的名字数组。 这些类可以在你Python路径的任何位置。</p><p class="cn" id="cn39">默认情况下，AUTHENTICATION_BACKENDS被设置为如下：</p><pre class="cn literal-block" id="cn41">('django.contrib.auth.backends.ModelBackend',)</pre><p class="cn" id="cn42">那就是检测Django用户数据库的基本认证模式。</p><p class="cn" id="cn43">AUTHENTICATION_BACKENDS的顺序很重要，如果用户名和密码在多个后台中都是有效的，那么Django将会在第一个正确匹配后停止进一步的处理。</p></div><div class="section" id="id5"><span id="cn44"></span><h3 class="cn" id="cn44">编写认证后台</h3><p class="cn" id="cn45">一个认证后台其实就是一个实现了如下两个方法的类：<tt class="docutils literal"><span class="pre">get_user(id)</span></tt> 和 <tt class="docutils literal"><span class="pre">authenticate(**credentials)</span></tt> 。</p><p class="cn" id="cn46">方法 <tt class="docutils literal"><span class="pre">get_user</span></tt> 需要一个参数 <tt class="docutils literal"><span class="pre">id</span></tt> ，这个 <tt class="docutils literal"><span class="pre">id</span></tt> 可以是用户名，数据库ID或者其他任何数值，该方法会返回一个 <tt class="docutils literal"><span class="pre">User</span></tt> 对象。</p><p class="cn" id="cn47">方法 <tt class="docutils literal"><span class="pre">authenticate</span></tt> 使用证书作为关键参数。 大多数情况下，该方法看起来如下：</p><pre class="cn literal-block" id="cn49">class MyBackend(object):def authenticate(self, username=None, password=None):# Check the username/password and return a User.</pre><p class="cn" id="cn50">但是有时候它也可以认证某个短语，例如：</p><pre class="cn literal-block" id="cn52">class MyBackend(object):def authenticate(self, token=None):# Check the token and return a User.</pre><p class="cn" id="cn53">每一个方法中， <tt class="docutils literal"><span class="pre">authenticate</span></tt> 都应该检测它所获取的证书，并且当证书有效时，返回一个匹配于该证书的 <tt class="docutils literal"><span class="pre">User</span></tt> 对象，如果证书无效那么返回 <tt class="docutils literal"><span class="pre">None</span></tt> 。 如果它们不合法，就返回<tt class="docutils literal"><span class="pre">None</span></tt>。</p><p class="cn" id="cn54">如14章中所述，Django管理系统紧密连接于其自己后台数据库的 <tt class="docutils literal"><span class="pre">User</span></tt> 对象。 实现这个功能的最好办法就是为您的后台数据库（如LDAP目录，外部SQL数据库等）中的每个用户都创建一个对应的Django User对象。 您可以提前写一个脚本来完成这个工作，也可以在某个用户第一次登陆的时候在 <tt class="docutils literal"><span class="pre">authenticate</span></tt> 方法中进行实现。</p><p class="cn" id="cn55">以下是一个示例后台程序，该后台用于认证定义在 <tt class="docutils literal"><span class="pre">setting.py</span></tt> 文件中的username和password变量，并且在该用户第一次认证的时候创建一个相应的Django <tt class="docutils literal"><span class="pre">User</span></tt> 对象。</p><pre class="cn literal-block" id="cn57">from django.conf import settingsfrom django.contrib.auth.models import User, check_passwordclass SettingsBackend(object):&quot;&quot;&quot;Authenticate against the settings ADMIN_LOGIN and ADMIN_PASSWORD.Use the login name, and a hash of the password. For example:ADMIN_LOGIN = 'admin'ADMIN_PASSWORD = 'sha1$4e987$afbcf42e21bd417fb71db8c66b321e9fc33051de'&quot;&quot;&quot;def authenticate(self, username=None, password=None):login_valid = (settings.ADMIN_LOGIN == username)pwd_valid = check_password(password, settings.ADMIN_PASSWORD)if login_valid and pwd_valid:try:user = User.objects.get(username=username)except User.DoesNotExist:# Create a new user. Note that we can set password# to anything, because it won't be checked; the password# from settings.py will.user = User(username=username, password='get from settings.py')user.is_staff = Trueuser.is_superuser = Trueuser.save()return userreturn Nonedef get_user(self, user_id):try:return User.objects.get(pk=user_id)except User.DoesNotExist:return None</pre><p class="cn" id="cn58">更多认证模块的后台, 参考Django文档。</p></div></div><div class="section" id="web"><span id="cn59"></span><h2 class="cn" id="cn59">和遗留Web应用集成</h2><p class="cn" id="cn60">同由其他技术驱动的应用一样，在相同的Web服务器上运行Django应用也是可行的。 最简单直接的办法就是利用Apaches配置文件httpd.conf，将不同的URL类型分发至不同的技术。 （请注意，第12章包含了在Apache/mod_python上配置Django的相关内容，因此在尝试本章集成之前花些时间去仔细阅读第12章或许是值得的。)</p><p class="cn" id="cn61">关键在于只有在您的httpd.conf文件中进行了相关定义，Django对某个特定的URL类型的驱动才会被激活。 在第12章中解释的缺省部署方案假定您需要Django去驱动某个特定域上的每一个页面。</p><pre class="cn literal-block" id="cn63">&lt;Location &quot;/&quot;&gt;SetHandler python-programPythonHandler django.core.handlers.modpythonSetEnv DJANGO_SETTINGS_MODULE mysite.settingsPythonDebug On&lt;/Location&gt;</pre><p class="cn" id="cn64">这里, <tt class="docutils literal"><span class="pre">&lt;Location</span> <span class="pre">&quot;/&quot;&gt;</span></tt> 这一行表示用Django处理每个以根开头的URL.</p><p class="cn" id="cn65">精妙之处在于Django将&lt;location&gt;指令值限定于一个特定的目录树上。 举个例子，比如说您有一个在某个域中驱动大多数页面的遗留PHP应用，并且您希望不中断PHP代码的运行而在../admin/位置安装一个Django域。 要做到这一点，您只需将&lt;location&gt;值设置为/admin/即可。</p><pre class="cn literal-block" id="cn67">&lt;Location &quot;/admin/&quot;&gt;SetHandler python-programPythonHandler django.core.handlers.modpythonSetEnv DJANGO_SETTINGS_MODULE mysite.settingsPythonDebug On&lt;/Location&gt;</pre><p class="cn" id="cn68">有了这样的设置，只有那些以/admin/开头的URL地址才会触发Django去进行处理。 其他页面会使用已存在的设置。</p><p class="cn" id="cn69">请注意，把Diango绑定到的合格的URL（比如在本章例子中的 <tt class="docutils literal"><span class="pre">/admin/</span></tt> ）并不会影响其对URL的解析。 绝对路径对Django才是有效的（例如 <tt class="docutils literal"><span class="pre">/admin/people/person/add/</span></tt> ），而非截断后的URL（例如 <tt class="docutils literal"><span class="pre">/people/person/add/</span></tt> ）。这意味着你的根URLconf必须包含前缀 <tt class="docutils literal"><span class="pre">/admin/</span></tt> 。</p></div><div class="section" id="id6"><span id="cn70"></span><h2 class="cn" id="cn70">下一章</h2><p class="cn" id="cn71">如果你的母语是英语, 你可能就不会注意到许多Django admin网站中最酷的特性功能。 它支持超过50种语言! Django 的国际化框架使其成为可能( 还有Django志愿翻译者的努力 ) ` 下一章 &lt;chapter19.html&gt;`__ 介绍如何使用这个框架来提供本地化的Django网站。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter17.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter19.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>