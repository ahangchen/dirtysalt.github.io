<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十一章：通用视图</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter10.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter12.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第11章 通用视图</h1><p class="cn" id="cn1">这里需要再次回到本书的主题： 在最坏的情况下， Web 开发是一项无聊而且单调的工作。 到目前为止，我们已经介绍了 Django 怎样在模型和模板的层面上减小开发的单调性，但是 Web 开发在视图的层面上，也经历着这种令人厌倦的事情。</p><p class="cn" id="cn2">Django的<em>通用视图</em> 可以减少这些痛苦。 它抽象出一些在视图开发中常用的代码和模式，这样就可以在无需编写大量代码的情况下，快速编写出常用的数据视图。 事实上，前面章节中的几乎所有视图的示例都可以在通用视图的帮助下重写。</p><p class="cn" id="cn3">在第八章简单的向大家介绍了怎样使视图更加的“通用”。 回顾一下，我们会发现一些比较常见的任务，比如显示一系列对象，写一段代码来显示 <em>任何</em> 对象内容。 解决办法就是传递一个额外的参数到URLConf。</p><p class="cn" id="cn4">Django内建通用视图可以实现如下功能：</p><ul class="simple"><li class="cn" id="cn5"><p class="first cn" id="cn5">完成常用的简单任务： 重定向到另一个页面以及渲染一个指定的模板。</p></li></ul><ul class="simple"><li class="cn" id="cn6"><p class="first cn" id="cn6">显示列表和某个特定对象的详细内容页面。 第8章中提到的 <tt class="docutils literal"><span class="pre">event_list</span></tt> 和 <tt class="docutils literal"><span class="pre">entry_list</span></tt> 视图就是列表视图的一个例子。 一个单一的 event 页面就是我们所说的详细内容页面。</p></li></ul><ul class="simple"><li class="cn" id="cn7"><p class="first cn" id="cn7">呈现基于日期的数据的年/月/日归档页面，关联的详情页面，最新页面。 Django Weblogs (<a class="reference external" href="http://www.djangoproject.com/weblog/">http://www.djangoproject.com/weblog/</a>)的年、月、日的归档就是使用通用视图 架构的，就像是典型的新闻报纸归档。</p></li></ul><p class="cn" id="cn8">综上所述，这些视图为开发者日常开发中常见的任务提供了易用的接口。</p><div class="section" id="id2"><span id="cn9"></span><h2 class="cn" id="cn9">使用通用视图</h2><p class="cn" id="cn10">使用通用视图的方法是在URLconf文件中创建配置字典，然后把这些字典作为URLconf元组的第三个成员。 （对于这个技巧的应用可以参看第八章向视图传递额外选项。）</p><p class="cn" id="cn11">例如，下面是一个呈现静态“关于”页面的URLconf：</p><pre class="cn literal-block" id="cn13">from django.conf.urls.defaults import *from django.views.generic.simple import direct_to_templateurlpatterns = patterns('',(r'^about/$', direct_to_template, {'template': 'about.html'}))</pre><p class="cn" id="cn14">一眼看上去似乎有点不可思议，不需要编写代码的视图！它和第八章中的例子完全一样：<tt class="docutils literal"><span class="pre">direct_to_template</span></tt>视图仅仅是直接从传递过来的额外参数获取信息并用于渲染视图。</p><p class="cn" id="cn15">因为通用视图都是标准的视图函数，我们可以在我们自己的视图中重用它。 例如，我们扩展 about例子，把映射的URL从 <tt class="docutils literal"><span class="pre">/about//</span></tt>修改到一个静态渲染 <tt class="docutils literal"><span class="pre">about/.html</span></tt> 。 我们首先修改URL配置以指向新的视图函数：</p><pre class="cn literal-block" id="cn17">from django.conf.urls.defaults import *from django.views.generic.simple import direct_to_template**from mysite.books.views import about_pages**urlpatterns = patterns('',(r'^about/$', direct_to_template, {'template': 'about.html'}),**(r'^about/(\w+)/$', about_pages),**)</pre><p class="cn" id="cn18">接下来，我们编写 <tt class="docutils literal"><span class="pre">about_pages</span></tt> 视图的代码：</p><pre class="cn literal-block" id="cn20">from django.http import Http404from django.template import TemplateDoesNotExistfrom django.views.generic.simple import direct_to_templatedef about_pages(request, page):try:return direct_to_template(request, template=&quot;about/%s.html&quot; % page)except TemplateDoesNotExist:raise Http404()</pre><p class="cn" id="cn21">在这里我们象使用其他函数一样使用 <tt class="docutils literal"><span class="pre">direct_to_template</span></tt> 。 因为它返回一个<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>对象，我们只需要简单的返回它就好了。 这里唯一有点棘手的事情是要处理找不到模板的情况。 我们不希望一个不存在的模板导致一个服务端错误，所以我们捕获TemplateDoesNotExist异常并且返回404错误来作为替代。</p><p class="cn" id="cn22">这里有没有安全性问题？</p><p class="cn" id="cn23">眼尖的读者可能已经注意到一个可能的安全漏洞： 我们直接使用从客户端浏览器得到的数据构造模板名称(<tt class="docutils literal"><span class="pre">template=&quot;about/%s.html&quot;</span> <span class="pre">%</span> <span class="pre">page</span></tt> )。乍看起来，这像是一个经典的 <em>目录跨越（directory traversal）</em> 攻击（详情请看第20章）。 事实真是这样吗？</p><p class="cn" id="cn24">完全不是。 是的，一个恶意的 <tt class="docutils literal"><span class="pre">page</span></tt> 值可以导致目录跨越，但是尽管 <tt class="docutils literal"><span class="pre">page</span></tt> <em>是</em> 从请求的URL中获取的，但并不是所有的值都会被接受。 这就是URL配置的关键所在： 我们使用正则表达式 <tt class="docutils literal"><span class="pre">\w+</span></tt> 来从URL里匹配 <tt class="docutils literal"><span class="pre">page</span></tt> ，而 <tt class="docutils literal"><span class="pre">\w</span></tt> 只接受字符和数字。 因此，任何恶意的字符 （例如在这里是点 <tt class="docutils literal"><span class="pre">.</span></tt> 和正斜线 <tt class="docutils literal"><span class="pre">/</span></tt> ）将在URL解析时被拒绝，根本不会传递给视图函数。</p></div><div class="section" id="id3"><span id="cn25"></span><h2 class="cn" id="cn25">对象的通用视图</h2><p class="cn" id="cn26"><tt class="docutils literal"><span class="pre">direct_to_template</span></tt> 毫无疑问是非常有用的，但Django通用视图最有用的地方是呈现数据库中的数据。因为这个应用实在太普遍了，Django带有很多内建的通用视图来帮助你很容易 地生成对象的列表和明细视图。</p><p class="cn" id="cn27">让我们先看看其中的一个通用视图： 对象列表视图。 我们使用第五章中的 <tt class="docutils literal"><span class="pre">Publisher</span></tt> 来举例：</p><pre class="cn literal-block" id="cn29">class Publisher(models.Model):name = models.CharField(max_length=30)address = models.CharField(max_length=50)city = models.CharField(max_length=60)state_province = models.CharField(max_length=30)country = models.CharField(max_length=50)website = models.URLField()def __unicode__(self):return self.nameclass Meta:ordering = ['name']</pre><p class="cn" id="cn30">要为所有的出版商创建一个列表页面，我们使用下面的URL配置：</p><pre class="cn literal-block" id="cn32">from django.conf.urls.defaults import *from django.views.generic import list_detailfrom mysite.books.models import Publisherpublisher_info = {'queryset': Publisher.objects.all(),}urlpatterns = patterns('',(r'^publishers/$', list_detail.object_list, publisher_info))</pre><p class="cn" id="cn33">这就是所要编写的所有Python代码。 当然，我们还需要编写一个模板。 我们可以通过在额外参数字典中包含一个<tt class="docutils literal"><span class="pre">template_name</span></tt>键来显式地告诉<tt class="docutils literal"><span class="pre">object_list</span></tt>视图使用哪个模板：</p><pre class="cn literal-block" id="cn35">from django.conf.urls.defaults import *from django.views.generic import list_detailfrom mysite.books.models import Publisherpublisher_info = {'queryset': Publisher.objects.all(),**'template_name': 'publisher_list_page.html',**}urlpatterns = patterns('',(r'^publishers/$', list_detail.object_list, publisher_info))</pre><p class="cn" id="cn36">在缺少<tt class="docutils literal"><span class="pre">template_name</span></tt>的情况下，<tt class="docutils literal"><span class="pre">object_list</span></tt>通用视图将自动使用一个对象名称。 在这个例子中，这个推导出的模板名称将是 <tt class="docutils literal"><span class="pre">&quot;books/publisher_list.html&quot;</span></tt> ，其中books部分是定义这个模型的app的名称， publisher部分是这个模型名称的小写。</p><p class="cn" id="cn37">这个模板将按照 context 中包含的变量 <tt class="docutils literal"><span class="pre">object_list</span></tt> 来渲染，这个变量包含所有的书籍对象。 一个非常简单的模板看起来象下面这样：</p><pre class="cn literal-block" id="cn39">{% extends &quot;base.html&quot; %}{% block content %}&lt;h2&gt;Publishers&lt;/h2&gt;&lt;ul&gt;{% for publisher in object_list %}&lt;li&gt;{{ publisher.name }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;{% endblock %}</pre><p class="cn" id="cn40">(注意，这里我们假定存在一个<tt class="docutils literal"><span class="pre">base.html</span></tt>模板，它和我们第四章中的一样。）</p><p class="cn" id="cn41">这就是所有要做的事。 要使用通用视图酷酷的特性只需要修改参数字典并传递给通用视图函数。 附录D是通用视图的完全参考资料；本章接下来的章节将讲到自定义和扩展通用视图的一些方法。</p></div><div class="section" id="id4"><span id="cn42"></span><h2 class="cn" id="cn42">扩展通用视图</h2><p class="cn" id="cn43">毫无疑问，使用通用视图可以充分加快开发速度。 然而，在多数的工程中，也会出现通用视图不能 满足需求的情况。 实际上，刚接触Django的开发者最常见的问题就是怎样使用通用视图来处理更多的情况。</p><p class="cn" id="cn44">幸运的是，几乎每种情况都有相应的方法来简易地扩展通用视图以处理这些情况。 这时总是使用下面的 这些方法。</p><div class="section" id="context"><span id="cn45"></span><h3 class="cn" id="cn45">制作友好的模板Context</h3><p class="cn" id="cn46">你也许已经注意到范例中的出版商列表模板在变量 <tt class="docutils literal"><span class="pre">object_list</span></tt> 里保存所有的书籍。这个方法工作的很好，只是对编写模板的人不太友好。 他们必须知道这里正在处理的是书籍。 更好的变量名应该是<tt class="docutils literal"><span class="pre">publisher_list</span></tt>，这样变量所代表的内容就显而易见了。</p><p class="cn" id="cn47">我们可以很容易地像下面这样修改 <tt class="docutils literal"><span class="pre">template_object_name</span></tt> 参数的名称：</p><pre class="cn literal-block" id="cn49">from django.conf.urls.defaults import *from django.views.generic import list_detailfrom mysite.books.models import Publisherpublisher_info = {'queryset': Publisher.objects.all(),'template_name': 'publisher_list_page.html','template_object_name': 'publisher',}urlpatterns = patterns('',(r'^publishers/$', list_detail.object_list, publisher_info))</pre><p class="cn" id="cn50">在模板中，通用视图会通过在<tt class="docutils literal"><span class="pre">template_object_name</span></tt>后追加一个<tt class="docutils literal"><span class="pre">_list</span></tt>的方式来创建一个表示列表项目的变量名。</p><p class="cn" id="cn51">使用有用的 <tt class="docutils literal"><span class="pre">template_object_name</span></tt> 总是个好想法。 你的设计模板的合作伙伴会感谢你的。</p></div><div class="section" id="id5"><span id="cn52"></span><h3 class="cn" id="cn52">添加额外的Context</h3><p class="cn" id="cn53">你常常需要呈现比通用视图提供的更多的额外信息。 例如，考虑一下在每个出版商的详细页面显示所有其他出版商列表。 <tt class="docutils literal"><span class="pre">object_detail</span></tt> 通用视图为context提供了出版商信息，但是看起来没有办法在模板中 获取 <em>所有</em> 出版商列表。</p><p class="cn" id="cn54">这是解决方法： 所有的通用视图都有一个额外的可选参数 <tt class="docutils literal"><span class="pre">extra_context</span></tt> 。这个参数是一个字典数据类型，包含要添加到模板的context中的额外的对象。 所以要给视图提供所有出版商的列表，我们就用这样的info字典：</p><pre class="cn literal-block" id="cn56">publisher_info = {'queryset': Publisher.objects.all(),'template_object_name': 'publisher',**'extra_context': {'book_list': Book.objects.all()}**}</pre><p class="cn" id="cn57">这样就把一个 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">book_list</span> <span class="pre">}}</span></tt> 变量放到模板的context中。这个方法可以用来传递任意数据 到通用视图模板中去，非常方便。 这是非常方便的</p><p class="cn" id="cn58">不过，这里有一个很隐蔽的BUG，不知道你发现了没有？</p><p class="cn" id="cn59">我们现在来看一下， <tt class="docutils literal"><span class="pre">extra_context</span></tt> 里包含数据库查询的问题。因为在这个例子中，我们把 <tt class="docutils literal"><span class="pre">Publisher.objects.all()</span></tt> 放在URLconf中，它只会执行一次（当URLconf第一次加载的时候）。 当你添加或删除出版商，你会发现在重启Web服务器之前，通用视图不会反映出这些修改（有关QuerySet何时被缓存和赋值的更多信息请参考附录C中“缓存与查询集”一节）。</p><p class="cn" id="cn60">备注</p><p class="cn" id="cn61">这个问题不适用于通用视图的 <tt class="docutils literal"><span class="pre">queryset</span></tt> 参数。 因为Django知道有些特别的 QuerySet <em>永远不能</em> 被缓存，通用视图在渲染前都做了缓存清除工作。</p><p class="cn" id="cn62">解决这个问题的办法是在 <em>extra_context</em> 中用一个回调（callback）来代替使用一个变量。任何传递给<tt class="docutils literal"><span class="pre">extra_context</span></tt>的可调用对象（例如一个函数）都会在每次视图渲染前执行（而不是只执行一次）。 你可以象这样定义一个函数：</p><pre class="cn literal-block" id="cn64">**def get_books():****return Book.objects.all()**publisher_info = {'queryset': Publisher.objects.all(),'template_object_name': 'publisher','extra_context': **{'book_list': get_books}**}</pre><p class="cn" id="cn65">或者你可以使用另一个不是那么清晰但是很简短的方法，事实上 <tt class="docutils literal"><span class="pre">Publisher.objects.all</span></tt> 本身就是可以调用的：</p><pre class="cn literal-block" id="cn67">publisher_info = {'queryset': Publisher.objects.all(),'template_object_name': 'publisher','extra_context': **{'book_list': Book.objects.all}**}</pre><p class="cn" id="cn68">注意 <tt class="docutils literal"><span class="pre">Book.objects.all</span></tt> 后面没有括号；这表示这是一个函数的引用，并没有真正调用它（通用视图将会在渲染时调用它）。</p></div><div class="section" id="id6"><span id="cn69"></span><h3 class="cn" id="cn69">显示对象的子集</h3><p class="cn" id="cn70">现在让我们来仔细看看这个 <tt class="docutils literal"><span class="pre">queryset</span></tt> 。 大多数通用视图有一个<tt class="docutils literal"><span class="pre">queryset</span></tt>参数，这个参数告诉视图要显示对象的集合 （有关QuerySet的解释请看第五章的 “选择对象”章节，详细资料请参看附录B）。</p><p class="cn" id="cn71">举一个简单的例子，我们打算对书籍列表按出版日期排序，最近的排在最前：</p><pre class="cn literal-block" id="cn73">book_info = {'queryset': Book.objects.order_by('-publication_date'),}urlpatterns = patterns('',(r'^publishers/$', list_detail.object_list, publisher_info),**(r'^books/$', list_detail.object_list, book_info),**)</pre><p class="cn" id="cn74">这是一个相当简单的例子，但是很说明问题。 当然，你通常还想做比重新排序更多的事。 如果你想要呈现某个特定出版商出版的所有书籍列表，你可以使用同样的技术：</p><pre class="cn literal-block" id="cn76">**apress_books = {****'queryset': Book.objects.filter(publisher__name='Apress Publishing'),****'template_name': 'books/apress_list.html'****}**urlpatterns = patterns('',(r'^publishers/$', list_detail.object_list, publisher_info),**(r'^books/apress/$', list_detail.object_list, apress_books),**)</pre><p class="cn" id="cn77">注意 在使用一个过滤的 <tt class="docutils literal"><span class="pre">queryset</span></tt> 的同时，我们还使用了一个自定义的模板名称。 如果我们不这么做，通用视图就会用以前的模板，这可能不是我们想要的结果。</p><p class="cn" id="cn78">同样要注意的是这并不是一个处理出版商相关书籍的最好方法。 如果我们想要添加另一个 出版商页面，我们就得在URL配置中写URL配置，如果有很多的出版商，这个方法就不能 接受了。在接下来的章节我们将来解决这个问题。</p></div><div class="section" id="id7"><span id="cn79"></span><h3 class="cn" id="cn79">用函数包装来处理复杂的数据过滤</h3><p class="cn" id="cn80">另一个常见的需求是按URL里的关键字来过滤数据对象。 之前，我们在URLconf中硬编码了出版商的名字，但是如果我们想用一个视图就显示某个任意指定的出版商的所有书籍，那该怎么办呢？ 我们可以通过对 <tt class="docutils literal"><span class="pre">object_list</span></tt> 通用视图进行包装来避免 写一大堆的手工代码。 按惯例，我们先从写URL配置开始：</p><pre class="cn literal-block" id="cn82">urlpatterns = patterns('',(r'^publishers/$', list_detail.object_list, publisher_info),**(r'^books/(\w+)/$', books_by_publisher),**)</pre><p class="cn" id="cn83">接下来，我们写 <tt class="docutils literal"><span class="pre">books_by_publisher</span></tt> 这个视图：</p><pre class="cn literal-block" id="cn85">from django.shortcuts import get_object_or_404from django.views.generic import list_detailfrom mysite.books.models import Book, Publisherdef books_by_publisher(request, name):# Look up the publisher (and raise a 404 if it can't be found).publisher = get_object_or_404(Publisher, name__iexact=name)# Use the object_list view for the heavy lifting.return list_detail.object_list(request,queryset = Book.objects.filter(publisher=publisher),template_name = 'books/books_by_publisher.html',template_object_name = 'book',extra_context = {'publisher': publisher})</pre><p class="cn" id="cn86">这样写没问题，因为通用视图就是Python函数。 和其他的视图函数一样，通用视图也是接受一些 参数并返回 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 对象。 因此，通过包装通用视图函数可以做更多的事。</p><p class="cn" id="cn87">注意</p><p class="cn" id="cn88">注意在前面这个例子中我们在 <tt class="docutils literal"><span class="pre">extra_context</span></tt>中传递了当前出版商这个参数。</p></div><div class="section" id="id8"><span id="cn89"></span><h3 class="cn" id="cn89">处理额外工作</h3><p class="cn" id="cn90">我们再来看看最后一个常用模式：</p><p class="cn" id="cn91">想象一下我们在 <tt class="docutils literal"><span class="pre">Author</span></tt> 对象里有一个 <tt class="docutils literal"><span class="pre">last_accessed</span></tt> 字段，我们用这个字段来记录最近一次对author的访问。 当然通用视图 <tt class="docutils literal"><span class="pre">object_detail</span></tt> 并不能处理这个问题，但是我们仍然可以很容易地编写一个自定义的视图来更新这个字段。</p><p class="cn" id="cn92">首先，我们需要在URL配置里设置指向到新的自定义视图：</p><pre class="cn literal-block" id="cn94">from mysite.books.views import author_detailurlpatterns = patterns('',# ...**(r'^authors/(?P&lt;author_id&gt;\d+)/$', author_detail),**# ...)</pre><p class="cn" id="cn95">接下来写包装函数：</p><pre class="cn literal-block" id="cn97">import datetimefrom django.shortcuts import get_object_or_404from django.views.generic import list_detailfrom mysite.books.models import Authordef author_detail(request, author_id):# Delegate to the generic view and get an HttpResponse.response = list_detail.object_detail(request,queryset = Author.objects.all(),object_id = author_id,)# Record the last accessed date. We do this *after* the call# to object_detail(), not before it, so that this won't be called# unless the Author actually exists. (If the author doesn't exist,# object_detail() will raise Http404, and we won't reach this point.)now = datetime.datetime.now()Author.objects.filter(id=author_id).update(last_accessed=now)return response</pre><p class="cn" id="cn98">注意</p><p class="cn" id="cn99">除非你添加 <tt class="docutils literal"><span class="pre">last_accessed</span></tt> 字段到你的 <tt class="docutils literal"><span class="pre">Author</span></tt> 模型并创建 <tt class="docutils literal"><span class="pre">books/author_detail.html</span></tt> 模板，否则这段代码不能真正工作。</p><p class="cn" id="cn100">我们可以用同样的方法修改通用视图的返回值。如果我们想要提供一个供下载用的 纯文本版本的author列表，我们可以用下面这个视图：</p><pre class="cn literal-block" id="cn102">def author_list_plaintext(request):response = list_detail.object_list(request,queryset = Author.objects.all(),mimetype = 'text/plain',template_name = 'books/author_list.txt')response[&quot;Content-Disposition&quot;] = &quot;attachment; filename=authors.txt&quot;return response</pre><p class="cn" id="cn103">这个方法之所以工作是因为通用视图返回的 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 对象可以象一个字典 一样的设置HTTP的头部。 随便说一下，这个 <tt class="docutils literal"><span class="pre">Content-Disposition</span></tt> 的含义是 告诉浏览器下载并保存这个页面，而不是在浏览器中显示它。</p></div></div><div class="section" id="id9"><span id="cn104"></span><h2 class="cn" id="cn104">下一章</h2><p class="cn" id="cn105">在这一章我们只讲了Django带的通用视图其中一部分，不过这些方法也适用于其他的 通用视图。 附录C详细地介绍了所有可用的视图，如果你想了解这些强大的特性，推荐你阅读一下。</p><p class="cn" id="cn106">这本书的高级语法部分到此结束。 在<a class="reference external" href="chapter12.html">下一章</a>, 我们讲解了Django应用的部署。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter10.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter12.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>