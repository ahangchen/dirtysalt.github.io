<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十章 模型高级进阶</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter09.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter11.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第10章： 数据模型高级进阶</h1><p class="cn" id="cn1">在第5章里，我们介绍了Django的数据层如何定义数据模型以及如何使用数据库API来创建、检索、更新以及删除记录 在这章里，我们将向你介绍Django在这方面的一些更高级功能。</p><div class="section" id="id2"><span id="cn2"></span><h2 class="cn" id="cn2">相关对象</h2><p class="cn" id="cn3">先让我们回忆一下在第五章里的关于书本(book)的数据模型：</p><pre class="cn literal-block" id="cn5">from django.db import modelsclass Publisher(models.Model):name = models.CharField(max_length=30)address = models.CharField(max_length=50)city = models.CharField(max_length=60)state_province = models.CharField(max_length=30)country = models.CharField(max_length=50)website = models.URLField()def __unicode__(self):return self.nameclass Author(models.Model):first_name = models.CharField(max_length=30)last_name = models.CharField(max_length=40)email = models.EmailField()def __unicode__(self):return u'%s %s' % (self.first_name, self.last_name)class Book(models.Model):title = models.CharField(max_length=100)authors = models.ManyToManyField(Author)publisher = models.ForeignKey(Publisher)publication_date = models.DateField()def __unicode__(self):return self.title</pre><p class="cn" id="cn6">如我们在第5章的讲解,获取数据库对象的特定字段的值只需直接使用属性。 例如,要确定ID为50的书本的标题,我们这样做:</p><pre class="cn literal-block" id="cn8">&gt;&gt;&gt; from mysite.books.models import Book&gt;&gt;&gt; b = Book.objects.get(id=50)&gt;&gt;&gt; b.titleu'The Django Book'</pre><p class="cn" id="cn9">但是,在之前有一件我们没提及到的是表现为<tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 或 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt>的关联对象字段,它们的作用稍有不同。</p><div class="section" id="foreign-key"><span id="cn10"></span><h3 class="cn" id="cn10">访问外键(Foreign Key)值</h3><p class="cn" id="cn11">当你获取一个<tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 字段时,你会得到相关的数据模型对象。 例如:</p><pre class="cn literal-block" id="cn13">&gt;&gt;&gt; b = Book.objects.get(id=50)&gt;&gt;&gt; b.publisher&lt;Publisher: Apress Publishing&gt;&gt;&gt;&gt; b.publisher.websiteu'http://www.apress.com/'</pre><p class="cn" id="cn14">对于用`` ForeignKey`` 来定义的关系来说，在关系的另一端也能反向的追溯回来，只不过由于不对称性的关系而稍有不同。 通过一个`` publisher`` 对象，直接获取 books ，用 publisher.book_set.all() ，如下：</p><pre class="cn literal-block" id="cn16">&gt;&gt;&gt; p = Publisher.objects.get(name='Apress Publishing')&gt;&gt;&gt; p.book_set.all()[&lt;Book: The Django Book&gt;, &lt;Book: Dive Into Python&gt;, ...]</pre><p class="cn" id="cn17">实际上，<tt class="docutils literal"><span class="pre">book_set</span></tt> 只是一个 <tt class="docutils literal"><span class="pre">QuerySet</span></tt>（参考第5章的介绍），所以它可以像<tt class="docutils literal"><span class="pre">QuerySet</span></tt>一样,能实现数据过滤和分切，例如：</p><pre class="cn literal-block" id="cn19">&gt;&gt;&gt; p = Publisher.objects.get(name='Apress Publishing')&gt;&gt;&gt; p.book_set.filter(name__icontains='django')[&lt;Book: The Django Book&gt;, &lt;Book: Pro Django&gt;]</pre><p class="cn" id="cn20">属性名称<tt class="docutils literal"><span class="pre">book_set</span></tt>是由模型名称的小写(如book)加<tt class="docutils literal"><span class="pre">_set</span></tt>组成的。</p></div><div class="section" id="many-to-many-values"><span id="cn21"></span><h3 class="cn" id="cn21">访问多对多值(Many-to-Many Values)</h3><p class="cn" id="cn22">多对多和外键工作方式相同，只不过我们处理的是<tt class="docutils literal"><span class="pre">QuerySet</span></tt>而不是模型实例。 例如,这里是如何查看书籍的作者：</p><pre class="cn literal-block" id="cn24">&gt;&gt;&gt; b = Book.objects.get(id=50)&gt;&gt;&gt; b.authors.all()[&lt;Author: Adrian Holovaty&gt;, &lt;Author: Jacob Kaplan-Moss&gt;]&gt;&gt;&gt; b.authors.filter(first_name='Adrian')[&lt;Author: Adrian Holovaty&gt;]&gt;&gt;&gt; b.authors.filter(first_name='Adam')[]</pre><p class="cn" id="cn25">反向查询也可以。 要查看一个作者的所有书籍,使用<tt class="docutils literal"><span class="pre">author.book_set</span></tt> ,就如这样:</p><pre class="cn literal-block" id="cn27">&gt;&gt;&gt; a = Author.objects.get(first_name='Adrian', last_name='Holovaty')&gt;&gt;&gt; a.book_set.all()[&lt;Book: The Django Book&gt;, &lt;Book: Adrian's Other Book&gt;]</pre><p class="cn" id="cn28">这里,就像使用 <tt class="docutils literal"><span class="pre">ForeignKey</span></tt>字段一样，属性名<tt class="docutils literal"><span class="pre">book_set</span></tt>是在数据模型(model)名后追加<tt class="docutils literal"><span class="pre">_set</span></tt>。</p></div></div><div class="section" id="database-schema"><span id="cn29"></span><h2 class="cn" id="cn29">更改数据库模式(Database Schema)</h2><p class="cn" id="cn30">在我们在第5章介绍 <tt class="docutils literal"><span class="pre">syncdb</span></tt> 这个命令时, 我们注意到 <tt class="docutils literal"><span class="pre">syncdb</span></tt>仅仅创建数据库里还没有的表，它 <em>并不</em> 对你数据模型的修改进行同步,也不处理数据模型的删除。 如果你新增或修改数据模型里的字段,或是删除了一个数据模型，你需要手动在数据库里进行相应的修改。 这段将解释了具体怎么做：</p><p class="cn" id="cn31">当处理模型修改的时候，将Django的数据库层的工作流程铭记于心是很重要的。</p><ul class="simple"><li class="cn" id="cn32"><p class="first cn" id="cn32">如果模型包含一个未曾在数据库里建立的字段，Django会报出错信息。 当你第一次用Django的数据库API请求表中不存在的字段时会导致错误（就是说，它会在运行时出错，而不是编译时）。</p></li></ul><ul class="simple"><li class="cn" id="cn33"><p class="first cn" id="cn33">Django<em>不</em>关心数据库表中是否存在未在模型中定义的列。</p></li></ul><ul class="simple"><li class="cn" id="cn34"><p class="first cn" id="cn34">Django<em>不</em>关心数据库中是否存在未被模型表示的表格。</p></li></ul><p class="cn" id="cn35">改变模型的模式架构意味着需要按照顺序更改Python代码和数据库。</p><div class="section" id="id3"><span id="cn36"></span><h3 class="cn" id="cn36">添加字段</h3><p class="cn" id="cn37">当要向一个产品设置表(或者说是model)添加一个字段的时候，要使用的技巧是利用Django不关心表里是否包含model里所没有的列的特性。 策略就是现在数据库里加入字段，然后同步Django的模型以包含新字段。</p><p class="cn" id="cn38">然而 这里有一个鸡生蛋蛋生鸡的问题 ,由于要想了解新增列的SQL语句，你需要使用Django的<tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">sqlall</span></tt>命令进行查看 ,而这又需要字段已经在模型里存在了。 (注意:你并 <em>不是非得使用</em>与Django相同的SQL语句创建新的字段，但是这样做确实是一个好主意 ,它能让一切都保持同步。)</p><p class="cn" id="cn39">这个鸡-蛋的问题的解决方法是在开发者环境里而不是发布环境里实现这个变化。 (你<em>正</em>使用的是测试/开发环境，对吧?)下面是具体的实施步骤。</p><p class="cn" id="cn40">首先，进入开发环境(也就是说，不是在发布环境里)：</p><ol class="arabic simple"><li class="cn" id="cn41"><p class="first cn" id="cn41">在你的模型里添加字段。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn42"><p class="first cn" id="cn42">运行 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">sqlall</span> <span class="pre">[yourapp]</span></tt> 来测试模型新的 <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE</span></tt> 语句。 注意为新字段的列定义。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn43"><p class="first cn" id="cn43">开启你的数据库的交互命令界面(比如, <tt class="docutils literal"><span class="pre">psql</span></tt> 或<tt class="docutils literal"><span class="pre">mysql</span></tt> , 或者可以使用<tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">dbshell</span></tt> )。 执行 <tt class="docutils literal"><span class="pre">ALTER</span> <span class="pre">TABLE</span></tt> 语句来添加新列。</p></li></ol><ol class="arabic simple" start="4"><li class="cn" id="cn44"><p class="first cn" id="cn44">使用Python的<tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">shell</span></tt>，通过导入模型和选中表单(例如，<tt class="docutils literal"><span class="pre">MyModel.objects.all()[:5]</span></tt> )来验证新的字段是否被正确的添加 ,如果一切顺利,所有的语句都不会报错。</p></li></ol><p class="cn" id="cn45">然后在你的产品服务器上再实施一遍这些步骤。</p><ol class="arabic simple"><li class="cn" id="cn46"><p class="first cn" id="cn46">启动数据库的交互界面。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn47"><p class="first cn" id="cn47">执行在开发环境步骤中，第三步的<tt class="docutils literal"><span class="pre">ALTER</span> <span class="pre">TABLE</span></tt>语句。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn48"><p class="first cn" id="cn48">将新的字段加入到模型中。 如果你使用了某种版本控制工具，并且在第一步中，已经提交了你在开发环境上的修改，现在，可以在生产环境中更新你的代码了（例如，如果你使用Subversion，执行<tt class="docutils literal"><span class="pre">svn</span> <span class="pre">update</span></tt>。</p></li></ol><ol class="arabic simple" start="4"><li class="cn" id="cn49"><p class="first cn" id="cn49">重新启动Web server，使修改生效。</p></li></ol><p class="cn" id="cn50">让我们实践下，比如添加一个num_pages字段到第五章中Book模型。首先，我们会把开发环境中的模型改成如下形式：</p><pre class="cn literal-block" id="cn52">class Book(models.Model):title = models.CharField(max_length=100)authors = models.ManyToManyField(Author)publisher = models.ForeignKey(Publisher)publication_date = models.DateField()**num_pages = models.IntegerField(blank=True, null=True)**def __unicode__(self):return self.title</pre><p class="cn" id="cn53">(注意 阅读第六章的“设置可选字段”以及本章下面的“添加非空列”小节以了解我们在这里添加<tt class="docutils literal"><span class="pre">blank=True</span></tt>和<tt class="docutils literal"><span class="pre">null=True</span></tt>的原因。)</p><p class="cn" id="cn54">然后，我们运行命令manage.py sqlall books 来查看CREATE TABLE语句。语句的具体内容取决与你所使用的数据库， 大概是这个样子：</p><pre class="cn literal-block" id="cn56">CREATE TABLE &quot;books_book&quot; (&quot;id&quot; serial NOT NULL PRIMARY KEY,&quot;title&quot; varchar(100) NOT NULL,&quot;publisher_id&quot; integer NOT NULL REFERENCES &quot;books_publisher&quot; (&quot;id&quot;),&quot;publication_date&quot; date NOT NULL,&quot;num_pages&quot; integer NULL);</pre><p class="cn" id="cn57">新加的字段被这样表示：</p><pre class="cn literal-block" id="cn59">&quot;num_pages&quot; integer NULL</pre><p class="cn" id="cn60">接下来，我们要在开发环境上运行数据库客户端，如果是PostgreSQL，运行 psql,，然后，我执行如下语句。</p><pre class="cn literal-block" id="cn62">ALTER TABLE books_book ADD COLUMN num_pages integer;</pre><p class="cn" id="cn63">添加 非NULL 字段</p><p class="cn" id="cn64">这里有个微妙之处值得一提。 在我们添加字段num_pages的时候，我们使用了 blank=True 和 null=True 选项。 这是因为在我们第一次创建它的时候，这个数据库字段会含有空值。</p><p class="cn" id="cn65">然而，想要添加不能含有空值的字段也是可以的。 要想实现这样的效果，你必须先创建 NULL 型的字段，然后将该字段的值填充为某个默认值，然后再将该字段改为 NOT NULL 型。 例如：</p><pre class="cn literal-block" id="cn67">BEGIN;ALTER TABLE books_book ADD COLUMN num_pages integer;UPDATE books_book SET num_pages=0;ALTER TABLE books_book ALTER COLUMN num_pages SET NOT NULL;COMMIT;</pre><p class="cn" id="cn68">如果你这样做，记得你不要在模型中添加 blank=True 和 null=True 选项。</p><p class="cn" id="cn69">执行ALTER TABLE之后，我们要验证一下修改结果是否正确。启动python并执行下面的代码：</p><pre class="cn literal-block" id="cn71">&gt;&gt;&gt; from mysite.books.models import Book&gt;&gt;&gt; Book.objects.all()[:5]</pre><p class="cn" id="cn72">如果没有异常发生，我们将切换到生产服务器，然后在生产环境的数据库中执行命令<tt class="docutils literal"><span class="pre">ALTER</span> <span class="pre">TABLE</span></tt> 然后我们更新生产环境中的模型，最后重启web服务器。</p></div><div class="section" id="id4"><span id="cn73"></span><h3 class="cn" id="cn73">删除字段</h3><p class="cn" id="cn74">从Model中删除一个字段要比添加容易得多。 删除字段，仅仅只要以下几个步骤：</p><blockquote><p class="cn" id="cn75">删除字段，然后重新启动你的web服务器。</p><p class="cn" id="cn76">用以下命令从数据库中删除字段：</p></blockquote><pre class="cn literal-block" id="cn78">ALTER TABLE books_book DROP COLUMN num_pages;</pre><p class="cn" id="cn79">请保证操作的顺序正确。 如果你先从数据库中删除字段，Django将会立即抛出异常。</p></div><div class="section" id="id5"><span id="cn80"></span><h3 class="cn" id="cn80">删除多对多关联字段</h3><p class="cn" id="cn81">由于多对多关联字段不同于普通字段，所以删除操作是不同的。</p><blockquote><p class="cn" id="cn82">从你的模型中删除<tt class="docutils literal"><span class="pre">ManyToManyField</span></tt>，然后重启web服务器。</p><p class="cn" id="cn83">用下面的命令从数据库删除关联表：</p></blockquote><pre class="cn literal-block" id="cn85">DROP TABLE books_book_authors;</pre><p class="cn" id="cn86">像上面一样，注意操作的顺序。</p></div><div class="section" id="id6"><span id="cn87"></span><h3 class="cn" id="cn87">删除模型</h3><p class="cn" id="cn88">删除整个模型要比删除一个字段容易。 删除一个模型只要以下几个步骤：</p><blockquote><p class="cn" id="cn89">从文件中删除你想要删除的模型，然后重启web 服务器<tt class="docutils literal"><span class="pre">models.py</span></tt></p><p class="cn" id="cn90">然后用以下命令从数据库中删除表：</p></blockquote><pre class="cn literal-block" id="cn92">DROP TABLE books_book;</pre><blockquote><p class="cn" id="cn93">当你需要从数据库中删除任何有依赖的表时要注意（也就是任何与表books_book有外键的表 ）。</p></blockquote><p class="cn" id="cn94">正如在前面部分，一定要按这样的顺序做。</p></div></div><div class="section" id="managers"><span id="cn95"></span><h2 class="cn" id="cn95">Managers</h2><p class="cn" id="cn96">在语句<tt class="docutils literal"><span class="pre">Book.objects.all()</span></tt>中，<tt class="docutils literal"><span class="pre">objects</span></tt>是一个特殊的属性，需要通过它查询数据库。 在第5章，我们只是简要地说这是模块的manager 。现在是时候深入了解managers是什么和如何使用了。</p><p class="cn" id="cn97">总之，模块manager是一个对象，Django模块通过它进行数据库查询。 每个Django模块至少有一个manager，你可以创建自定义manager以定制数据库访问。</p><p class="cn" id="cn98">下面是你创建自定义manager的两个原因： 增加额外的manager方法，和/或修manager返回的初始QuerySet。</p><div class="section" id="manager"><span id="cn99"></span><h3 class="cn" id="cn99">增加额外的Manager方法</h3><p class="cn" id="cn100">增加额外的manager方法是为模块添加表级功能的首选办法。 （至于行级功能，也就是只作用于模型对象实例的函数，一会儿将在本章后面解释。）</p><p class="cn" id="cn101">例如,我们为Book模型定义了一个title_count()方法，它需要一个关键字，返回包含这个关键字的书的数量。 （这个例子有点牵强，不过它可以说明managers如何工作。）</p><pre class="cn literal-block" id="cn103"># models.pyfrom django.db import models# ... Author and Publisher models here ...**class BookManager(models.Manager):****def title_count(self, keyword):****return self.filter(title__icontains=keyword).count()**class Book(models.Model):title = models.CharField(max_length=100)authors = models.ManyToManyField(Author)publisher = models.ForeignKey(Publisher)publication_date = models.DateField()num_pages = models.IntegerField(blank=True, null=True)**objects = BookManager()**def __unicode__(self):return self.title</pre><p class="cn" id="cn104">有了这个manager，我们现在可以这样做：</p><pre class="cn literal-block" id="cn106">&gt;&gt;&gt; Book.objects.title_count('django')4&gt;&gt;&gt; Book.objects.title_count('python')18</pre><p class="cn" id="cn107">下面是编码该注意的一些地方：</p><ul class="simple"><li class="cn" id="cn108"><p class="first cn" id="cn108">我们建立了一个BookManager类，它继承了django.db.models.Manager。这个类只有一个title_count()方法，用来做统计。 注意，这个方法使用了self.filter()，此处self指manager本身。</p></li></ul><ul class="simple"><li class="cn" id="cn109"><p class="first cn" id="cn109">我们把BookManager()赋值给模型的objects属性。 它将取代模型的默认manager（<tt class="docutils literal"><span class="pre">objects</span></tt>）如果我们没有特别定义，它将会被自动创建。 我们把它命名为objects，这是为了与自动创建的manager保持一致。</p></li></ul><p class="cn" id="cn110">为什么我们要添加一个title_count()方法呢?是为了将经常使用的查询进行封装，这样我们就不必重复编码了。</p></div><div class="section" id="manager-querysets"><span id="cn111"></span><h3 class="cn" id="cn111">修改初始Manager QuerySets</h3><p class="cn" id="cn112">manager的基本QuerySet返回系统中的所有对象。 例如,`` Book.objects.all()`` 返回数据库book中的所有书本。</p><p class="cn" id="cn113">我们可以通过覆盖Manager.get_query_set()方法来重写manager的基本QuerySet。 get_query_set()按照你的要求返回一个QuerySet。</p><p class="cn" id="cn114">例如,下面的模型有* 两个* manager。一个返回所有对像，另一个只返回作者是Roald Dahl的书。</p><pre class="cn literal-block" id="cn116">from django.db import models**# First, define the Manager subclass.****class DahlBookManager(models.Manager):****def get_query_set(self):****return super(DahlBookManager, self).get_query_set().filter(author='Roald Dahl')****# Then hook it into the Book model explicitly.**class Book(models.Model):title = models.CharField(max_length=100)author = models.CharField(max_length=50)# ...**objects = models.Manager() # The default manager.****dahl_objects = DahlBookManager() # The Dahl-specific manager.**</pre><p class="cn" id="cn117">在这个示例模型中,Book.objects.all()返回了数据库中的所有书本,而Book.dahl_objects.all()只返回了一本. 注意我们明确地将objects设置成manager的实例，因为如果我们不这么做，那么唯一可用的manager就将是dah1_objects。</p><p class="cn" id="cn118">当然,由于get_query_set()返回的是一个QuerySet对象，所以我们可以使用filter()，exclude()和其他一切QuerySet的方法。 像这些语法都是正确的：</p><pre class="cn literal-block" id="cn120">Book.dahl_objects.all()Book.dahl_objects.filter(title='Matilda')Book.dahl_objects.count()</pre><p class="cn" id="cn121">这个例子也指出了其他有趣的技术： 在同一个模型中使用多个manager。 只要你愿意，你可以为你的模型添加多个manager()实例。 这是一个为模型添加通用滤器的简单方法。</p><p class="cn" id="cn122">例如:</p><pre class="cn literal-block" id="cn124">class MaleManager(models.Manager):def get_query_set(self):return super(MaleManager, self).get_query_set().filter(sex='M')class FemaleManager(models.Manager):def get_query_set(self):return super(FemaleManager, self).get_query_set().filter(sex='F')class Person(models.Model):first_name = models.CharField(max_length=50)last_name = models.CharField(max_length=50)sex = models.CharField(max_length=1, choices=(('M', 'Male'), ('F', 'Female')))people = models.Manager()men = MaleManager()women = FemaleManager()</pre><p class="cn" id="cn125">这个例子允许你执行`` Person.men.all()`` ，`` Person.women.all()`` ，`` Person.people.all()`` 查询，生成你想要的结果。</p><p class="cn" id="cn126">如果你使用自定义的<tt class="docutils literal"><span class="pre">Manager</span></tt>对象，请注意，Django遇到的第一个Manager(以它在模型中被定义的位置为准)会有一个特殊状态。 Django将会把第一个<tt class="docutils literal"><span class="pre">Manager</span></tt> 定义为默认<tt class="docutils literal"><span class="pre">Manager</span></tt> ，Django的许多部分(但是不包括admin应用)将会明确地为模型使用这个<tt class="docutils literal"><span class="pre">manager</span></tt>。 结论是，你应该小心地选择你的默认manager。因为覆盖<tt class="docutils literal"><span class="pre">get_query_set()</span></tt> 了，你可能接受到一个无用的返回对像，你必须避免这种情况。</p></div></div><div class="section" id="id7"><span id="cn127"></span><h2 class="cn" id="cn127">模型方法</h2><p class="cn" id="cn128">为了给你的对像添加一个行级功能，那就定义一个自定义方法。有鉴于manager经常被用来用一些整表操作（table-wide），模型方法应该只对特殊模型实例起作用。</p><p class="cn" id="cn129">这是一项在模型的一个地方集中业务逻辑的技术。</p><p class="cn" id="cn130">最好用例子来解释一下。 这个模型有一些自定义方法：</p><pre class="cn literal-block" id="cn132">from django.contrib.localflavor.us.models import USStateFieldfrom django.db import modelsclass Person(models.Model):first_name = models.CharField(max_length=50)last_name = models.CharField(max_length=50)birth_date = models.DateField()address = models.CharField(max_length=100)city = models.CharField(max_length=50)state = USStateField() # Yes, this is U.S.-centric...def baby_boomer_status(self):&quot;Returns the person's baby-boomer status.&quot;import datetimeif datetime.date(1945, 8, 1) &lt;= self.birth_date &lt;= datetime.date(1964, 12, 31):return &quot;Baby boomer&quot;if self.birth_date &lt; datetime.date(1945, 8, 1):return &quot;Pre-boomer&quot;return &quot;Post-boomer&quot;def is_midwestern(self):&quot;Returns True if this person is from the Midwest.&quot;return self.state in ('IL', 'WI', 'MI', 'IN', 'OH', 'IA', 'MO')def _get_full_name(self):&quot;Returns the person's full name.&quot;return u'%s %s' % (self.first_name, self.last_name)full_name = property(_get_full_name)</pre><p class="cn" id="cn133">例子中的最后一个方法是一个property。 想了解更多关于属性的信息请访问<a class="reference external" href="http://www.python.org/download/releases/2.2/descrintro/#property">http://www.python.org/download/releases/2.2/descrintro/#property</a></p><p class="cn" id="cn134">这是用法的实例：</p><pre class="cn literal-block" id="cn136">&gt;&gt;&gt; p = Person.objects.get(first_name='Barack', last_name='Obama')&gt;&gt;&gt; p.birth_datedatetime.date(1961, 8, 4)&gt;&gt;&gt; p.baby_boomer_status()'Baby boomer'&gt;&gt;&gt; p.is_midwestern()True&gt;&gt;&gt; p.full_name  # Note this isn't a method -- it's treated as an attributeu'Barack Obama'</pre></div><div class="section" id="sql"><span id="cn137"></span><h2 class="cn" id="cn137">执行原始SQL查询</h2><p class="cn" id="cn138">有时候你会发现Django数据库API带给你的也只有这么多，那你可以为你的数据库写一些自定义SQL查询。 你可以通过导入<tt class="docutils literal"><span class="pre">django.db.connection</span></tt>对像来轻松实现，它代表当前数据库连接。 要使用它，需要通过<tt class="docutils literal"><span class="pre">connection.cursor()</span></tt>得到一个游标对像。 然后，使用<tt class="docutils literal"><span class="pre">cursor.execute(sql,</span> <span class="pre">[params])</span></tt>来执行SQL语句，使用<tt class="docutils literal"><span class="pre">cursor.fetchone()</span></tt>或者<tt class="docutils literal"><span class="pre">cursor.fetchall()</span></tt>来返回记录集。 例如:</p><pre class="cn literal-block" id="cn140">&gt;&gt;&gt; from django.db import connection&gt;&gt;&gt; cursor = connection.cursor()&gt;&gt;&gt; cursor.execute(&quot;&quot;&quot;...    SELECT DISTINCT first_name...    FROM people_person...    WHERE last_name = %s&quot;&quot;&quot;, ['Lennon'])&gt;&gt;&gt; row = cursor.fetchone()&gt;&gt;&gt; print row['John']</pre><p class="cn" id="cn141"><tt class="docutils literal"><span class="pre">connection</span></tt>和<tt class="docutils literal"><span class="pre">cursor</span></tt>几乎实现了标准Python DB-API，你可以访问` <a class="reference external" href="http://www.python.org/peps/pep-0249.html">http://www.python.org/peps/pep-0249.html</a> &lt;<a class="reference external" href="http://www.python.org/peps/pep-0249.html">http://www.python.org/peps/pep-0249.html</a>&gt;`__来获取更多信息。 如果你对Python DB-API不熟悉，请注意在<tt class="docutils literal"><span class="pre">cursor.execute()</span></tt> 的SQL语句中使用`` &#8220;%s&#8221;`` ，而不要在SQL内直接添加参数。 如果你使用这项技术，数据库基础库将会自动添加引号，同时在必要的情况下转意你的参数。</p><p class="cn" id="cn142">不要把你的视图代码和django.db.connection语句混杂在一起，把它们放在自定义模型或者自定义manager方法中是个不错的主意。 比如，上面的例子可以被整合成一个自定义manager方法，就像这样：</p><pre class="cn literal-block" id="cn144">from django.db import connection, modelsclass PersonManager(models.Manager):def first_names(self, last_name):cursor = connection.cursor()cursor.execute(&quot;&quot;&quot;SELECT DISTINCT first_nameFROM people_personWHERE last_name = %s&quot;&quot;&quot;, [last_name])return [row[0] for row in cursor.fetchone()]class Person(models.Model):first_name = models.CharField(max_length=50)last_name = models.CharField(max_length=50)objects = PersonManager()</pre><p class="cn" id="cn145">然后这样使用:</p><pre class="cn literal-block" id="cn147">&gt;&gt;&gt; Person.objects.first_names('Lennon')['John', 'Cynthia']</pre></div><div class="section" id="id8"><span id="cn148"></span><h2 class="cn" id="cn148">接下来做什么？</h2><p class="cn" id="cn149">在<a class="reference external" href="chapter11.html">下一章</a> 我们将讲解Django的通用视图框架，使用它创建常见的网站可以节省时间。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter09.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter11.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>