<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十四章： 会话、用户和注册</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter13.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter15.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第十四章： 会话、用户和注册</h1><p class="cn" id="cn1">是时候承认了： 我们有意的避开了Web开发中极其重要的方面。 到目前为止，我们都在假定，网站流量是大量的匿名用户带来的。</p><p class="cn" id="cn2">这当然不对。 浏览器的背后都是活生生的人(至少某些时候是)。 这忽略了重要的一点： 互联网服务于人而不是机器。 要开发一个真正令人心动的网站，我们必须面对浏览器后面活生生的人。</p><p class="cn" id="cn3">很不幸，这并不容易。 HTTP被设计为&#8221;无状态&#8221;，每次请求都处于相同的空间中。 在一次请求和下一次请求之间没有任何状态保持，我们无法根据请求的任何方面(IP地址，用户代理等)来识别来自同一人的连续请求。</p><p class="cn" id="cn4">在本章中你将学会如何搞定状态的问题。 好了，我们会从较低的层次(<em>cookies</em>)开始，然后过渡到用高层的工具来搞定会话，用户和注册的问题。</p><div class="section" id="cookies"><span id="cn5"></span><h2 class="cn" id="cn5">Cookies</h2><p class="cn" id="cn6">浏览器的开发者在很早的时候就已经意识到， HTTP&#8217;s 的无状态会对Web开发者带来很大的问题，于是(<em>cookies</em>)应运而生。 cookies 是浏览器为 Web 服务器存储的一小段信息。 每次浏览器从某个服务器请求页面时，它向服务器回送之前收到的cookies</p><p class="cn" id="cn7">来看看它是怎么工作的。 当你打开浏览器并访问 <tt class="docutils literal"><span class="pre">google.com</span></tt> ，你的浏览器会给Google发送一个HTTP请求，起始部分就象这样：</p><pre class="cn literal-block" id="cn9">GET / HTTP/1.1Host: google.com...</pre><p class="cn" id="cn10">当 Google响应时，HTTP的响应是这样的：</p><pre class="cn literal-block" id="cn12">HTTP/1.1 200 OKContent-Type: text/htmlSet-Cookie: PREF=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671;expires=Sun, 17-Jan-2038 19:14:07 GMT;path=/; domain=.google.comServer: GWS/2.1...</pre><p class="cn" id="cn13">注意 <tt class="docutils literal"><span class="pre">Set-Cookie</span></tt> 的头部。 你的浏览器会存储cookie值( <tt class="docutils literal"><span class="pre">PREF=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671</span></tt> ) ，而且每次访问google 站点都会回送这个cookie值。 因此当你下次访问Google时，你的浏览器会发送像这样的请求：</p><pre class="cn literal-block" id="cn15">GET / HTTP/1.1Host: google.comCookie: PREF=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671...</pre><p class="cn" id="cn16">于是 <tt class="docutils literal"><span class="pre">Cookies</span></tt> 的值会告诉Google，你就是早些时候访问过Google网站的人。 这个值可能是数据库中存储用户信息的key，可以用它在页面上显示你的用户名。 Google会（以及目前）使用它在网页上显示你账号的用户名。</p><div class="section" id="id2"><span id="cn17"></span><h3 class="cn" id="cn17">存取Cookies</h3><p class="cn" id="cn18">在Django中处理持久化，大部分时候你会更愿意用高层些的session 和/或 后面要讨论的user 框架。 但在此之前，我们需要停下来在底层看看如何读写cookies。 这会帮助你理解本章节后面要讨论的工具是如何工作的，而且如果你需要自己操作cookies，这也会有所帮助。</p><p class="cn" id="cn19">读取已经设置好的cookies极其简单。 每一个`` HttpRequest`` 对象都有一个`` COOKIES`` 对象，该对象的行为类似一个字典，你可以使用它读取任何浏览器发送给视图（view）的cookies。</p><pre class="cn literal-block" id="cn21">def show_color(request):if &quot;favorite_color&quot; in request.COOKIES:return HttpResponse(&quot;Your favorite color is %s&quot; %             request.COOKIES[&quot;favorite_color&quot;])else:return HttpResponse(&quot;You don't have a favorite color.&quot;)</pre><dl class="docutils"><dt>写cookies稍微复杂点。 你需要使用 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt>对象的 <tt class="docutils literal"><span class="pre">set_cookie()</span></tt>方法。 这儿有个基于 <tt class="docutils literal"><span class="pre">GET</span></tt> 参数来设置 <tt class="docutils literal"><span class="pre">favorite_color</span></tt></dt><dd><p class="first last cn" id="cn22">cookie的例子：</p></dd></dl><pre class="cn literal-block" id="cn24">def set_color(request):if &quot;favorite_color&quot; in request.GET:# Create an HttpResponse object...response = HttpResponse(&quot;Your favorite color is now %s&quot; %             request.GET[&quot;favorite_color&quot;])# ... and set a cookie on the responseresponse.set_cookie(&quot;favorite_color&quot;,request.GET[&quot;favorite_color&quot;])return responseelse:return HttpResponse(&quot;You didn't give a favorite color.&quot;)</pre><p class="cn" id="cn25">你可以给 <tt class="docutils literal"><span class="pre">response.set_cookie()</span></tt> 传递一些可选的参数来控制cookie的行为，详见表14-1。</p><div class="system-message"><p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">&lt;string&gt;</tt>, line 145)</p><p class="cn" id="cn26">Error parsing content block for the &#8220;table&#8221; directive: exactly one table expected.</p><pre class="cn literal-block" id="cn26">.. table:: 表 14-1: Cookie 选项+---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|参数                             |缺省值                     |描述                                                                                                                                                                                |+=================================+===========================+====================================================================================================================================================================================+|``max_age``                      |``None``                   |cookie需要延续的时间（以秒为单位） 如果参数是\ `` None`` ，这个cookie会延续到浏览器关闭为止。                                                                                       |+---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|``expires``                      |``None``                   |cookie失效的实际日期/时间。 它的格式必须是：\ `` &quot;Wdy, DD-Mth-YY HH:MM:SS GMT&quot;`` 。如果给出了这个参数，它会覆盖\ `` max_age`` 参数。                                                |+---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|``path``                         |``&quot;/&quot;``                    |cookie生效的路径前缀。 浏览器只会把cookie回传给带有该路径的页 面，这样你可以避免将cookie传给站点中的其他的应用。                                                                    ||                                 |                           |                                                                                                                                                                                    ||                                 |                           |当你不是控制你的站点的顶层时，这样做是特别有用的。                                                                                                                                  |+---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|``domain``                       |``None``                   |这个cookie有效的站点。 你可以使用这个参数设置一个跨站点（cross-domain）的cookie。 比如，\ `` domain=&quot;.example.com&quot;`` 可以设置一个在\ `` www.example.com`` 、\ `` www2.example.com`` 以及\ `` an.other.sub.domain.example.com`` 站点下都可读到的cookie。||                                 |                           |                                                                                                                                                                                    ||                                 |                           |如果这个参数被设成\ `` None`` ，cookie将只能在设置它的站点下可以读到。                                                                                                              |+---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+|``False``                        |``False``                  |如果设置为 ``True`` ，浏览器将通过HTTPS来回传cookie。                                                                                                                               |+---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</pre></div></div><div class="section" id="id3"><span id="cn27"></span><h3 class="cn" id="cn27">好坏参半的Cookies</h3><p class="cn" id="cn28">也许你已经注意到了，cookies的工作方式可能导致的问题。 让我们看一下其中一些比较重要的问题：</p><blockquote><p class="cn" id="cn29">cookie的存储是自愿的，一个客户端不一定要去接受或存储cookie。 事实上，所有的浏览器都让用户自己控制 是否接受cookies。 如果你想知道cookies对于Web应用有多重要，你可以试着打开这个浏览器的 选项：</p><p class="cn" id="cn30">尽管cookies广为使用，但仍被认为是不可靠的的。 这意味着，开发者使用cookies之前必须 检查用户是否可以接收cookie。</p><p class="cn" id="cn31">Cookie(特别是那些没通过HTTPS传输的)是非常不安全的。 因为HTTP数据是以明文发送的，所以 特别容易受到嗅探攻击。 也就是说，嗅探攻击者可以在网络中拦截并读取cookies，因此你要 绝对避免在cookies中存储敏感信息。 这就意味着您不应该使用cookie来在存储任何敏感信息。</p><p class="cn" id="cn32">还有一种被称为&#8221;中间人&#8221;的攻击更阴险，攻击者拦截一个cookie并将其用于另一个用户。第19章将深入讨论这种攻击的本质以及如何避免。</p><p class="cn" id="cn33">即使从预想中的接收者返回的cookie也是不安全的。 在大多数浏览器中您可以非常容易地修改cookies中的信息。有经验的用户甚至可以通过像mechanize(<a class="reference external" href="http://wwwsearch.sourceforge.net/mechanize/">http://wwwsearch.sourceforge.net/mechanize/</a>)这样的工具手工构造一个HTTP请求。</p><p class="cn" id="cn34">因此不能在cookies中存储可能会被篡改的敏感数据。 在cookies中存储 <tt class="docutils literal"><span class="pre">IsLoggedIn=1</span></tt> ，以标识用户已经登录。 犯这类错误的站点数量多的令人难以置信； 绕过这些网站的安全系统也是易如反掌。</p></blockquote></div></div><div class="section" id="django-session"><span id="cn35"></span><h2 class="cn" id="cn35">Django的 Session 框架</h2><p class="cn" id="cn36">由于存在的限制与安全漏洞，cookies和持续性会话已经成为Web开发中令人头疼的典范。 好消息是，Django的目标正是高效的“头疼杀手”，它自带的session框架会帮你搞定这些问题。</p><p class="cn" id="cn37">你可以用session 框架来存取每个访问者任意数据， 这些数据在服务器端存储，并对cookie的收发进行了抽象。 Cookies只存储数据的哈希会话ID，而不是数据本身，从而避免了大部分的常见cookie问题。</p><p class="cn" id="cn38">下面我们来看看如何打开session功能，并在视图中使用它。</p><div class="section" id="sessions"><span id="cn39"></span><h3 class="cn" id="cn39">打开 Sessions功能</h3><p class="cn" id="cn40">Sessions 功能是通过一个中间件(参见第17章)和一个模型(model)来实现的。 要打开sessions功能，需要以下几步操作：</p><ol class="arabic simple"><li class="cn" id="cn41"><p class="first cn" id="cn41">编辑 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 配置，确保 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 中包含 <tt class="docutils literal"><span class="pre">'django.contrib.sessions.middleware.SessionMiddleware'</span></tt>。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn42"><p class="first cn" id="cn42">确认 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中有 <tt class="docutils literal"><span class="pre">'django.contrib.sessions'</span></tt> (如果你是刚打开这个应用，别忘了运行 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">syncdb</span></tt> )</p></li></ol><p class="cn" id="cn43">如果项目是用 <tt class="docutils literal"><span class="pre">startproject</span></tt> 来创建的，配置文件中都已经安装了这些东西，除非你自己删除，正常情况下，你无需任何设置就可以使用session功能。</p><p class="cn" id="cn44">如果不需要session功能，你可以删除 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 设置中的 <tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> 和 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置中的 <tt class="docutils literal"><span class="pre">'django.contrib.sessions'</span></tt> 。虽然这只会节省很少的开销，但积少成多啊。</p></div><div class="section" id="session"><span id="cn45"></span><h3 class="cn" id="cn45">在视图中使用Session</h3><p class="cn" id="cn46"><tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> 激活后，每个传给视图(view)函数的第一个参数``HttpRequest`` 对象都有一个 <tt class="docutils literal"><span class="pre">session</span></tt> 属性，这是一个字典型的对象。 你可以象用普通字典一样来用它。 例如，在视图(view)中你可以这样用：</p><pre class="cn literal-block" id="cn48"># Set a session value:request.session[&quot;fav_color&quot;] = &quot;blue&quot;# Get a session value -- this could be called in a different view,# or many requests later (or both):fav_color = request.session[&quot;fav_color&quot;]# Clear an item from the session:del request.session[&quot;fav_color&quot;]# Check if the session has a given key:if &quot;fav_color&quot; in request.session:...</pre><p class="cn" id="cn49">其他的映射方法，如 <tt class="docutils literal"><span class="pre">keys()</span></tt> 和 <tt class="docutils literal"><span class="pre">items()</span></tt> 对 <tt class="docutils literal"><span class="pre">request.session</span></tt> 同样有效：</p><p class="cn" id="cn50">下面是一些有效使用Django sessions的简单规则：</p><blockquote><p class="cn" id="cn51">用正常的字符串作为key来访问字典 <tt class="docutils literal"><span class="pre">request.session</span></tt> ， 而不是整数、对象或其它什么的。</p><p class="cn" id="cn52">Session字典中以下划线开头的key值是Django内部保留key值。 框架只会用很少的几个下划线 开头的session变量，除非你知道他们的具体含义，而且愿意跟上Django的变化，否则，最好 不要用这些下划线开头的变量，它们会让Django搅乱你的应用。</p><p class="cn" id="cn53">比如，不要象这样使用`` _fav_color`` 会话密钥(session key)：</p></blockquote><pre class="cn literal-block" id="cn55">request.session['_fav_color'] = 'blue' # Don't do this!</pre><blockquote><p class="cn" id="cn56">不要用一个新对象来替换掉 <tt class="docutils literal"><span class="pre">request.session</span></tt> ，也不要存取其属性。 可以像Python中的字典那样使用。 例如：</p></blockquote><pre class="cn literal-block" id="cn58">request.session = some_other_object # Don't do this!request.session.foo = 'bar' # Don't do this!</pre><p class="cn" id="cn59">我们来看个简单的例子。 这是个简单到不能再简单的例子：在用户发了一次评论后将<tt class="docutils literal"><span class="pre">has_commented</span></tt>设置为<tt class="docutils literal"><span class="pre">True</span></tt>。 这是个简单（但不很安全）的、防止用户多次评论的方法。</p><pre class="cn literal-block" id="cn61">def post_comment(request):if request.method != 'POST':raise Http404('Only POSTs are allowed')if 'comment' not in request.POST:raise Http404('Comment not submitted')if request.session.get('has_commented', False):return HttpResponse(&quot;You've already commented.&quot;)c = comments.Comment(comment=request.POST['comment'])c.save()request.session['has_commented'] = Truereturn HttpResponse('Thanks for your comment!')</pre><p class="cn" id="cn62">下面是一个很简单的站点登录视图(view)：</p><pre class="cn literal-block" id="cn64">def login(request):if request.method != 'POST':raise Http404('Only POSTs are allowed')try:m = Member.objects.get(username=request.POST['username'])if m.password == request.POST['password']:request.session['member_id'] = m.idreturn HttpResponseRedirect('/you-are-logged-in/')except Member.DoesNotExist:return HttpResponse(&quot;Your username and password didn't match.&quot;)</pre><p class="cn" id="cn65">下面的例子将登出一个在上面已通过`` login()`` 登录的用户：</p><pre class="cn literal-block" id="cn67">def logout(request):try:del request.session['member_id']except KeyError:passreturn HttpResponse(&quot;You're logged out.&quot;)</pre><p class="cn" id="cn68">注意</p><p class="cn" id="cn69">在实践中，这是很烂的用户登录方式，稍后讨论的认证(authentication )框架会帮你以更健壮和有利的方式来处理这些问题。 这些非常简单的例子只是想让你知道这一切是如何工作的。这些实例尽量简单，这样你可以更容易看到发生了什么</p></div><div class="section" id="id4"><span id="cn70"></span><h3 class="cn" id="cn70">设置测试Cookies</h3><dl class="docutils"><dt>就像前面提到的，你不能指望所有的浏览器都可以接受cookie。 因此，为了使用方便，Django提供了一个简单的方法来测试用户的浏览器是否接受cookie。 你只需在视图(view)中调用 <tt class="docutils literal"><span class="pre">request.session.set_test_cookie()</span></tt></dt><dd><p class="first last cn" id="cn71">，并在后续的视图(view)、而不是当前的视图(view)中检查 <tt class="docutils literal"><span class="pre">request.session.test_cookie_worked()</span></tt>。</p></dd></dl><p class="cn" id="cn72">虽然把 <tt class="docutils literal"><span class="pre">set_test_cookie()</span></tt> 和 <tt class="docutils literal"><span class="pre">test_cookie_worked()</span></tt> 分开的做法看起来有些笨拙，但由于cookie的工作方式，这无可避免。 当设置一个cookie时候，只能等浏览器下次访问的时候，你才能知道浏览器是否接受cookie。</p><p class="cn" id="cn73">检查cookie是否可以正常工作后，你得自己用 <tt class="docutils literal"><span class="pre">delete_test_cookie()</span></tt> 来清除它，这是个好习惯。 在你证实了测试cookie已工作了之后这样操作。</p><p class="cn" id="cn74">这是个典型例子：</p><pre class="cn literal-block" id="cn76">def login(request):# If we submitted the form...if request.method == 'POST':# Check that the test cookie worked (we set it below):if request.session.test_cookie_worked():# The test cookie worked, so delete it.request.session.delete_test_cookie()# In practice, we'd need some logic to check username/password# here, but since this is an example...return HttpResponse(&quot;You're logged in.&quot;)# The test cookie failed, so display an error message. If this# were a real site, we'd want to display a friendlier message.else:return HttpResponse(&quot;Please enable cookies and try again.&quot;)# If we didn't post, send the test cookie along with the login form.request.session.set_test_cookie()return render_to_response('foo/login_form.html')</pre><p class="cn" id="cn77">注意</p><p class="cn" id="cn78">再次强调，内置的认证函数会帮你做检查的。</p></div><div class="section" id="view-session"><span id="cn79"></span><h3 class="cn" id="cn79">在视图(View)外使用Session</h3><p class="cn" id="cn80">从内部来看，每个session都只是一个普通的Django model（在 <tt class="docutils literal"><span class="pre">django.contrib.sessions.models</span></tt> 中定义)。每个session都由一个随机的32字节哈希串来标识，并存储于cookie中。 因为它是一个标准的模型，所以你可以使用Django数据库API来存取session。</p><pre class="cn literal-block" id="cn82">&gt;&gt;&gt; from django.contrib.sessions.models import Session&gt;&gt;&gt; s = Session.objects.get(pk='2b1189a188b44ad18c35e113ac6ceead')&gt;&gt;&gt; s.expire_datedatetime.datetime(2005, 8, 20, 13, 35, 12)</pre><p class="cn" id="cn83">你需要使用<tt class="docutils literal"><span class="pre">get_decoded()</span></tt> 来读取实际的session数据。 这是必需的，因为字典存储为一种特定的编码格式。</p><pre class="cn literal-block" id="cn85">&gt;&gt;&gt; s.session_data'KGRwMQpTJ19hdXRoX3VzZXJfaWQnCnAyCkkxCnMuMTExY2ZjODI2Yj...'&gt;&gt;&gt; s.get_decoded(){'user_id': 42}</pre></div><div class="section" id="id5"><span id="cn86"></span><h3 class="cn" id="cn86">何时保存Session</h3><p class="cn" id="cn87">缺省的情况下，Django只会在session发生变化的时候才会存入数据库，比如说，字典赋值或删除。</p><pre class="cn literal-block" id="cn89"># Session is modified.request.session['foo'] = 'bar'# Session is modified.del request.session['foo']# Session is modified.request.session['foo'] = {}# Gotcha: Session is NOT modified, because this alters# request.session['foo'] instead of request.session.request.session['foo']['bar'] = 'baz'</pre><p class="cn" id="cn90">你可以设置 <tt class="docutils literal"><span class="pre">SESSION_SAVE_EVERY_REQUEST</span></tt> 为 <tt class="docutils literal"><span class="pre">True</span></tt> 来改变这一缺省行为。如果置为True的话，Django会在每次收到请求的时候保存session，即使没发生变化。</p><p class="cn" id="cn91">注意，会话cookie只会在创建和修改的时候才会送出。 但如果 <tt class="docutils literal"><span class="pre">SESSION_SAVE_EVERY_REQUEST</span></tt> 设置为 <tt class="docutils literal"><span class="pre">True</span></tt> ，会话cookie在每次请求的时候都会送出。 同时，每次会话cookie送出的时候，其 <tt class="docutils literal"><span class="pre">expires</span></tt> 参数都会更新。</p></div><div class="section" id="vs"><span id="cn92"></span><h3 class="cn" id="cn92">浏览器关闭即失效会话 vs 持久会话</h3><p class="cn" id="cn93">你可能注意到了，Google给我们发送的cookie中有 <tt class="docutils literal"><span class="pre">expires=Sun,</span> <span class="pre">17-Jan-2038</span> <span class="pre">19:14:07</span> <span class="pre">GMT;</span></tt> cookie可以有过期时间，这样浏览器就知道什么时候可以删除cookie了。 如果cookie没有设置过期时间，当用户关闭浏览器的时候，cookie就自动过期了。 你可以改变 <tt class="docutils literal"><span class="pre">SESSION_EXPIRE_AT_BROWSER_CLOSE</span></tt> 的设置来控制session框架的这一行为。</p><p class="cn" id="cn94">缺省情况下， <tt class="docutils literal"><span class="pre">SESSION_EXPIRE_AT_BROWSER_CLOSE</span></tt> 设置为 <tt class="docutils literal"><span class="pre">False</span></tt> ，这样，会话cookie可以在用户浏览器中保持有效达 <tt class="docutils literal"><span class="pre">SESSION_COOKIE_AGE</span></tt> 秒（缺省设置是两周，即1,209,600 秒）。 如果你不想用户每次打开浏览器都必须重新登陆的话，用这个参数来帮你。</p><p class="cn" id="cn95">如果 <tt class="docutils literal"><span class="pre">SESSION_EXPIRE_AT_BROWSER_CLOSE</span></tt> 设置为 <tt class="docutils literal"><span class="pre">True</span></tt> ，当浏览器关闭时，Django会使cookie失效。</p></div><div class="section" id="id6"><span id="cn96"></span><h3 class="cn" id="cn96">其他的Session设置</h3><p class="cn" id="cn97">除了上面提到的设置，还有一些其他的设置可以影响Django session框架如何使用cookie，详见表 14-2.</p><table class="cn docutils" id="cn98"><caption>表 14-2.  影响cookie行为的设置</caption><colgroup><col width="31%" /><col width="50%" /><col width="19%" /></colgroup><thead valign="bottom"><tr><th class="head">设置</th><th class="head">描述</th><th class="head">缺省</th></tr></thead><tbody valign="top"><tr><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_DOMAIN</span></tt></td><td>使用会话cookie（session cookies）的站点。将它设成一个字符串，就好象`` &#8220;.example.com&#8221;`` 以用于跨站点（cross-domain）的cookie，或`` None`` 以用于单个站点。</td><td><tt class="docutils literal"><span class="pre">None</span></tt></td></tr><tr><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_NAME</span></tt></td><td>会话中使用的cookie的名字。 它可以是任意的字符串。</td><td><tt class="docutils literal"><span class="pre">&quot;sessionid&quot;</span></tt></td></tr><tr><td><tt class="docutils literal"><span class="pre">SESSION_COOKIE_SECURE</span></tt></td><td>是否在session中使用安全cookie。 如果设置 <tt class="docutils literal"><span class="pre">True</span></tt> , cookie就会标记为安全， 这意味着cookie只会通过HTTPS来传输。</td><td><tt class="docutils literal"><span class="pre">False</span></tt></td></tr></tbody></table><p class="cn" id="cn99">技术细节</p><p class="cn" id="cn100">如果你还是好奇的话，下面是一些关于session框架内部工作方式的技术细节：</p><blockquote><p class="cn" id="cn101">session 字典接受任何支持序列化的Python对象。 参考Python内建模块<tt class="docutils literal"><span class="pre">pickle</span></tt>的文档以获取更多信息。</p><p class="cn" id="cn102">Session 数据存在数据库表 <tt class="docutils literal"><span class="pre">django_session</span></tt> 中</p><p class="cn" id="cn103">Session 数据在需要的时候才会读取。 如果你从不使用 <tt class="docutils literal"><span class="pre">request.session</span></tt> ，Django不会动相关数据库表的一根毛。</p><p class="cn" id="cn104">Django 只在需要的时候才送出cookie。 如果你压根儿就没有设置任何会话数据，它不会 送出会话cookie(除非 <tt class="docutils literal"><span class="pre">SESSION_SAVE_EVERY_REQUEST</span></tt> 设置为 <tt class="docutils literal"><span class="pre">True</span></tt> )。</p><p class="cn" id="cn105">Django session 框架完全而且只能基于cookie。 它不会后退到把会话ID编码在URL中（像某些工具(PHP,JSP)那样）。</p><p class="cn" id="cn106">这是一个有意而为之的设计。 把session放在URL中不只是难看，更重要的是这让你的站点 很容易受到攻击——通过 <tt class="docutils literal"><span class="pre">Referer</span></tt> header进行session ID&#8221;窃听&#8221;而实施的攻击。</p></blockquote><p class="cn" id="cn107">如果你还是好奇，阅读源代码是最直接办法，详见 <tt class="docutils literal"><span class="pre">django.contrib.sessions</span></tt> 。</p></div></div><div class="section" id="authentication"><span id="cn108"></span><h2 class="cn" id="cn108">用户与Authentication</h2><p class="cn" id="cn109">通过session，我们可以在多次浏览器请求中保持数据， 接下来的部分就是用session来处理用户登录了。 当然，不能仅凭用户的一面之词，我们就相信，所以我们需要认证。</p><p class="cn" id="cn110">当然了，Django 也提供了工具来处理这样的常见任务（就像其他常见任务一样）。Django 用户认证系统处理用户帐号，组，权限以及基于cookie的用户会话。 这个系统一般被称为 <em>auth/auth</em> (认证与授权)系统。 这个系统的名称同时也表明了用户常见的两步处理。 我们需要</p><ol class="arabic simple"><li class="cn" id="cn111"><p class="first cn" id="cn111">验证 (<em>认证</em>) 用户是否是他所宣称的用户(一般通过查询数据库验证其用户名和密码)</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn112"><p class="first cn" id="cn112">验证用户是否拥有执行某种操作的 <em>授权</em> (通常会通过检查一个权限表来确认)</p></li></ol><p class="cn" id="cn113">根据这些需求，Django 认证/授权 系统会包含以下的部分：</p><ul class="simple"><li class="cn" id="cn114"><p class="first cn" id="cn114"><em>用户</em> : 在网站注册的人</p></li></ul><ul class="simple"><li class="cn" id="cn115"><p class="first cn" id="cn115"><em>权限</em> : 用于标识用户是否可以执行某种操作的二进制(yes/no)标志</p></li></ul><ul class="simple"><li class="cn" id="cn116"><p class="first cn" id="cn116"><em>组</em> :一种可以将标记和权限应用于多个用户的常用方法</p></li></ul><ul class="simple"><li class="cn" id="cn117"><p class="first cn" id="cn117"><em>Messages</em> : 向用户显示队列式的系统消息的常用方法</p></li></ul><p class="cn" id="cn118">如果你已经用了admin工具(详见第6章)，就会看见这些工具的大部分。如果你在admin工具中编辑过用户或组，那么实际上你已经编辑过授权系统的数据库表了。</p><div class="section" id="id7"><span id="cn119"></span><h3 class="cn" id="cn119">打开认证支持</h3><p class="cn" id="cn120">像session工具一样，认证支持也是一个Django应用，放在 <tt class="docutils literal"><span class="pre">django.contrib</span></tt> 中，所以也需要安装。 与session系统相似，它也是缺省安装的，但如果它已经被删除了，通过以下步骤也能重新安装上：</p><ol class="arabic simple"><li class="cn" id="cn121"><p class="first cn" id="cn121">根据本章早前的部分确认已经安装了session 框架。 需要确认用户使用cookie，这样sesson 框架才能正常使用。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn122"><p class="first cn" id="cn122">将 <tt class="docutils literal"><span class="pre">'django.contrib.auth'</span></tt> 放在你的 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置中，然后运行 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">syncdb</span></tt>以创建对应的数据库表。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn123"><p class="first cn" id="cn123">确认 <tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> 后面的 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 设置中包含 <tt class="docutils literal"><span class="pre">'django.contrib.auth.middleware.AuthenticationMiddleware'</span></tt> SessionMiddleware。</p></li></ol><p class="cn" id="cn124">这样安装后，我们就可以在视图(view)的函数中处理user了。 在视图中存取users，主要用 <tt class="docutils literal"><span class="pre">request.user</span></tt> ；这个对象表示当前已登录的用户。如果用户还没登录，这就是一个<tt class="docutils literal"><span class="pre">AnonymousUser</span></tt>对象(细节见下)。</p><p class="cn" id="cn125">你可以很容易地通过 <tt class="docutils literal"><span class="pre">is_authenticated()</span></tt> 方法来判断一个用户是否已经登录了：</p><pre class="cn literal-block" id="cn127">if request.user.is_authenticated():# Do something for authenticated users.else:# Do something for anonymous users.</pre></div><div class="section" id="user"><span id="cn128"></span><h3 class="cn" id="cn128">使用User对象</h3><p class="cn" id="cn129"><tt class="docutils literal"><span class="pre">User</span></tt> 实例一般从 <tt class="docutils literal"><span class="pre">request.user</span></tt> ，或是其他下面即将要讨论到的方法取得，它有很多属性和方法。 <tt class="docutils literal"><span class="pre">AnonymousUser</span></tt> 对象模拟了 <em>部分</em> 的接口，但不是全部，在把它当成真正的user对象 使用前，你得检查一下 <tt class="docutils literal"><span class="pre">user.is_authenticated()</span></tt> 表14-3和14-4分别列出了`` User`` 对象中的属性（fields)和方法。</p><table class="cn docutils" id="cn130"><caption>表 14-3.  <tt class="docutils literal"><span class="pre">User</span></tt> 对象属性</caption><colgroup><col width="20%" /><col width="80%" /></colgroup><thead valign="bottom"><tr><th class="head">属性</th><th class="head">描述</th></tr></thead><tbody valign="top"><tr><td>username</td><td>必需的，不能多于30个字符。 仅用字母数字式字符（字母、数字和下划线）。</td></tr><tr><td><tt class="docutils literal"><span class="pre">first_name</span></tt></td><td>可选; 少于等于30字符。</td></tr><tr><td><tt class="docutils literal"><span class="pre">last_name</span></tt></td><td>可选; 少于等于30字符。</td></tr><tr><td><tt class="docutils literal"><span class="pre">email</span></tt></td><td>可选。 邮件地址。</td></tr><tr><td><tt class="docutils literal"><span class="pre">password</span></tt></td><td>必需的。 密码的哈希值（Django不储存原始密码）。 See the Passwords section formore about this value.</td></tr><tr><td><tt class="docutils literal"><span class="pre">is_staff</span></tt></td><td>布尔值。 用户是否拥有网站的管理权限。</td></tr><tr><td><tt class="docutils literal"><span class="pre">is_active</span></tt></td><td>布尔值. 设置该账户是否可以登录。把该标志位置为<tt class="docutils literal"><span class="pre">False</span></tt>而不是直接删除账户。</td></tr><tr><td><tt class="docutils literal"><span class="pre">is_superuser</span></tt></td><td>布尔值 标识用户是否拥有所有权限，无需显式地权限分配定义。</td></tr><tr><td><tt class="docutils literal"><span class="pre">last_login</span></tt></td><td>用户上次登录的时间日期。 它被默认设置为当前的日期/时间。</td></tr><tr><td><tt class="docutils literal"><span class="pre">date_joined</span></tt></td><td>账号被创建的日期时间 当账号被创建时，它被默认设置为当前的日期/时间。</td></tr></tbody></table><div class="system-message"><p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">&lt;string&gt;</tt>, line 735)</p><p class="cn" id="cn131">Error parsing content block for the &#8220;table&#8221; directive: exactly one table expected.</p><pre class="cn literal-block" id="cn131">.. table:: 表 14-4. ``User`` 对象方法+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|方法                                                                                         |描述                                                                                                                                                  |+=============================================================================================+======================================================================================================================================================+|``is_authenticated()``                                                                       |对于真实的User对象，总是返回\ `` True`` 。                                                                                                            ||                                                                                             |这是一个分辨用户是否已被鉴证的方法。 它并不意味着任何权限，也不检查用户是否仍是活动的。 它仅说明此用户已被成功鉴证。                                  |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``is_anonymous()``                                                                           |对于\ `` AnonymousUser`` 对象返回\ `` True`` （对于真实的\ `` User`` 对象返回\ `` False`` ）。                                                        ||                                                                                             |总的来说，比起这个方法，你应该倾向于使用\ `` is_authenticated()`` 方法。                                                                              |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``get_full_name()``                                                                          |返回\ `` first_name`` 加上\ `` last_name`` ，中间插入一个空格。                                                                                       |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``set_password(passwd)``                                                                     |设定用户密码为指定字符串（自动处理成哈希串）。 实际上没有保存\ ``User``\对象。                                                                        |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|check_password(passwd)                                                                       |如果指定的字符串与用户密码匹配则返回\ ``True``\。 比较时会使用密码哈希表。                                                                            |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``get_group_permissions()``                                                                  |返回一个用户通过其所属组获得的权限字符串列表。                                                                                                        |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``get_all_permissions()``                                                                    |返回一个用户通过其所属组以及自身权限所获得的权限字符串列表。                                                                                          |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``has_perm(perm)``                                                                           |如果用户有指定的权限，则返回\ `` True`` ，此时\ `` perm`` 的格式是\ `` &quot;package.codename&quot;`` 。如果用户已不活动，此方法总是返回\ `` False`` 。         |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|has_perms(perm_list)                                                                         |如果用户拥有\ * 全部* 的指定权限，则返回\ `` True`` 。 如果用户是不活动的，这个方法总是返回\ `` False`` 。                                            |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``has_module_perms(app_label)``                                                              |如果用户拥有给定的\ `` app_label`` 中的任何权限，则返回\ `` True`` 。如果用户已不活动，这个方法总是返回\ `` False`` 。                                |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|get_and_delete_messages()                                                                    |返回一个用户队列中的\ `` Message`` 对象列表，并从队列中将这些消息删除。                                                                               |+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+|``email_user(subj, msg)``                                                                    |向用户发送一封电子邮件。 这封电子邮件是从\ `` DEFAULT_FROM_EMAIL`` 设置的地址发送的。 你还可以传送一个第三参数：\ `` from_email`` ，以覆盖电邮中的发送地址。|+---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+</pre></div><p class="cn" id="cn132">最后，`` User`` 对象有两个many-to-many属性。 `` groups`` 和`` permissions`` 。正如其他的many-to-many属性使用的方法一样，`` User`` 对象可以获得它们相关的对象：</p><pre class="cn literal-block" id="cn134"># Set a user's groups:myuser.groups = group_list# Add a user to some groups:myuser.groups.add(group1, group2,...)# Remove a user from some groups:myuser.groups.remove(group1, group2,...)# Remove a user from all groups:myuser.groups.clear()# Permissions work the same waymyuser.permissions = permission_listmyuser.permissions.add(permission1, permission2, ...)myuser.permissions.remove(permission1, permission2, ...)myuser.permissions.clear()</pre></div><div class="section" id="id8"><span id="cn135"></span><h3 class="cn" id="cn135">登录和退出</h3><dl class="docutils"><dt>Django 提供内置的视图(view)函数用于处理登录和退出 (以及其他奇技淫巧)，但在开始前，我们来看看如何手工登录和退出。 Django提供两个函数来执行<tt class="docutils literal"><span class="pre">django.contrib.auth</span></tt>\中的动作 <span class="classifier-delimiter">:</span> <span class="classifier"><tt class="docutils literal"><span class="pre">authenticate()</span></tt></span></dt><dd><p class="first last cn" id="cn136">和<tt class="docutils literal"><span class="pre">login()</span></tt>。</p></dd></dl><p class="cn" id="cn137">认证给出的用户名和密码，使用 <tt class="docutils literal"><span class="pre">authenticate()</span></tt> 函数。它接受两个参数，用户名 username 和 密码 password ，并在密码对给出的用户名合法的情况下返回一个 User 对象。 如果密码不合法，<tt class="docutils literal"><span class="pre">authenticate()</span></tt>返回<tt class="docutils literal"><span class="pre">None</span></tt>。</p><pre class="cn literal-block" id="cn139">&gt;&gt;&gt; from django.contrib import auth&gt;&gt;&gt; user = auth.authenticate(username='john', password='secret')&gt;&gt;&gt; if user is not None:...     print &quot;Correct!&quot;... else:...     print &quot;Invalid password.&quot;</pre><p class="cn" id="cn140"><tt class="docutils literal"><span class="pre">authenticate()</span></tt> 只是验证一个用户的证书而已。 而要登录一个用户，使用 <tt class="docutils literal"><span class="pre">login()</span></tt> 。该函数接受一个 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 对象和一个 <tt class="docutils literal"><span class="pre">User</span></tt> 对象作为参数并使用Django的会话（ <tt class="docutils literal"><span class="pre">session</span></tt> ）框架把用户的ID保存在该会话中。</p><p class="cn" id="cn141">下面的例子演示了如何在一个视图中同时使用 <tt class="docutils literal"><span class="pre">authenticate()</span></tt> 和 <tt class="docutils literal"><span class="pre">login()</span></tt> 函数：</p><pre class="cn literal-block" id="cn143">from django.contrib import authdef login_view(request):username = request.POST.get('username', '')password = request.POST.get('password', '')user = auth.authenticate(username=username, password=password)if user is not None and user.is_active:# Correct password, and the user is marked &quot;active&quot;auth.login(request, user)# Redirect to a success page.return HttpResponseRedirect(&quot;/account/loggedin/&quot;)else:# Show an error pagereturn HttpResponseRedirect(&quot;/account/invalid/&quot;)</pre><p class="cn" id="cn144">注销一个用户，在你的视图中使用 <tt class="docutils literal"><span class="pre">django.contrib.auth.logout()</span></tt> 。 它接受一个<tt class="docutils literal"><span class="pre">HttpRequest</span></tt>对象并且没有返回值。</p><pre class="cn literal-block" id="cn146">from django.contrib import authdef logout_view(request):auth.logout(request)# Redirect to a success page.return HttpResponseRedirect(&quot;/account/loggedout/&quot;)</pre><p class="cn" id="cn147">注意，即使用户没有登录， <tt class="docutils literal"><span class="pre">logout()</span></tt> 也不会抛出任何异常。</p><p class="cn" id="cn148">在实际中，你一般不需要自己写登录/登出的函数；认证系统提供了一系例视图用来处理登录和登出。 使用认证视图的第一步是把它们写在你的URLconf中。 你需要这样写：</p><pre class="cn literal-block" id="cn150">from django.contrib.auth.views import login, logouturlpatterns = patterns('',# existing patterns here...(r'^accounts/login/$',  login),(r'^accounts/logout/$', logout),)</pre><p class="cn" id="cn151"><tt class="docutils literal"><span class="pre">/accounts/login/</span></tt> 和 <tt class="docutils literal"><span class="pre">/accounts/logout/</span></tt> 是Django提供的视图的默认URL。</p><p class="cn" id="cn152">缺省情况下， <tt class="docutils literal"><span class="pre">login</span></tt> 视图渲染 <tt class="docutils literal"><span class="pre">registragiton/login.html</span></tt> 模板(可以通过视图的额外参数 <tt class="docutils literal"><span class="pre">template_name</span></tt> 修改这个模板名称)。 这个表单必须包含 <tt class="docutils literal"><span class="pre">username</span></tt> 和 <tt class="docutils literal"><span class="pre">password</span></tt> 域。如下示例： 一个简单的 template 看起来是这样的</p><pre class="cn literal-block" id="cn154">{% extends &quot;base.html&quot; %}{% block content %}{% if form.errors %}&lt;p class=&quot;error&quot;&gt;Sorry, that's not a valid username or password&lt;/p&gt;{% endif %}&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;label for=&quot;username&quot;&gt;User name:&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; id=&quot;username&quot;&gt;&lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot; id=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;login&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;{{ next|escape }}&quot; /&gt;&lt;/form&gt;{% endblock %}</pre><p class="cn" id="cn155">如果用户登录成功，缺省会重定向到 <tt class="docutils literal"><span class="pre">/accounts/profile</span></tt> 。 你可以提供一个保存登录后重定向URL的<tt class="docutils literal"><span class="pre">next</span></tt>隐藏域来重载它的行为。 也可以把值以<tt class="docutils literal"><span class="pre">GET</span></tt>参数的形式发送给视图函数，它会以变量<tt class="docutils literal"><span class="pre">next</span></tt>的形式保存在上下文中，这样你就可以把它用在隐藏域上了。</p><p class="cn" id="cn156">logout视图有一些不同。 默认情况下它渲染 <tt class="docutils literal"><span class="pre">registration/logged_out.html</span></tt> 模板（这个视图一般包含你已经成功退出的信息）。 视图中还可以包含一个参数 <tt class="docutils literal"><span class="pre">next_page</span></tt> 用于退出后重定向。</p></div><div class="section" id="id9"><span id="cn157"></span><h3 class="cn" id="cn157">限制已登录用户的访问</h3><p class="cn" id="cn158">有很多原因需要控制用户访问站点的某部分。</p><p class="cn" id="cn159">一个简单原始的限制方法是检查 <tt class="docutils literal"><span class="pre">request.user.is_authenticated()</span></tt> ,然后重定向到登陆页面：</p><pre class="cn literal-block" id="cn161">from django.http import HttpResponseRedirectdef my_view(request):if not request.user.is_authenticated():return HttpResponseRedirect('/accounts/login/?next=%s' % request.path)# ...</pre><p class="cn" id="cn162">或者显示一个出错信息：</p><pre class="cn literal-block" id="cn164">def my_view(request):if not request.user.is_authenticated():return render_to_response('myapp/login_error.html')# ...</pre><p class="cn" id="cn165">作为一个快捷方式, 你可以使用便捷的 <tt class="docutils literal"><span class="pre">login_required</span></tt> 修饰符:</p><pre class="cn literal-block" id="cn167">from django.contrib.auth.decorators import login_required&#64;login_requireddef my_view(request):# ...</pre><p class="cn" id="cn168"><tt class="docutils literal"><span class="pre">login_required</span></tt> 做下面的事情:</p><ul class="simple"><li class="cn" id="cn169"><p class="first cn" id="cn169">如果用户没有登录, 重定向到 <tt class="docutils literal"><span class="pre">/accounts/login/</span></tt> , 把当前绝对URL作为 <tt class="docutils literal"><span class="pre">next</span></tt> 在查询字符串中传递过去, 例如：/accounts/login/?next=/polls/3/ 。</p></li></ul><ul class="simple"><li class="cn" id="cn170"><p class="first cn" id="cn170">如果用户已经登录, 正常地执行视图函数。 视图代码就可以假定用户已经登录了。</p></li></ul></div><div class="section" id="id10"><span id="cn171"></span><h3 class="cn" id="cn171">对通过测试的用户限制访问</h3><p class="cn" id="cn172">限制访问可以基于某种权限，某些检查或者为login视图提供不同的位置，这些实现方式大致相同。</p><p class="cn" id="cn173">一般的方法是直接在视图的 <tt class="docutils literal"><span class="pre">request.user</span></tt> 上运行检查。 例如，下面视图确认用户登录并是否有 <tt class="docutils literal"><span class="pre">polls.can_vote</span></tt>权限：</p><pre class="cn literal-block" id="cn175">def vote(request):if request.user.is_authenticated() and request.user.has_perm('polls.can_vote')):# vote hereelse:return HttpResponse(&quot;You can't vote in this poll.&quot;)</pre><p class="cn" id="cn176">并且Django有一个称为 <tt class="docutils literal"><span class="pre">user_passes_test</span></tt> 的简洁方式。它接受参数然后为你指定的情况生成装饰器。</p><pre class="cn literal-block" id="cn178">def user_can_vote(user):return user.is_authenticated() and user.has_perm(&quot;polls.can_vote&quot;)&#64;user_passes_test(user_can_vote, login_url=&quot;/login/&quot;)def vote(request):# Code here can assume a logged-in user with the correct permission....</pre><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">user_passes_test</span></tt> 使用一个必需的参数： 一个可调用的方法，当存在 <tt class="docutils literal"><span class="pre">User</span></tt> 对象并当此用户允许查看该页面时返回 <tt class="docutils literal"><span class="pre">True</span></tt> 。 注意 user_passes_test 不会自动检查 User</dt><dd><p class="first last cn" id="cn179">是否认证，你应该自己做这件事。</p></dd></dl><p class="cn" id="cn180">例子中我们也展示了第二个可选的参数 <tt class="docutils literal"><span class="pre">login_url</span></tt> ，它让你指定你的登录页面的URL（默认为 <tt class="docutils literal"><span class="pre">/accounts/login/</span></tt> ）。 如果用户没有通过测试，那么<tt class="docutils literal"><span class="pre">user_passes_test</span></tt>将把用户重定向到<tt class="docutils literal"><span class="pre">login_url</span></tt></p><p class="cn" id="cn181">既然检查用户是否有一个特殊权限是相对常见的任务，Django为这种情形提供了一个捷径： <tt class="docutils literal"><span class="pre">permission_required()</span></tt> 装饰器。 使用这个装饰器，前面的例子可以改写为：</p><pre class="cn literal-block" id="cn183">from django.contrib.auth.decorators import permission_required&#64;permission_required('polls.can_vote', login_url=&quot;/login/&quot;)def vote(request):# ...</pre><p class="cn" id="cn184">注意, <tt class="docutils literal"><span class="pre">permission_required()</span></tt> 也有一个可选的 <tt class="docutils literal"><span class="pre">login_url</span></tt> 参数, 这个参数默认为 <tt class="docutils literal"><span class="pre">'/accounts/login/'</span></tt> 。</p><p class="cn" id="cn185">限制通用视图的访问</p><p class="cn" id="cn186">在Django用户邮件列表中问到最多的问题是关于对通用视图的限制性访问。 为实现这个功能，你需要自己包装视图，并且在URLconf中，将你自己的版本替换通用视图：</p><pre class="cn literal-block" id="cn188">from django.contrib.auth.decorators import login_requiredfrom django.views.generic.date_based import object_detail&#64;login_requireddef limited_object_detail(*args, **kwargs):return object_detail(*args, **kwargs)</pre><p class="cn" id="cn189">当然, 你可以用任何其他限定修饰符来替换 <tt class="docutils literal"><span class="pre">login_required</span></tt> 。</p></div><div class="section" id="users-permissions-groups"><span id="cn190"></span><h3 class="cn" id="cn190">管理 Users, Permissions 和 Groups</h3><p class="cn" id="cn191">管理认证系统最简单的方法是通过管理界面。第六章讨论了怎样使用Django的管理界面来编辑用户和控制他们的权限和可访问性，并且大多数时间你使用这个界面就可以了。</p><p class="cn" id="cn192">然而，当你需要绝对的控制权的时候，有一些低层 API 需要深入专研，我们将在下面的章节中讨论它们。</p><div class="section" id="id11"><span id="cn193"></span><h4 class="cn" id="cn193">创建用户</h4><p class="cn" id="cn194">使用 <tt class="docutils literal"><span class="pre">create_user</span></tt> 辅助函数创建用户:</p><pre class="cn literal-block" id="cn196">&gt;&gt;&gt; from django.contrib.auth.models import User&gt;&gt;&gt; user = User.objects.create_user(username='john',...                                 email='jlennon&#64;beatles.com',...                                 password='glass onion')</pre><p class="cn" id="cn197">在这里， <tt class="docutils literal"><span class="pre">user</span></tt> 是 <tt class="docutils literal"><span class="pre">User</span></tt> 类的一个实例，准备用于向数据库中存储数据。（<tt class="docutils literal"><span class="pre">create_user()</span></tt>实际上没有调用<tt class="docutils literal"><span class="pre">save()</span></tt>）。 <tt class="docutils literal"><span class="pre">create_user()</span></tt> 函数并没有在数据库中创建记录，在保存数据之前，你仍然可以继续修改它的属性值。</p><pre class="cn literal-block" id="cn199">&gt;&gt;&gt; user.is_staff = True&gt;&gt;&gt; user.save()</pre></div><div class="section" id="id12"><span id="cn200"></span><h4 class="cn" id="cn200">修改密码</h4><p class="cn" id="cn201">你可以使用 <tt class="docutils literal"><span class="pre">set_password()</span></tt> 来修改密码：</p><pre class="cn literal-block" id="cn203">&gt;&gt;&gt; user = User.objects.get(username='john')&gt;&gt;&gt; user.set_password('goo goo goo joob')&gt;&gt;&gt; user.save()</pre><p class="cn" id="cn204">除非你清楚的知道自己在做什么，否则不要直接修改 <tt class="docutils literal"><span class="pre">password</span></tt> 属性。 其中保存的是密码的 <em>加入salt的hash值</em> ，所以不能直接编辑。</p><p class="cn" id="cn205">一般来说， <tt class="docutils literal"><span class="pre">User</span></tt> 对象的 <tt class="docutils literal"><span class="pre">password</span></tt> 属性是一个字符串，格式如下：</p><pre class="cn literal-block" id="cn207">hashtype$salt$hash</pre><p class="cn" id="cn208">这是哈希类型，salt和哈希本身，用美元符号（$）分隔。</p><p class="cn" id="cn209"><tt class="docutils literal"><span class="pre">hashtype</span></tt> 是 <tt class="docutils literal"><span class="pre">sha1</span></tt> （默认）或者 <tt class="docutils literal"><span class="pre">md5</span></tt> ，它是用来处理单向密码哈希的算法。 Salt是一个用来加密原始密码以创建哈希的随机字符串，例如:</p><pre class="cn literal-block" id="cn211">sha1$a1976$a36cc8cbf81742a8fb52e221aaeab48ed7f58ab4</pre><p class="cn" id="cn212"><tt class="docutils literal"><span class="pre">User.set_password()</span></tt> 和 <tt class="docutils literal"><span class="pre">User.check_password()</span></tt> 函数在后台处理和检查这些值。</p><p class="cn" id="cn213">salt化得哈希值</p><p class="cn" id="cn214">一次 <em>哈希</em> 是一次单向的加密过程，你能容易地计算出一个给定值的哈希码，但是几乎不可能从一个哈希码解出它的原值。</p><p class="cn" id="cn215">如果我们以普通文本存储密码,任何能进入数据库的人都能轻易的获取每个人的密码。 使用哈希方式来存储密码相应的减少了数据库泄露密码的可能。</p><p class="cn" id="cn216">然而，攻击者仍然可以使用 <em>暴力破解</em> 使用上百万个密码与存储的值对比来获取数据库密码。 这需要花一些时间，但是智能电脑惊人的速度超出了你的想象。</p><p class="cn" id="cn217">更糟糕的是我们可以公开地得到 <em>rainbow tables</em> （一种暴力密码破解表）或预备有上百万哈希密码值的数据库。 使用rainbow tables可以在几秒之内就能搞定最复杂的一个密码。</p><p class="cn" id="cn218">在存储的hash值的基础上，加入 <em>salt</em> 值（一个随机值），增加了密码的强度，使得破解更加困难。 因为每个密码的salt值都不相同，这也限制了rainbow table的使用，使得攻击者只能使用最原始的暴力破解方法。</p><p class="cn" id="cn219">加入salt值得hash并不是绝对安全的存储密码的方法，然而却是安全和方便之间很好的折衷。</p></div><div class="section" id="id13"><span id="cn220"></span><h4 class="cn" id="cn220">处理注册</h4><p class="cn" id="cn221">我们可以使用这些底层工具来创建允许用户注册的视图。 最近每个开发人员都希望实现各自不同的注册方法，所以Django把写注册视图的工作留给了你。 幸运的是，这很容易。</p><p class="cn" id="cn222">作为这个事情的最简化处理, 我们可以提供一个小视图, 提示一些必须的用户信息并创建这些用户。 Django为此提供了可用的内置表单, 下面这个例子就使用了这个表单:</p><pre class="cn literal-block" id="cn224">from django import formsfrom django.contrib.auth.forms import UserCreationFormfrom django.http import HttpResponseRedirectfrom django.shortcuts import render_to_responsedef register(request):if request.method == 'POST':form = UserCreationForm(request.POST)if form.is_valid():new_user = form.save()return HttpResponseRedirect(&quot;/books/&quot;)else:form = UserCreationForm()return render_to_response(&quot;registration/register.html&quot;, {'form': form,})</pre><p class="cn" id="cn225">这个表单需要一个叫 <tt class="docutils literal"><span class="pre">registration/register.html</span></tt> 的模板。这个模板可能是这样的：</p><pre class="cn literal-block" id="cn227">{% extends &quot;base.html&quot; %}{% block title %}Create an account{% endblock %}{% block content %}&lt;h1&gt;Create an account&lt;/h1&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;{{ form.as_p }}&lt;input type=&quot;submit&quot; value=&quot;Create the account&quot;&gt;&lt;/form&gt;{% endblock %}</pre></div></div><div class="section" id="id14"><span id="cn228"></span><h3 class="cn" id="cn228">在模板中使用认证数据</h3><p class="cn" id="cn229">当前登入的用户以及他（她）的权限可以通过 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 在模板的context中使用（详见第9章）。</p><p class="cn" id="cn230">注意</p><p class="cn" id="cn231">从技术上来说，只有当你使用了 <tt class="docutils literal"><span class="pre">RequestContext</span></tt>这些变量才可用。 <em>并且</em>TEMPLATE_CONTEXT_PROCESSORS 设置包含了 &#8220;django.core.context_processors.auth&#8221; （默认情况就是如此）时，这些变量才能在模板context中使用。 <tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt> 设置包含了 <tt class="docutils literal"><span class="pre">&quot;django.core.context_processors.auth&quot;</span></tt> （默认情况就是如此）时，这些变量才能在模板context中使用。</p><p class="cn" id="cn232">当使用 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 时, 当前用户 (是一个 <tt class="docutils literal"><span class="pre">User</span></tt> 实例或一个 <tt class="docutils literal"><span class="pre">AnonymousUser</span></tt> 实例) 存储在模板变量 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">user</span> <span class="pre">}}</span></tt> 中:</p><pre class="cn literal-block" id="cn234">{% if user.is_authenticated %}&lt;p&gt;Welcome, {{ user.username }}. Thanks for logging in.&lt;/p&gt;{% else %}&lt;p&gt;Welcome, new user. Please log in.&lt;/p&gt;{% endif %}</pre><p class="cn" id="cn235">这些用户的权限信息存储在 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">perms</span> <span class="pre">}}</span></tt> 模板变量中。</p><p class="cn" id="cn236">你有两种方式来使用 <tt class="docutils literal"><span class="pre">perms</span></tt> 对象。 你可以使用类似于 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">perms.polls</span> <span class="pre">}}</span></tt> 的形式来检查，对于某个特定的应用，一个用户是否具有 <em>任意</em> 权限；你也可以使用 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">perms.polls.can_vote</span> <span class="pre">}}</span></tt> 这样的形式，来检查一个用户是否拥有特定的权限。</p><p class="cn" id="cn237">这样你就可以在模板中的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 语句中检查权限:</p><pre class="cn literal-block" id="cn239">{% if perms.polls %}&lt;p&gt;You have permission to do something in the polls app.&lt;/p&gt;{% if perms.polls.can_vote %}&lt;p&gt;You can vote!&lt;/p&gt;{% endif %}{% else %}&lt;p&gt;You don't have permission to do anything in the polls app.&lt;/p&gt;{% endif %}</pre></div></div><div class="section" id="id15"><span id="cn240"></span><h2 class="cn" id="cn240">权限、组和消息</h2><p class="cn" id="cn241">在认证框架中还有其他的一些功能。 我们会在接下来的几个部分中进一步地了解它们。</p><div class="section" id="id16"><span id="cn242"></span><h3 class="cn" id="cn242">权限</h3><p class="cn" id="cn243">权限可以很方便地标识用户和用户组可以执行的操作。 它们被Django的admin管理站点所使用，你也可以在你自己的代码中使用它们。</p><p class="cn" id="cn244">Django的admin站点如下使用权限：</p><ul class="simple"><li class="cn" id="cn245"><p class="first cn" id="cn245">只有设置了 <em>add</em> 权限的用户才能使用添加表单，添加对象的视图。</p></li></ul><ul class="simple"><li class="cn" id="cn246"><p class="first cn" id="cn246">只有设置了 <em>change</em> 权限的用户才能使用变更列表，变更表格，变更对象的视图。</p></li></ul><ul class="simple"><li class="cn" id="cn247"><p class="first cn" id="cn247">只有设置了 <em>delete</em> 权限的用户才能删除一个对象。</p></li></ul><p class="cn" id="cn248">权限是根据每一个类型的对象而设置的，并不具体到对象的特定实例。例如，我们可以允许Mary改变新故事，但是目前还不允许设置Mary只能改变自己创建的新故事，或者根据给定的状态，出版日期或者ID号来选择权限。</p><p class="cn" id="cn249">会自动为每一个Django模型创建三个基本权限：增加、改变和删除。 当你运行<tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">syncdb</span></tt>命令时，这些权限被添加到<tt class="docutils literal"><span class="pre">auth_permission</span></tt>数据库表中。</p><p class="cn" id="cn250">权限以 <tt class="docutils literal"><span class="pre">&quot;&lt;app&gt;.&lt;action&gt;_&lt;object_name&gt;&quot;</span></tt> 的形式出现。</p><p class="cn" id="cn251">就跟用户一样，权限也就是Django模型中的 <tt class="docutils literal"><span class="pre">django.contrib.auth.models</span></tt> 。因此如果你愿意，你也可以通过Django的数据库API直接操作权限。</p></div><div class="section" id="id17"><span id="cn252"></span><h3 class="cn" id="cn252">组</h3><p class="cn" id="cn253">组提供了一种通用的方式来让你按照一定的权限规则和其他标签将用户分类。 一个用户可以隶属于任何数量的组。</p><p class="cn" id="cn254">在一个组中的用户自动获得了赋予该组的权限。 例如， <tt class="docutils literal"><span class="pre">Site</span> <span class="pre">editors</span></tt> 组拥有 <tt class="docutils literal"><span class="pre">can_edit_home_page</span></tt> 权限，任何在该组中的用户都拥有这个权限。</p><p class="cn" id="cn255">组也可以通过给定一些用户特殊的标记，来扩展功能。 例如，你创建了一个 <tt class="docutils literal"><span class="pre">'Special</span> <span class="pre">users'</span></tt> 组，并且允许组中的用户访问站点的一些VIP部分，或者发送VIP的邮件消息。</p><p class="cn" id="cn256">和用户管理一样，admin接口是管理组的最简单的方法。然而，组也就是Django模型 <tt class="docutils literal"><span class="pre">django.contrib.auth.models</span></tt> ，因此你可以使用Django的数据库API，在底层访问这些组。</p></div><div class="section" id="id18"><span id="cn257"></span><h3 class="cn" id="cn257">消息</h3><p class="cn" id="cn258">消息系统会为给定的用户接收消息。 每个消息都和一个 <tt class="docutils literal"><span class="pre">User</span></tt> 相关联。</p><p class="cn" id="cn259">在每个成功的操作以后，Django的admin管理接口就会使用消息机制。 例如，当你创建了一个对象，你会在admin页面的顶上看到 <tt class="docutils literal"><span class="pre">The</span> <span class="pre">object</span> <span class="pre">was</span> <span class="pre">created</span> <span class="pre">successfully</span></tt> 的消息。</p><p class="cn" id="cn260">你也可以使用相同的API在你自己的应用中排队接收和显示消息。 API非常地简单：</p><ul class="simple"><li class="cn" id="cn261"><p class="first cn" id="cn261">要创建一条新的消息，使用 <tt class="docutils literal"><span class="pre">user.message_set.create(message='message_text')</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn262"><p class="first cn" id="cn262">要获得/删除消息，使用 <tt class="docutils literal"><span class="pre">user.get_and_delete_messages()</span></tt> ，这会返回一个 <tt class="docutils literal"><span class="pre">Message</span></tt> 对象的列表，并且从队列中删除返回的项。</p></li></ul><p class="cn" id="cn263">在例子视图中，系统在创建了播放单（playlist）以后，为用户保存了一条消息。</p><pre class="cn literal-block" id="cn265">def create_playlist(request, songs):# Create the playlist with the given songs.# ...request.user.message_set.create(message=&quot;Your playlist was added successfully.&quot;)return render_to_response(&quot;playlists/create.html&quot;,context_instance=RequestContext(request))</pre><p class="cn" id="cn266">当使用 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> ，当前登录的用户以及他（她）的消息，就会以模板变量 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">messages</span> <span class="pre">}}</span></tt> 出现在模板的context中。</p><pre class="cn literal-block" id="cn268">{% if messages %}&lt;ul&gt;{% for message in messages %}&lt;li&gt;{{ message }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;{% endif %}</pre><p class="cn" id="cn269">需要注意的是 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 会在后台调用 <tt class="docutils literal"><span class="pre">get_and_delete_messages</span></tt> ，因此即使你没有显示它们，它们也会被删除掉。</p><p class="cn" id="cn270">最后注意，这个消息框架只能服务于在用户数据库中存在的用户。 如果要向匿名用户发送消息，请直接使用会话框架。</p></div></div><div class="section" id="id19"><span id="cn271"></span><h2 class="cn" id="cn271">下一章</h2><p class="cn" id="cn272">是的，会话和认证系统有太多的东西要学。 大多数情况下，你并不需要本章所提到的所有功能。</p><p class="cn" id="cn273">在` 下一章 &lt;chapter15.html&gt;`__ ，我们会看一下Django的缓存机制，这是一个提高你的网页应用性能的便利的办法。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter13.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter15.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>