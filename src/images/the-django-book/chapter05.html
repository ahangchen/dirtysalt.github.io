<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第五章：模型</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter04.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter06.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第5章 模型</h1><p class="cn" id="cn1">在第三章，我们讲述了用 Django 建造网站的基本途径： 建立视图和 URLConf 。 正如我们所阐述的，视图负责处理<em>一些主观逻辑</em>，然后返回响应结果。 作为例子之一，我们的主观逻辑是要计算当前的日期和时间。</p><p class="cn" id="cn2">在当代 Web 应用中，主观逻辑经常牵涉到与数据库的交互。 <em>数据库驱动网站</em> 在后台连接数据库服务器，从中取出一些数据，然后在 Web 页面用漂亮的格式展示这些数据。 这个网站也可能会向访问者提供修改数据库数据的方法。</p><p class="cn" id="cn3">许多复杂的网站都提供了以上两个功能的某种结合。 例如 Amazon.com 就是一个数据库驱动站点的良好范例。 本质上，每个产品页面都是数据库中数据以 HTML格式进行的展现，而当你发表客户评论时，该评论被插入评论数据库中。</p><p class="cn" id="cn4">由于先天具备 Python 简单而强大的数据库查询执行方法，Django 非常适合开发数据库驱动网站。 本章深入介绍了该功能： Django 数据库层。</p><p class="cn" id="cn5">（注意： 尽管对 Django 数据库层的使用中并不特别强调这点，但是我们还是强烈建议您掌握一些数据库和 SQL 原理。 对这些概念的介绍超越了本书的范围，但就算你是数据库方面的菜鸟，我们也建议你继续阅读。 你也许能够跟上进度，并在上下文学习过程中掌握一些概念。）</p><div class="section" id="id2"><span id="cn6"></span><h2 class="cn" id="cn6">在视图中进行数据库查询的笨方法</h2><p class="cn" id="cn7">正如第三章详细介绍的那个在视图中输出 HTML 的笨方法（通过在视图里对文本直接硬编码HTML），在视图中也有笨方法可以从数据库中获取数据。 很简单：用现有的任何 Python 类库执行一条 SQL 查询并对结果进行一些处理。</p><p class="cn" id="cn8">在本例的视图中，我们使用了 <tt class="docutils literal"><span class="pre">MySQLdb</span></tt> 类库（可以从 <a class="reference external" href="http://www.djangoproject.com/r/python-mysql/">http://www.djangoproject.com/r/python-mysql/</a> 获得）来连接 MySQL 数据库，取回一些记录，将它们提供给模板以显示一个网页：</p><pre class="cn literal-block" id="cn10">from django.shortcuts import render_to_responseimport MySQLdbdef book_list(request):db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')cursor = db.cursor()cursor.execute('SELECT name FROM books ORDER BY name')names = [row[0] for row in cursor.fetchall()]db.close()return render_to_response('book_list.html', {'names': names})</pre><p class="cn" id="cn11">这个方法可用，但很快一些问题将出现在你面前：</p><ul class="simple"><li class="cn" id="cn12"><p class="first cn" id="cn12">我们将数据库连接参数硬行编码于代码之中。 理想情况下，这些参数应当保存在 Django 配置中。</p></li></ul><ul class="simple"><li class="cn" id="cn13"><p class="first cn" id="cn13">我们不得不重复同样的代码： 创建数据库连接、创建数据库游标、执行某个语句、然后关闭数据库。 理想情况下，我们所需要应该只是指定所需的结果。</p></li></ul><ul class="simple"><li class="cn" id="cn14"><p class="first cn" id="cn14">它把我们栓死在 MySQL 之上。 如果过段时间，我们要从 MySQL 换到 PostgreSQL，就不得不使用不同的数据库适配器（例如 <tt class="docutils literal"><span class="pre">psycopg</span></tt> 而不是 <tt class="docutils literal"><span class="pre">MySQLdb</span></tt> ），改变连接参数，根据 SQL 语句的类型可能还要修改SQL 。 理想情况下，应对所使用的数据库服务器进行抽象，这样一来只在一处修改即可变换数据库服务器。 （如果你正在建立一个开源的Django应用程序来尽可能让更多人使用的话，这个特性是非常适当的。）</p></li></ul><p class="cn" id="cn15">正如你所期待的，Django数据库层正是致力于解决这些问题。 以下提前揭示了如何使用 Django 数据库 API 重写之前那个视图。</p><pre class="cn literal-block" id="cn17">from django.shortcuts import render_to_responsefrom mysite.books.models import Bookdef book_list(request):books = Book.objects.order_by('name')return render_to_response('book_list.html', {'books': books})</pre><p class="cn" id="cn18">我们将在本章稍后的地方解释这段代码。 目前而言，仅需对它有个大致的认识。</p></div><div class="section" id="mtv"><span id="cn19"></span><h2 class="cn" id="cn19">MTV 开发模式</h2><p class="cn" id="cn20">在钻研更多代码之前，让我们先花点时间考虑下 Django 数据驱动 Web 应用的总体设计。</p><p class="cn" id="cn21">我们在前面章节提到过，Django 的设计鼓励松耦合及对应用程序中不同部分的严格分割。 遵循这个理念的话，要想修改应用的某部分而不影响其它部分就比较容易了。 在视图函数中，我们已经讨论了通过模板系统把业务逻辑和表现逻辑分隔开的重要性。 在数据库层中，我们对数据访问逻辑也应用了同样的理念。</p><p class="cn" id="cn22">把数据存取逻辑、业务逻辑和表现逻辑组合在一起的概念有时被称为软件架构的 <em>Model-View-Controller</em> (MVC)模式。 在这个模式中， Model 代表数据存取层，View 代表的是系统中选择显示什么和怎么显示的部分，Controller 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。</p><p class="cn" id="cn23">为什么用缩写？</p><p class="cn" id="cn24">像 MVC 这样的明确定义模式的主要用于改善开发人员之间的沟通。 比起告诉同事，“让我们采用抽象的数据存取方式，然后单独划分一层来显示数据，并且在中间加上一个控制它的层”，一个通用的说法会让你收益，你只需要说：“我们在这里使用MVC模式吧。”。</p><p class="cn" id="cn25">Django 紧紧地遵循这种 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：</p><ul class="simple"><li class="cn" id="cn26"><p class="first cn" id="cn26"><em>M</em> ，数据存取部分，由django数据库层处理，本章要讲述的内容。</p></li></ul><ul class="simple"><li class="cn" id="cn27"><p class="first cn" id="cn27"><em>V</em> ，选择显示哪些数据要显示以及怎样显示的部分，由视图和模板处理。</p></li></ul><ul class="simple"><li class="cn" id="cn28"><p class="first cn" id="cn28"><em>C</em> ，根据用户输入委派视图的部分，由 Django 框架根据 URLconf 设置，对给定 URL 调用适当的 Python 函数。</p></li></ul><p class="cn" id="cn29">由于 C 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），Django 也被称为 <em>MTV 框架</em> 。在 MTV 开发模式中：</p><ul class="simple"><li class="cn" id="cn30"><p class="first cn" id="cn30"><em>M</em> 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。</p></li></ul><ul class="simple"><li class="cn" id="cn31"><p class="first cn" id="cn31"><em>T</em> 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p></li></ul><ul class="simple"><li class="cn" id="cn32"><p class="first cn" id="cn32"><em>V</em> 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p></li></ul><p class="cn" id="cn33">如果你熟悉其它的 MVC Web开发框架，比方说 Ruby on Rails，你可能会认为 Django 视图是控制器，而 Django 模板是视图。 很不幸，这是对 MVC 不同诠释所引起的错误认识。 在 Django 对 MVC 的诠释中，视图用来描述要展现给用户的数据；不是数据 <em>如何</em>展现 ,而且展现 <em>哪些</em> 数据。 相比之下，Ruby on Rails 及一些同类框架提倡控制器负责决定向用户展现哪些数据，而视图则仅决定 <em>如何</em> 展现数据，而不是展现 <em>哪些</em> 数据。</p><p class="cn" id="cn34">两种诠释中没有哪个更加正确一些。 重要的是要理解底层概念。</p></div><div class="section" id="id3"><span id="cn35"></span><h2 class="cn" id="cn35">数据库配置</h2><p class="cn" id="cn36">记住这些理念之后，让我们来开始 Django 数据库层的探索。 首先，我们需要做些初始配置；我们需要告诉Django使用什么数据库以及如何连接数据库。</p><p class="cn" id="cn37">我们假定你已经完成了数据库服务器的安装和激活，并且已经在其中创建了数据库（例如，用 <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">DATABASE</span></tt> 语句）。 如果你使用SQLite，不需要这步安装，因为SQLite使用文件系统上的独立文件来存储数据。</p><p class="cn" id="cn38">象前面章节提到的 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 一样，数据库配置也是在Django的配置文件里，缺省 是 <tt class="docutils literal"><span class="pre">settings.py</span></tt> 。 打开这个文件并查找数据库配置：</p><pre class="cn literal-block" id="cn40">DATABASE_ENGINE = ''DATABASE_NAME = ''DATABASE_USER = ''DATABASE_PASSWORD = ''DATABASE_HOST = ''DATABASE_PORT = ''</pre><p class="cn" id="cn41">配置纲要如下。</p><blockquote><p class="cn" id="cn42"><tt class="docutils literal"><span class="pre">DATABASE_ENGINE</span></tt> 告诉Django使用哪个数据库引擎。 如果你在 Django 中使用数据库， <tt class="docutils literal"><span class="pre">DATABASE_ENGINE</span></tt> 必须是 Table 5-1 中所列出的值。</p><table class="cn docutils" id="cn43"><caption>表 5-1.  数据库引擎设置</caption><colgroup><col width="28%" /><col width="14%" /><col width="58%" /></colgroup><thead valign="bottom"><tr><th class="head">设置</th><th class="head">数据库</th><th class="head">所需适配器</th></tr></thead><tbody valign="top"><tr><td>`` postgresql``</td><td>PostgreSQL</td><td><tt class="docutils literal"><span class="pre">psycopg</span></tt> 1.x版，<a class="reference external" href="http://www.djangoproject.com/r/python-pgsql/1/">http://www.djangoproject.com/r/python-pgsql/1/</a>。</td></tr><tr><td><tt class="docutils literal"><span class="pre">postgresql_psycopg2</span></tt></td><td>PostgreSQL</td><td><tt class="docutils literal"><span class="pre">psycopg</span></tt> 2.x版，<a class="reference external" href="http://www.djangoproject.com/r/python-pgsql/">http://www.djangoproject.com/r/python-pgsql/</a>。</td></tr><tr><td><tt class="docutils literal"><span class="pre">mysql</span></tt></td><td>MySQL</td><td><tt class="docutils literal"><span class="pre">MySQLdb</span></tt> ,<a class="reference external" href="http://www.djangoproject.com/r/python-mysql/">http://www.djangoproject.com/r/python-mysql/</a>.</td></tr><tr><td><tt class="docutils literal"><span class="pre">sqlite3</span></tt></td><td>SQLite</td><td>如果使用Python 2.5+则不需要适配器。 否则就使用 <tt class="docutils literal"><span class="pre">pysqlite</span></tt> ，<a class="reference external" href="http://www.djangoproject.com/r/python-sqlite/">http://www.djangoproject.com/r/python-sqlite/</a>。</td></tr><tr><td><tt class="docutils literal"><span class="pre">oracle</span></tt></td><td>Oracle</td><td><tt class="docutils literal"><span class="pre">cx_Oracle</span></tt> ,<a class="reference external" href="http://www.djangoproject.com/r/python-oracle/">http://www.djangoproject.com/r/python-oracle/</a>.</td></tr></tbody></table><p class="cn" id="cn45">要注意的是无论选择使用哪个数据库服务器，都必须下载和安装对应的数据库适配器。 访问表 5-1 中“所需适配器”一栏中的链接，可通过互联网免费获取这些适配器。 如果你使用Linux，你的发布包管理系统会提供合适的包。 比如说查找`` python-postgresql`` 或者`` python-psycopg`` 的软件包。</p><p class="cn" id="cn46">配置示例：</p></blockquote><pre class="cn literal-block" id="cn48">DATABASE_ENGINE = 'postgresql_psycopg2'</pre><blockquote><p class="cn" id="cn49"><tt class="docutils literal"><span class="pre">DATABASE_NAME</span></tt> 将数据库名称告知 Django 。 例如：</p></blockquote><pre class="cn literal-block" id="cn51">DATABASE_NAME = 'mydb'</pre><blockquote><p class="cn" id="cn52">如果使用 SQLite，请对数据库文件指定完整的文件系统路径。例如：</p></blockquote><pre class="cn literal-block" id="cn54">DATABASE_NAME = '/home/django/mydata.db'</pre><blockquote><p class="cn" id="cn55">在这个例子中，我们将SQLite数据库放在/home/django目录下，你可以任意选用最合适你的目录。</p><p class="cn" id="cn56"><tt class="docutils literal"><span class="pre">DATABASE_USER</span></tt> 告诉 Django 用哪个用户连接数据库。 例如： 如果用SQLite，空白即可。</p><p class="cn" id="cn57"><tt class="docutils literal"><span class="pre">DATABASE_PASSWORD</span></tt> 告诉Django连接用户的密码。 SQLite 用空密码即可。</p><p class="cn" id="cn58"><tt class="docutils literal"><span class="pre">DATABASE_HOST</span></tt> 告诉 Django 连接哪一台主机的数据库服务器。 如果数据库与 Django 安装于同一台计算机（即本机），可将此项保留空白。如果你使用SQLite，此项留空。</p><p class="cn" id="cn59">此处的 MySQL 是一个特例。 如果使用的是 MySQL 且该项设置值由斜杠（ <tt class="docutils literal"><span class="pre">'/'</span></tt> ）开头，MySQL 将通过 Unix socket 来连接指定的套接字，例如：</p></blockquote><pre class="cn literal-block" id="cn61">DATABASE_HOST = '/var/run/mysql'</pre><p class="cn" id="cn62">一旦在输入了那些设置并保存之后应当测试一下你的配置。 我们可以在`` mysite`` 项目目录下执行上章所提到的`` python manage.py shell`` 来进行测试。 （我们上一章提到过在，`` manager.py shell`` 命令是以正确Django配置启用Python交互解释器的一种方法。 这个方法在这里是很有必要的，因为Django需要知道加载哪个配置文件来获取数据库连接信息。）</p><p class="cn" id="cn63">输入下面这些命令来测试你的数据库配置：</p><pre class="cn literal-block" id="cn65">&gt;&gt;&gt; from django.db import connection&gt;&gt;&gt; cursor = connection.cursor()</pre><p class="cn" id="cn66">如果没有显示什么错误信息，那么你的数据库配置是正确的。 否则，你就得 查看错误信息来纠正错误。 表 5-2 是一些常见错误。</p><table class="cn docutils" id="cn67"><caption>表 5-2. 数据库配置错误信息</caption><colgroup><col width="22%" /><col width="78%" /></colgroup><thead valign="bottom"><tr><th class="head">错误信息</th><th class="head">解决方法</th></tr></thead><tbody valign="top"><tr><td>You haven&#8217;t set theDATABASE_ENGINEsetting yet.</td><td>不要以空字符串配置`` DATABASE_ENGINE`` 的值。表格 5-1 列出可用的值。</td></tr><tr><td>Environment variableDJANGO_SETTINGS_MODULEis undefined.</td><td>使用`` python manager.py shell`` 命令启动交互解释器，不要以`` python`` 命令直接启动交互解释器。</td></tr><tr><td>Error loading _____module: No modulenamed _____.</td><td>未安装合适的数据库适配器 (例如, <tt class="docutils literal"><span class="pre">psycopg</span></tt> 或 <tt class="docutils literal"><span class="pre">MySQLdb</span></tt> )。Django并不自带适配器，所以你得自己下载安装。</td></tr><tr><td>_____ isn&#8217;t anavailable databasebackend.</td><td>把<tt class="docutils literal"><span class="pre">DATABASE_ENGINE</span></tt> 配置成前面提到的合法的数据库引擎。 也许是拼写错误？</td></tr><tr><td>database _____ doesnot exist</td><td>设置`` DATABASE_NAME`` 指向存在的数据库，或者先在数据库客户端中执行合适的`` CREATE DATABASE`` 语句创建数据库。</td></tr><tr><td>role _____ does notexist</td><td>设置`` DATABASE_USER`` 指向存在的用户，或者先在数据库客户端中执创建用户。</td></tr><tr><td>could not connect toserver</td><td>查看DATABASE_HOST和DATABASE_PORT是否已正确配置，并确认数据库服务器是否已正常运行。</td></tr></tbody></table></div><div class="section" id="id4"><span id="cn68"></span><h2 class="cn" id="cn68">第一个应用程序</h2><p class="cn" id="cn69">你现在已经确认数据库连接正常工作了，让我们来创建一个 <em>Django app</em>-一个包含模型，视图和Django代码，并且形式为独立Python包的完整Django应用。</p><p class="cn" id="cn70">在这里要先解释一些术语，初学者可能会混淆它们。 在第二章我们已经创建了 <em>project</em> , 那么 <em>project</em> 和 <em>app</em> 之间到底有什么不同呢？它们的区别就是一个是配置另一个是 代码：</p><blockquote><p class="cn" id="cn71">一个project包含很多个Django app以及对它们的配置。</p><p class="cn" id="cn72">技术上，project的作用是提供配置文件，比方说哪里定义数据库连接信息, 安装的app列表， <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> ，等等。</p><p class="cn" id="cn73">一个app是一套Django功能的集合，通常包括模型和视图，按Python的包结构的方式存在。</p><p class="cn" id="cn74">例如，Django本身内建有一些app，例如注释系统和自动管理界面。 app的一个关键点是它们是很容易移植到其他project和被多个project复用。</p></blockquote><p class="cn" id="cn75">对于如何架构Django代码并没有快速成套的规则。 如果你只是建造一个简单的Web站点，那么可能你只需要一个app就可以了； 但如果是一个包含许多不相关的模块的复杂的网站，例如电子商务和社区之类的站点，那么你可能需要把这些模块划分成不同的app，以便以后复用。</p><p class="cn" id="cn76">不错，你可以不用创建app，这一点应经被我们之前编写的视图函数的例子证明了 。 在那些例子中，我们只是简单的创建了一个称为<tt class="docutils literal"><span class="pre">views.py</span></tt>的文件，编写了一些函数并在URLconf中设置了各个函数的映射。 这些情况都不需要使用apps。</p><p class="cn" id="cn77">但是，系统对app有一个约定： 如果你使用了Django的数据库层（模型），你 必须创建一个Django app。 模型必须存放在apps中。 因此，为了开始建造 我们的模型，我们必须创建一个新的app。</p><p class="cn" id="cn78">在`` mysite`` 项目文件下输入下面的命令来创建`` books``  app：</p><pre class="cn literal-block" id="cn80">python manage.py startapp books</pre><p class="cn" id="cn81">这个命令并没有输出什么，它只在 <tt class="docutils literal"><span class="pre">mysite</span></tt> 的目录里创建了一个 <tt class="docutils literal"><span class="pre">books</span></tt> 目录。 让我们来看看这个目录的内容：</p><pre class="cn literal-block" id="cn83">books/__init__.pymodels.pytests.pyviews.py</pre><p class="cn" id="cn84">这个目录包含了这个app的模型和视图。</p><p class="cn" id="cn85">使用你最喜欢的文本编辑器查看一下 <tt class="docutils literal"><span class="pre">models.py</span></tt> 和 <tt class="docutils literal"><span class="pre">views.py</span></tt> 文件的内容。 它们都是空的，除了 <tt class="docutils literal"><span class="pre">models.py</span></tt> 里有一个 import。这就是你Django app的基础。</p></div><div class="section" id="python"><span id="cn86"></span><h2 class="cn" id="cn86">在Python代码里定义模型</h2><p class="cn" id="cn87">我们早些时候谈到。MTV里的M代表模型。 Django模型是用Python代码形式表述的数据在数据库中的定义。 对数据层来说它等同于 CREATE TABLE 语句，只不过执行的是Python代码而不是 SQL，而且还包含了比数据库字段定义更多的含义。 Django用模型在后台执行SQL代码并把结果用Python的数据结构来描述。Django也使用模型来呈现SQL无法处理的高级概念。</p><p class="cn" id="cn88">如果你对数据库很熟悉，你可能马上就会想到，用Python <em>和</em> SQL来定义数据模型是不是有点多余？ Django这样做是有下面几个原因的：</p><blockquote><p class="cn" id="cn89">自省（运行时自动识别数据库）会导致过载和有数据完整性问题。 为了提供方便的数据访问API， Django需要以 <em>某种方式</em> 知道数据库层内部信息，有两种实现方式。第一种方式是用Python明确地定义数据模型，第二种方式是通过自省来自动侦测识别数据模型。</p><p class="cn" id="cn90">第二种方式看起来更清晰，因为数据表信息只存放在一个地方-数据库里，但是会带来一些问题。 首先，运行时扫描数据库会带来严重的系统过载。 如果每个请求都要扫描数据库的表结构，或者即便是 服务启动时做一次都是会带来不能接受的系统过载。（有人认为这个程度的系统过载是可以接受的，而Django开发者的目标是尽可能地降低框架的系统过载）。第二，某些数据库，尤其是老版本的MySQL,并未完整存储那些精确的自省元数据。</p><p class="cn" id="cn91">编写Python代码是非常有趣的，保持用Python的方式思考会避免你的大脑在不同领域来回切换。 尽可能的保持在单一的编程环境/思想状态下可以帮助你提高生产率。 不得不去重复写SQL，再写Python代码，再写SQL，&#8230;，会让你头都要裂了。</p><p class="cn" id="cn92">把数据模型用代码的方式表述来让你可以容易对它们进行版本控制。 这样，你可以很容易了解数据层 的变动情况。</p><p class="cn" id="cn93">SQL只能描述特定类型的数据字段。 例如，大多数数据库都没有专用的字段类型来描述Email地址、URL。 而用Django的模型可以做到这一点。 好处就是高级的数据类型带来更高的效率和更好的代码复用。</p><p class="cn" id="cn94">SQL还有在不同数据库平台的兼容性问题。 发布Web应用的时候，使用Python模块描述数据库结构信息可以避免为MySQL, PostgreSQL, and SQLite编写不同的<tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE</span></tt>。</p></blockquote><p class="cn" id="cn95">当然，这个方法也有一个缺点，就是Python代码和数据库表的同步问题。 如果你修改了一个Django模型， 你要自己来修改数据库来保证和模型同步。 我们将在稍后讲解解决这个问题的几种策略。</p><p class="cn" id="cn96">最后,我们要提醒你Django提供了实用工具来从现有的数据库表中自动扫描生成模型。 这对已有的数据库来说是非常快捷有用的。 我们将在第18章中对此进行讨论。</p></div><div class="section" id="id5"><span id="cn97"></span><h2 class="cn" id="cn97">第一个模型</h2><p class="cn" id="cn98">在本章和后续章节里，我们把注意力放在一个基本的 书籍/作者/出版商 数据库结构上。 我们这样做是因为 这是一个众所周知的例子，很多SQL有关的书籍也常用这个举例。 你现在看的这本书也是由作者 创作再由出版商出版的哦！</p><p class="cn" id="cn99">我们来假定下面的这些概念、字段和关系：</p><ul class="simple"><li class="cn" id="cn100"><p class="first cn" id="cn100">一个作者有姓，有名及email地址。</p></li></ul><ul class="simple"><li class="cn" id="cn101"><p class="first cn" id="cn101">出版商有名称，地址，所在城市、省，国家，网站。</p></li></ul><ul class="simple"><li class="cn" id="cn102"><p class="first cn" id="cn102">书籍有书名和出版日期。 它有一个或多个作者（和作者是多对多的关联关系[many-to-many]）， 只有一个出版商（和出版商是一对多的关联关系[one-to-many]，也被称作外键[foreign key]）</p></li></ul><p class="cn" id="cn103">第一步是用Python代码来描述它们。 打开由`` startapp`` 命令创建的<tt class="docutils literal"><span class="pre">models.py</span></tt> 并输入下面的内容：</p><pre class="cn literal-block" id="cn105">from django.db import modelsclass Publisher(models.Model):name = models.CharField(max_length=30)address = models.CharField(max_length=50)city = models.CharField(max_length=60)state_province = models.CharField(max_length=30)country = models.CharField(max_length=50)website = models.URLField()class Author(models.Model):first_name = models.CharField(max_length=30)last_name = models.CharField(max_length=40)email = models.EmailField()class Book(models.Model):title = models.CharField(max_length=100)authors = models.ManyToManyField(Author)publisher = models.ForeignKey(Publisher)publication_date = models.DateField()</pre><p class="cn" id="cn106">让我们来快速讲解一下这些代码的含义。 首先要注意的事是每个数据模型都是 <tt class="docutils literal"><span class="pre">django.db.models.Model</span></tt> 的子类。它的父类 Model 包含了所有必要的和数据库交互的方法，并提供了一个简洁漂亮的定义数据库字段的语法。 信不信由你，这些就是我们需要编写的通过Django存取基本数据的所有代码。</p><p class="cn" id="cn107">每个模型相当于单个数据库表，每个属性也是这个表中的一个字段。 属性名就是字段名，它的类型（例如 <tt class="docutils literal"><span class="pre">CharField</span></tt> ）相当于数据库的字段类型 （例如 <tt class="docutils literal"><span class="pre">varchar</span></tt> ）。例如， <tt class="docutils literal"><span class="pre">Publisher</span></tt> 模块等同于下面这张表（用PostgreSQL的 <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE</span></tt> 语法描述）：</p><pre class="cn literal-block" id="cn109">CREATE TABLE &quot;books_publisher&quot; (&quot;id&quot; serial NOT NULL PRIMARY KEY,&quot;name&quot; varchar(30) NOT NULL,&quot;address&quot; varchar(50) NOT NULL,&quot;city&quot; varchar(60) NOT NULL,&quot;state_province&quot; varchar(30) NOT NULL,&quot;country&quot; varchar(50) NOT NULL,&quot;website&quot; varchar(200) NOT NULL);</pre><p class="cn" id="cn110">事实上，正如过一会儿我们所要展示的，Django 可以自动生成这些 <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE</span></tt> 语句。</p><p class="cn" id="cn111">“每个数据库表对应一个类”这条规则的例外情况是多对多关系。 在我们的范例模型中， <tt class="docutils literal"><span class="pre">Book</span></tt> 有一个 <tt class="docutils literal"><span class="pre">多对多字段</span></tt> 叫做 <tt class="docutils literal"><span class="pre">authors</span></tt> 。 该字段表明一本书籍有一个或多个作者，但 <tt class="docutils literal"><span class="pre">Book</span></tt> 数据库表却并没有 <tt class="docutils literal"><span class="pre">authors</span></tt> 字段。相反，Django创建了一个额外的表（多对多连接表）来处理书籍和作者之间的映射关系。</p><p class="cn" id="cn112">请查看附录 B 了解所有的字段类型和模型语法选项。</p><p class="cn" id="cn113">最后需要注意的是，我们并没有显式地为这些模型定义任何主键。 除非你单独指明，否则Django会自动为每个模型生成一个自增长的整数主键字段每个Django模型都要求有单独的主键。<tt class="docutils literal"><span class="pre">id</span></tt></p></div><div class="section" id="id6"><span id="cn114"></span><h2 class="cn" id="cn114">模型安装</h2><p class="cn" id="cn115">完成这些代码之后，现在让我们来在数据库中创建这些表。 要完成该项工作，第一步是在 Django 项目中 <em>激活</em> 这些模型。 将 <tt class="docutils literal"><span class="pre">books</span></tt> app 添加到配置文件的已安装应用列表中即可完成此步骤。</p><p class="cn" id="cn116">再次编辑 <tt class="docutils literal"><span class="pre">settings.py</span></tt> 文件， 找到 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置。 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 告诉 Django 项目哪些 app 处于激活状态。 缺省情况下如下所示：</p><pre class="cn literal-block" id="cn118">INSTALLED_APPS = ('django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.sites',)</pre><p class="cn" id="cn119">把这四个设置前面加#临时注释起来。 （这四个app是经常使用到的，我们将在后续章节里讨论如何使用它们）。同时，注释掉MIDDLEWARE_CLASSES的默认设置条目，因为这些条目是依赖于刚才我们刚在INSTALLED_APPS注释掉的apps。然后，添加`` &#8216;mysite.books&#8217;`` 到`` INSTALLED_APPS`` 的末尾，此时设置的内容看起来应该是这样的：</p><pre class="cn literal-block" id="cn121">MIDDLEWARE_CLASSES = (# 'django.middleware.common.CommonMiddleware',# 'django.contrib.sessions.middleware.SessionMiddleware',# 'django.contrib.auth.middleware.AuthenticationMiddleware',)INSTALLED_APPS = (# 'django.contrib.auth',# 'django.contrib.contenttypes',# 'django.contrib.sessions',# 'django.contrib.sites','mysite.books',)</pre><p class="cn" id="cn122">(就像我们在上一章设置TEMPLATE_DIRS所提到的逗号，同样在INSTALLED_APPS的末尾也需添加一个逗号，因为这是个单元素的元组。 另外，本书的作者喜欢在 <em>每一个</em> tuple元素后面加一个逗号，不管它是不是 只有一个元素。 这是为了避免忘了加逗号，而且也没什么坏处。)</p><p class="cn" id="cn123"><tt class="docutils literal"><span class="pre">'mysite.books'</span></tt>指示我们正在编写的<tt class="docutils literal"><span class="pre">books</span></tt> app。 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中的每个app都使用 Python的路径描述，包的路径，用小数点“.”间隔。</p><p class="cn" id="cn124">现在我们可以创建数据库表了。 首先，用下面的命令验证模型的有效性：</p><pre class="cn literal-block" id="cn126">python manage.py validate</pre><p class="cn" id="cn127"><tt class="docutils literal"><span class="pre">validate</span></tt> 命令检查你的模型的语法和逻辑是否正确。 如果一切正常，你会看到 <tt class="docutils literal"><span class="pre">0</span> <span class="pre">errors</span> <span class="pre">found</span></tt> 消息。如果出错，请检查你输入的模型代码。 错误输出会给出非常有用的错误信息来帮助你修正你的模型。</p><p class="cn" id="cn128">一旦你觉得你的模型可能有问题，运行 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">validate</span></tt> 。 它可以帮助你捕获一些常见的模型定义错误。</p><p class="cn" id="cn129">模型确认没问题了，运行下面的命令来生成 <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE</span></tt> 语句（如果你使用的是Unix，那么可以启用语法高亮）：</p><pre class="cn literal-block" id="cn131">python manage.py sqlall books</pre><p class="cn" id="cn132">在这个命令行中， <tt class="docutils literal"><span class="pre">books</span></tt> 是app的名称。 和你运行 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">startapp</span></tt> 中的一样。执行之后，输出如下：</p><pre class="cn literal-block" id="cn134">BEGIN;CREATE TABLE &quot;books_publisher&quot; (&quot;id&quot; serial NOT NULL PRIMARY KEY,&quot;name&quot; varchar(30) NOT NULL,&quot;address&quot; varchar(50) NOT NULL,&quot;city&quot; varchar(60) NOT NULL,&quot;state_province&quot; varchar(30) NOT NULL,&quot;country&quot; varchar(50) NOT NULL,&quot;website&quot; varchar(200) NOT NULL);CREATE TABLE &quot;books_author&quot; (&quot;id&quot; serial NOT NULL PRIMARY KEY,&quot;first_name&quot; varchar(30) NOT NULL,&quot;last_name&quot; varchar(40) NOT NULL,&quot;email&quot; varchar(75) NOT NULL);CREATE TABLE &quot;books_book&quot; (&quot;id&quot; serial NOT NULL PRIMARY KEY,&quot;title&quot; varchar(100) NOT NULL,&quot;publisher_id&quot; integer NOT NULL REFERENCES &quot;books_publisher&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED,&quot;publication_date&quot; date NOT NULL);CREATE TABLE &quot;books_book_authors&quot; (&quot;id&quot; serial NOT NULL PRIMARY KEY,&quot;book_id&quot; integer NOT NULL REFERENCES &quot;books_book&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED,&quot;author_id&quot; integer NOT NULL REFERENCES &quot;books_author&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED,UNIQUE (&quot;book_id&quot;, &quot;author_id&quot;));CREATE INDEX &quot;books_book_publisher_id&quot; ON &quot;books_book&quot; (&quot;publisher_id&quot;);COMMIT;</pre><p class="cn" id="cn135">注意：</p><ul class="simple"><li class="cn" id="cn136"><p class="first cn" id="cn136">自动生成的表名是app名称（ <tt class="docutils literal"><span class="pre">books</span></tt> ）和模型的小写名称 （ <tt class="docutils literal"><span class="pre">publisher</span></tt> , <tt class="docutils literal"><span class="pre">book</span></tt> , <tt class="docutils literal"><span class="pre">author</span></tt> )的组合。你可以参考附录B重写这个规则。</p></li></ul><ul class="simple"><li class="cn" id="cn137"><p class="first cn" id="cn137">我们前面已经提到，Django为每个表格自动添加加了一个 <tt class="docutils literal"><span class="pre">id</span></tt> 主键，你可以重新设置它。</p></li></ul><ul class="simple"><li class="cn" id="cn138"><p class="first cn" id="cn138">按约定，Django添加 <tt class="docutils literal"><span class="pre">&quot;_id&quot;</span></tt> 后缀到外键字段名。 你猜对了，这个同样是可以自定义的。</p></li></ul><ul class="simple"><li class="cn" id="cn139"><p class="first cn" id="cn139">外键是用 <tt class="docutils literal"><span class="pre">REFERENCES</span></tt> 语句明确定义的。</p></li></ul><ul class="simple"><li class="cn" id="cn140"><p class="first cn" id="cn140">这些 <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE</span></tt> 语句会根据你的数据库而作调整，这样象数据库特定的一些字段例如：（MySQL），<tt class="docutils literal"><span class="pre">auto_increment</span></tt>（PostgreSQL）,<tt class="docutils literal"><span class="pre">serial</span></tt>（SQLite），都会自动生成。<tt class="docutils literal"><span class="pre">integer</span> <span class="pre">primary</span> <span class="pre">key</span></tt> 同样的，字段名称也是自动处理（例如单引号还好是双引号）。 例子中的输出是基于PostgreSQL语法的。</p></li></ul><p class="cn" id="cn141"><tt class="docutils literal"><span class="pre">sqlall</span></tt> 命令并没有在数据库中真正创建数据表，只是把SQL语句段打印出来，这样你可以看到Django究竟会做些什么。 如果你想这么做的话，你可以把那些SQL语句复制到你的数据库客户端执行，或者通过Unix管道直接进行操作（例如，`` python manager.py sqlall books | psql mydb`` ）。不过，Django提供了一种更为简易的提交SQL语句至数据库的方法： `` syncdb`` 命令</p><pre class="cn literal-block" id="cn143">python manage.py syncdb</pre><p class="cn" id="cn144">执行这个命令后，将看到类似以下的内容：</p><pre class="cn literal-block" id="cn146">Creating table books_publisherCreating table books_authorCreating table books_bookInstalling index for books.Book model</pre><p class="cn" id="cn147"><tt class="docutils literal"><span class="pre">syncdb</span></tt> 命令是同步你的模型到数据库的一个简单方法。 它会根据 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 里设置的app来检查数据库， 如果表不存在，它就会创建它。 需要注意的是， <tt class="docutils literal"><span class="pre">syncdb</span></tt> 并 <em>不能</em>将模型的修改或删除同步到数据库；如果你修改或删除了一个模型，并想把它提交到数据库，<tt class="docutils literal"><span class="pre">syncdb</span></tt>并不会做出任何处理。 （更多内容请查看本章最后的“修改数据库的架构”一段。）</p><p class="cn" id="cn148">如果你再次运行 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">syncdb</span></tt> ，什么也没发生，因为你没有添加新的模型或者 添加新的app。因此，运行<tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">syncdb</span></tt>总是安全的，因为它不会重复执行SQL语句。</p><p class="cn" id="cn149">如果你有兴趣，花点时间用你的SQL客户端登录进数据库服务器看看刚才Django创建的数据表。 你可以手动启动命令行客户端（例如，执行PostgreSQL的`` psql`` 命令），也可以执行 `` python manage.py dbshell``  ，这个命令将依据`` DATABASE_SERVER`` 的里设置自动检测使用哪种命令行客户端。 常言说，后来者居上。</p></div><div class="section" id="id7"><span id="cn150"></span><h2 class="cn" id="cn150">基本数据访问</h2><p class="cn" id="cn151">一旦你创建了模型，Django自动为这些模型提供了高级的Python API。 运行 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">shell</span></tt> 并输入下面的内容试试看：</p><pre class="cn literal-block" id="cn153">&gt;&gt;&gt; from books.models import Publisher&gt;&gt;&gt; p1 = Publisher(name='Apress', address='2855 Telegraph Avenue',...     city='Berkeley', state_province='CA', country='U.S.A.',...     website='http://www.apress.com/')&gt;&gt;&gt; p1.save()&gt;&gt;&gt; p2 = Publisher(name=&quot;O'Reilly&quot;, address='10 Fawcett St.',...     city='Cambridge', state_province='MA', country='U.S.A.',...     website='http://www.oreilly.com/')&gt;&gt;&gt; p2.save()&gt;&gt;&gt; publisher_list = Publisher.objects.all()&gt;&gt;&gt; publisher_list[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]</pre><p class="cn" id="cn154">这短短几行代码干了不少的事。 这里简单的说一下：</p><ul class="simple"><li class="cn" id="cn155"><p class="first cn" id="cn155">首先，导入Publisher模型类， 通过这个类我们可以与包含 出版社 的数据表进行交互。</p></li></ul><ul class="simple"><li class="cn" id="cn156"><p class="first cn" id="cn156">接着，创建一个`` Publisher`` 类的实例并设置了字段`` name, address`` 等的值。</p></li></ul><ul class="simple"><li class="cn" id="cn157"><p class="first cn" id="cn157">调用该对象的 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法，将对象保存到数据库中。 Django 会在后台执行一条 <tt class="docutils literal"><span class="pre">INSERT</span></tt> 语句。</p></li></ul><ul class="simple"><li class="cn" id="cn158"><p class="first cn" id="cn158">最后，使用`` Publisher.objects`` 属性从数据库取出出版商的信息，这个属性可以认为是包含出版商的记录集。 这个属性有许多方法， 这里先介绍调用`` Publisher.objects.all()`` 方法获取数据库中`` Publisher`` 类的所有对象。这个操作的幕后，Django执行了一条SQL `` SELECT`` 语句。</p></li></ul><p class="cn" id="cn159">这里有一个值得注意的地方，在这个例子可能并未清晰地展示。 当你使用Django modle API创建对象时Django并未将对象保存至数据库内，除非你调用`` save()`` 方法：</p><pre class="cn literal-block" id="cn161">p1 = Publisher(...)# At this point, p1 is not saved to the database yet!p1.save()# Now it is.</pre><p class="cn" id="cn162">如果需要一步完成对象的创建与存储至数据库，就使用`` objects.create()`` 方法。 下面的例子与之前的例子等价：</p><pre class="cn literal-block" id="cn164">&gt;&gt;&gt; p1 = Publisher.objects.create(name='Apress',...     address='2855 Telegraph Avenue',...     city='Berkeley', state_province='CA', country='U.S.A.',...     website='http://www.apress.com/')&gt;&gt;&gt; p2 = Publisher.objects.create(name=&quot;O'Reilly&quot;,...     address='10 Fawcett St.', city='Cambridge',...     state_province='MA', country='U.S.A.',...     website='http://www.oreilly.com/')&gt;&gt;&gt; publisher_list = Publisher.objects.all()&gt;&gt;&gt; publisher_list</pre><p class="cn" id="cn165">当然，你肯定想执行更多的Django数据库API试试看，不过，还是让我们先解决一点烦人的小问题。</p></div><div class="section" id="id8"><span id="cn166"></span><h2 class="cn" id="cn166">添加模块的字符串表现</h2><p class="cn" id="cn167">当我们打印整个publisher列表时，我们没有得到想要的有用信息，无法把<a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">``</span></a>对象区分开来：</p><div class="system-message" id="id9"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 872); <em><a href="#id10">backlink</a></em></p><p class="cn" id="cn167">Inline literal start-string without end-string.</p></div><div class="system-message" id="id11"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 872); <em><a href="#id12">backlink</a></em></p><p class="cn" id="cn167">Inline literal start-string without end-string.</p></div><pre class="cn literal-block" id="cn169">[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]</pre><p class="cn" id="cn170">我们可以简单解决这个问题，只需要为<tt class="docutils literal"><span class="pre">Publisher</span></tt> 对象添加一个方法 <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> 。 <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> 方法告诉Python如何将对象以unicode的方式显示出来。 为以上三个模型添加<tt class="docutils literal"><span class="pre">__unicode__()</span></tt>方法后，就可以看到效果了：</p><pre class="cn literal-block" id="cn172">from django.db import modelsclass Publisher(models.Model):name = models.CharField(max_length=30)address = models.CharField(max_length=50)city = models.CharField(max_length=60)state_province = models.CharField(max_length=30)country = models.CharField(max_length=50)website = models.URLField()**def __unicode__(self):****return self.name**class Author(models.Model):first_name = models.CharField(max_length=30)last_name = models.CharField(max_length=40)email = models.EmailField()**def __unicode__(self):****return u'%s %s' % (self.first_name, self.last_name)**class Book(models.Model):title = models.CharField(max_length=100)authors = models.ManyToManyField(Author)publisher = models.ForeignKey(Publisher)publication_date = models.DateField()**def __unicode__(self):****return self.title**</pre><p class="cn" id="cn173">就象你看到的一样， <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> 方法可以进行任何处理来返回对一个对象的字符串表示。 <tt class="docutils literal"><span class="pre">Publisher</span></tt>和<tt class="docutils literal"><span class="pre">Book</span></tt>对象的<tt class="docutils literal"><span class="pre">__unicode__()</span></tt>方法简单地返回各自的名称和标题，<tt class="docutils literal"><span class="pre">Author</span></tt>对象的<tt class="docutils literal"><span class="pre">__unicode__()</span></tt>方法则稍微复杂一些，它将<tt class="docutils literal"><span class="pre">first_name</span></tt>和<tt class="docutils literal"><span class="pre">last_name</span></tt>字段值以空格连接后再返回。</p><p class="cn" id="cn174">对__unicode__()的唯一要求就是它要返回一个unicode对象 如果`` __unicode__()`` 方法未返回一个Unicode对象，而返回比如说一个整型数字，那么Python将抛出一个`` TypeError`` 错误，并提示：&#8221;coercing to Unicode: need string or buffer, int found&#8221; 。</p><p class="cn" id="cn175">Unicode对象</p><p class="cn" id="cn176">什么是Unicode对象呢？</p><p class="cn" id="cn177">你可以认为unicode对象就是一个Python字符串，它可以处理上百万不同类别的字符——从古老版本的Latin字符到非Latin字符，再到曲折的引用和艰涩的符号。</p><p class="cn" id="cn178">普通的python字符串是经过<em>编码</em>的，意思就是它们使用了某种编码方式（如ASCII，ISO-8859-1或者UTF-8）来编码。 如果你把奇特的字符（其它任何超出标准128个如0-9和A-Z之类的ASCII字符）保存在一个普通的Python字符串里，你一定要跟踪你的字符串是用什么编码的，否则这些奇特的字符可能会在显示或者打印的时候出现乱码。 当你尝试要将用某种编码保存的数据结合到另外一种编码的数据中，或者你想要把它显示在已经假定了某种编码的程序中的时候，问题就会发生。 我们都已经见到过网页和邮件被???弄得乱七八糟。 ?????? 或者其它出现在奇怪位置的字符：这一般来说就是存在编码问题了。</p><p class="cn" id="cn179">但是Unicode对象并没有编码。它们使用Unicode，一个一致的，通用的字符编码集。 当你在Python中处理Unicode对象的时候，你可以直接将它们混合使用和互相匹配而不必去考虑编码细节。</p><p class="cn" id="cn180">Django 在其内部的各个方面都使用到了 Unicode 对象。 模型 对象中，检索匹配方面的操作使用的是 Unicode 对象，视图 函数之间的交互使用的是 Unicode 对象，模板的渲染也是用的 Unicode 对象。 通常，我们不必担心编码是否正确，后台会处理的很好。</p><p class="cn" id="cn181">注意，我们这里只是对Unicode对象进行非常浅显的概述，若要深入了解你可能需要查阅相关的资料。 这是一个很好的起点：http://www.joelonsoftware.com/articles/Unicode.html。</p><p class="cn" id="cn182">为了让我们的修改生效，先退出Python Shell，然后再次运行 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">shell</span></tt> 进入。（这是保证代码修改生效的最简单方法。）现在`` Publisher``对象列表容易理解多了。</p><pre class="cn literal-block" id="cn184">&gt;&gt;&gt; from books.models import Publisher&gt;&gt;&gt; publisher_list = Publisher.objects.all()&gt;&gt;&gt; publisher_list[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]</pre><p class="cn" id="cn185">请确保你的每一个模型里都包含 <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> 方法，这不只是为了交互时方便，也是因为 Django会在其他一些地方用 <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> 来显示对象。</p><p class="cn" id="cn186">最后， <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> 也是一个很好的例子来演示我们怎么添加 <em>行为</em> 到模型里。 Django的模型不只是为对象定义了数据库表的结构，还定义了对象的行为。 <tt class="docutils literal"><span class="pre">__unicode__()</span></tt> 就是一个例子来演示模型知道怎么显示它们自己。</p></div><div class="section" id="id13"><span id="cn187"></span><h2 class="cn" id="cn187">插入和更新数据</h2><p class="cn" id="cn188">你已经知道怎么做了： 先使用一些关键参数创建对象实例，如下：</p><pre class="cn literal-block" id="cn190">&gt;&gt;&gt; p = Publisher(name='Apress',...         address='2855 Telegraph Ave.',...         city='Berkeley',...         state_province='CA',...         country='U.S.A.',...         website='http://www.apress.com/')</pre><p class="cn" id="cn191">这个对象实例并 <em>没有</em> 对数据库做修改。 在调用`` save()`` 方法之前，记录并没有保存至数据库，像这样：</p><pre class="cn literal-block" id="cn193">&gt;&gt;&gt; p.save()</pre><p class="cn" id="cn194">在SQL里，这大致可以转换成这样：</p><pre class="cn literal-block" id="cn196">INSERT INTO books_publisher(name, address, city, state_province, country, website)VALUES('Apress', '2855 Telegraph Ave.', 'Berkeley', 'CA','U.S.A.', 'http://www.apress.com/');</pre><p class="cn" id="cn197">因为 <tt class="docutils literal"><span class="pre">Publisher</span></tt> 模型有一个自动增加的主键 <tt class="docutils literal"><span class="pre">id</span></tt> ，所以第一次调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 还多做了一件事： 计算这个主键的值并把它赋值给这个对象实例：</p><pre class="cn literal-block" id="cn199">&gt;&gt;&gt; p.id52    # this will differ based on your own data</pre><p class="cn" id="cn200">接下来再调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 将不会创建新的记录，而只是修改记录内容（也就是 执行 <tt class="docutils literal"><span class="pre">UPDATE</span></tt> SQL语句，而不是 <tt class="docutils literal"><span class="pre">INSERT</span></tt> 语句）：</p><pre class="cn literal-block" id="cn202">&gt;&gt;&gt; p.name = 'Apress Publishing'&gt;&gt;&gt; p.save()</pre><p class="cn" id="cn203">前面执行的 <tt class="docutils literal"><span class="pre">save()</span></tt> 相当于下面的SQL语句：</p><pre class="cn literal-block" id="cn205">UPDATE books_publisher SETname = 'Apress Publishing',address = '2855 Telegraph Ave.',city = 'Berkeley',state_province = 'CA',country = 'U.S.A.',website = 'http://www.apress.com'WHERE id = 52;</pre><p class="cn" id="cn206">注意，并不是只更新修改过的那个字段，所有的字段都会被更新。这个操作有可能引起竞态条件，这取决于你的应用程序。 请参阅后面的“更新多个对象”小节以了解如何实现这种轻量的修改（只修改对象的部分字段）。</p><pre class="cn literal-block" id="cn208">UPDATE books_publisher SETname = 'Apress Publishing'WHERE id=52;</pre></div><div class="section" id="id14"><span id="cn209"></span><h2 class="cn" id="cn209">选择对象</h2><p class="cn" id="cn210">当然，创建新的数据库，并更新之中的数据是必要的，但是，对于 Web 应用程序来说，更多的时候是在检索查询数据库。我们已经知道如何从一个给定的模型中取出所有记录：</p><pre class="cn literal-block" id="cn212">&gt;&gt;&gt; Publisher.objects.all()[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]</pre><p class="cn" id="cn213">这相当于这个SQL语句：</p><pre class="cn literal-block" id="cn215">SELECT id, name, address, city, state_province, country, websiteFROM books_publisher;</pre><p class="cn" id="cn216">注意</p><p class="cn" id="cn217">注意到Django在选择所有数据时并没有使用 <tt class="docutils literal"><span class="pre">SELECT*</span></tt> ，而是显式列出了所有字段。 设计的时候就是这样： <tt class="docutils literal"><span class="pre">SELECT*</span></tt> 会更慢，而且最重要的是列出所有字段遵循了Python 界的一个信条： 明言胜于暗示。</p><p class="cn" id="cn218">有关Python之禅(戒律) :-），在Python提示行输入 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">this</span></tt> 试试看。</p><p class="cn" id="cn219">让我们来仔细看看 <tt class="docutils literal"><span class="pre">Publisher.objects.all()</span></tt> 这行的每个部分：</p><blockquote><p class="cn" id="cn220">首先，我们有一个已定义的模型 <tt class="docutils literal"><span class="pre">Publisher</span></tt> 。没什么好奇怪的： 你想要查找数据， 你就用模型来获得数据。</p><p class="cn" id="cn221">然后，是<tt class="docutils literal"><span class="pre">objects</span></tt>属性。 它被称为管理器，我们将在第10章中详细讨论它。 目前，我们只需了解管理器管理着所有针对数据包含、还有最重要的数据查询的表格级操作。</p><p class="cn" id="cn222">所有的模型都自动拥有一个 <tt class="docutils literal"><span class="pre">objects</span></tt> 管理器；你可以在想要查找数据时使用它。</p><p class="cn" id="cn223">最后，还有 <tt class="docutils literal"><span class="pre">all()</span></tt> 方法。这个方法返回返回数据库中所有的记录。 尽管这个对象 看起来 象一个列表（list），它实际是一个 QuerySet 对象， 这个对象是数据库中一些记录的集合。 附录C将详细描述QuerySet。现在，我们就先当它是一个仿真列表对象好了。</p></blockquote><p class="cn" id="cn224">所有的数据库查找都遵循一个通用模式：</p><div class="section" id="id15"><span id="cn225"></span><h3 class="cn" id="cn225">数据过滤</h3><p class="cn" id="cn226">我们很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作。 在Django API中，我们可以使用`` filter()`` 方法对数据进行过滤：</p><pre class="cn literal-block" id="cn228">&gt;&gt;&gt; Publisher.objects.filter(name='Apress')[&lt;Publisher: Apress&gt;]</pre><p class="cn" id="cn229"><tt class="docutils literal"><span class="pre">filter()</span></tt> 根据关键字参数来转换成 <tt class="docutils literal"><span class="pre">WHERE</span></tt> SQL语句。前面这个例子 相当于这样：</p><pre class="cn literal-block" id="cn231">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherWHERE name = 'Apress';</pre><p class="cn" id="cn232">你可以传递多个参数到 <tt class="docutils literal"><span class="pre">filter()</span></tt> 来缩小选取范围：</p><pre class="cn literal-block" id="cn234">&gt;&gt;&gt; Publisher.objects.filter(country=&quot;U.S.A.&quot;, state_province=&quot;CA&quot;)[&lt;Publisher: Apress&gt;]</pre><p class="cn" id="cn235">多个参数会被转换成 <tt class="docutils literal"><span class="pre">AND</span></tt> SQL从句， 因此上面的代码可以转化成这样：</p><pre class="cn literal-block" id="cn237">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherWHERE country = 'U.S.A.'AND state_province = 'CA';</pre><p class="cn" id="cn238">注意，SQL缺省的 <tt class="docutils literal"><span class="pre">=</span></tt> 操作符是精确匹配的， 其他类型的查找也可以使用：</p><pre class="cn literal-block" id="cn240">&gt;&gt;&gt; Publisher.objects.filter(name__contains=&quot;press&quot;)[&lt;Publisher: Apress&gt;]</pre><p class="cn" id="cn241">在 <em>name</em> 和 <tt class="docutils literal"><span class="pre">contains</span></tt> 之间有双下划线。和Python一样，Django也使用双下划线来表明会进行一些魔术般的操作。这里，<tt class="docutils literal"><span class="pre">contains</span></tt>部分会被Django翻译成<tt class="docutils literal"><span class="pre">LIKE</span></tt>语句：</p><pre class="cn literal-block" id="cn243">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherWHERE name LIKE '%press%';</pre><p class="cn" id="cn244">其他的一些查找类型有：<tt class="docutils literal"><span class="pre">icontains</span></tt>(大小写无关的<tt class="docutils literal"><span class="pre">LIKE</span></tt>),<tt class="docutils literal"><span class="pre">startswith</span></tt>和<tt class="docutils literal"><span class="pre">endswith</span></tt>, 还有<tt class="docutils literal"><span class="pre">range</span></tt>(SQL<tt class="docutils literal"><span class="pre">BETWEEN</span></tt>查询）。 附录C详细描述了所有的查找类型。</p></div><div class="section" id="id16"><span id="cn245"></span><h3 class="cn" id="cn245">获取单个对象</h3><p class="cn" id="cn246">上面的例子中`` filter()`` 函数返回一个记录集，这个记录集是一个列表。相对列表来说，有些时候我们更需要获取单个的对象， `` get()`` 方法就是在此时使用的：</p><pre class="cn literal-block" id="cn248">&gt;&gt;&gt; Publisher.objects.get(name=&quot;Apress&quot;)&lt;Publisher: Apress&gt;</pre><p class="cn" id="cn249">这样，就返回了单个对象，而不是列表（更准确的说，QuerySet)。 所以，如果结果是多个对象，会导致抛出异常：</p><pre class="cn literal-block" id="cn251">&gt;&gt;&gt; Publisher.objects.get(country=&quot;U.S.A.&quot;)Traceback (most recent call last):...MultipleObjectsReturned: get() returned more than one Publisher --it returned 2! Lookup parameters were {'country': 'U.S.A.'}</pre><p class="cn" id="cn252">如果查询没有返回结果也会抛出异常：</p><pre class="cn literal-block" id="cn254">&gt;&gt;&gt; Publisher.objects.get(name=&quot;Penguin&quot;)Traceback (most recent call last):...DoesNotExist: Publisher matching query does not exist.</pre><p class="cn" id="cn255">这个 <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> 异常 是 Publisher 这个 model 类的一个属性，即 <tt class="docutils literal"><span class="pre">Publisher.DoesNotExist</span></tt>。在你的应用中，你可以捕获并处理这个异常，像这样：</p><pre class="cn literal-block" id="cn257">try:p = Publisher.objects.get(name='Apress')except Publisher.DoesNotExist:print &quot;Apress isn't in the database yet.&quot;else:print &quot;Apress is in the database.&quot;</pre></div><div class="section" id="id17"><span id="cn258"></span><h3 class="cn" id="cn258">数据排序</h3><p class="cn" id="cn259">在运行前面的例子中，你可能已经注意到返回的结果是无序的。 我们还没有告诉数据库 怎样对结果进行排序，所以我们返回的结果是无序的。</p><p class="cn" id="cn260">在你的 Django 应用中，你或许希望根据某字段的值对检索结果排序，比如说，按字母顺序。 那么，使用 <tt class="docutils literal"><span class="pre">order_by()</span></tt> 这个方法就可以搞定了。</p><pre class="cn literal-block" id="cn262">&gt;&gt;&gt; Publisher.objects.order_by(&quot;name&quot;)[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]</pre><p class="cn" id="cn263">跟以前的 <tt class="docutils literal"><span class="pre">all()</span></tt> 例子差不多，SQL语句里多了指定排序的部分：</p><pre class="cn literal-block" id="cn265">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherORDER BY name;</pre><p class="cn" id="cn266">我们可以对任意字段进行排序：</p><pre class="cn literal-block" id="cn268">&gt;&gt;&gt; Publisher.objects.order_by(&quot;address&quot;)[&lt;Publisher: O'Reilly&gt;, &lt;Publisher: Apress&gt;]&gt;&gt;&gt; Publisher.objects.order_by(&quot;state_province&quot;)[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]</pre><p class="cn" id="cn269">如果需要以多个字段为标准进行排序（第二个字段会在第一个字段的值相同的情况下被使用到），使用多个参数就可以了，如下：</p><pre class="cn literal-block" id="cn271">&gt;&gt;&gt; Publisher.objects.order_by(&quot;state_province&quot;, &quot;address&quot;)[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]</pre><p class="cn" id="cn272">我们还可以指定逆向排序，在前面加一个减号 <tt class="docutils literal"><span class="pre">-</span></tt> 前缀：</p><pre class="cn literal-block" id="cn274">&gt;&gt;&gt; Publisher.objects.order_by(&quot;-name&quot;)[&lt;Publisher: O'Reilly&gt;, &lt;Publisher: Apress&gt;]</pre><p class="cn" id="cn275">尽管很灵活，但是每次都要用 <tt class="docutils literal"><span class="pre">order_by()</span></tt> 显得有点啰嗦。 大多数时间你通常只会对某些 字段进行排序。 在这种情况下，Django让你可以指定模型的缺省排序方式：</p><pre class="cn literal-block" id="cn277">class Publisher(models.Model):name = models.CharField(max_length=30)address = models.CharField(max_length=50)city = models.CharField(max_length=60)state_province = models.CharField(max_length=30)country = models.CharField(max_length=50)website = models.URLField()def __unicode__(self):return self.name**class Meta:****ordering = ['name']**</pre><p class="cn" id="cn278">现在，让我们来接触一个新的概念。 <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Meta</span></tt>，内嵌于 <tt class="docutils literal"><span class="pre">Publisher</span></tt> 这个类的定义中（如果 <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Publisher</span></tt> 是顶格的，那么 <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Meta</span></tt> 在它之下要缩进4个空格－－按 Python 的传统 ）。你可以在任意一个 模型 类中使用 <tt class="docutils literal"><span class="pre">Meta</span></tt> 类，来设置一些与特定模型相关的选项。 在 附录B 中有 <tt class="docutils literal"><span class="pre">Meta</span></tt> 中所有可选项的完整参考，现在，我们关注 <tt class="docutils literal"><span class="pre">ordering</span></tt> 这个选项就够了。 如果你设置了这个选项，那么除非你检索时特意额外地使用了 <tt class="docutils literal"><span class="pre">order_by()</span></tt>，否则，当你使用 Django 的数据库 API 去检索时，<tt class="docutils literal"><span class="pre">Publisher</span></tt>对象的相关返回值默认地都会按 <tt class="docutils literal"><span class="pre">name</span></tt> 字段排序。</p></div><div class="section" id="id18"><span id="cn279"></span><h3 class="cn" id="cn279">连锁查询</h3><p class="cn" id="cn280">我们已经知道如何对数据进行过滤和排序。 当然，通常我们需要同时进行过滤和排序查询的操作。 因此，你可以简单地写成这种“链式”的形式：</p><pre class="cn literal-block" id="cn282">&gt;&gt;&gt; Publisher.objects.filter(country=&quot;U.S.A.&quot;).order_by(&quot;-name&quot;)[&lt;Publisher: O'Reilly&gt;, &lt;Publisher: Apress&gt;]</pre><p class="cn" id="cn283">你应该没猜错，转换成SQL查询就是 <tt class="docutils literal"><span class="pre">WHERE</span></tt> 和 <tt class="docutils literal"><span class="pre">ORDER</span> <span class="pre">BY</span></tt> 的组合：</p><pre class="cn literal-block" id="cn285">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherWHERE country = 'U.S.A'ORDER BY name DESC;</pre></div><div class="section" id="id19"><span id="cn286"></span><h3 class="cn" id="cn286">限制返回的数据</h3><p class="cn" id="cn287">另一个常用的需求就是取出固定数目的记录。 想象一下你有成千上万的出版商在你的数据库里， 但是你只想显示第一个。 你可以使用标准的Python列表裁剪语句：</p><pre class="cn literal-block" id="cn289">&gt;&gt;&gt; Publisher.objects.order_by('name')[0]&lt;Publisher: Apress&gt;</pre><p class="cn" id="cn290">这相当于：</p><pre class="cn literal-block" id="cn292">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherORDER BY nameLIMIT 1;</pre><p class="cn" id="cn293">类似的，你可以用Python的range-slicing语法来取出数据的特定子集：</p><pre class="cn literal-block" id="cn295">&gt;&gt;&gt; Publisher.objects.order_by('name')[0:2]</pre><p class="cn" id="cn296">这个例子返回两个对象，等同于以下的SQL语句：</p><pre class="cn literal-block" id="cn298">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherORDER BY nameOFFSET 0 LIMIT 2;</pre><p class="cn" id="cn299">注意，不支持Python的负索引(negative slicing)：</p><pre class="cn literal-block" id="cn301">&gt;&gt;&gt; Publisher.objects.order_by('name')[-1]Traceback (most recent call last):...AssertionError: Negative indexing is not supported.</pre><p class="cn" id="cn302">虽然不支持负索引，但是我们可以使用其他的方法。 比如，稍微修改 order_by() 语句来实现：</p><pre class="cn literal-block" id="cn304">&gt;&gt;&gt; Publisher.objects.order_by('-name')[0]</pre></div><div class="section" id="id20"><span id="cn305"></span><h3 class="cn" id="cn305">更新多个对象</h3><p class="cn" id="cn306">在“插入和更新数据”小节中，我们有提到模型的save()方法，这个方法会更新一行里的所有列。 而某些情况下，我们只需要更新行里的某几列。</p><p class="cn" id="cn307">例如说我们现在想要将Apress Publisher的名称由原来的&#8221;Apress&#8221;更改为&#8221;Apress Publishing&#8221;。若使用save()方法，如：</p><pre class="cn literal-block" id="cn309">&gt;&gt;&gt; p = Publisher.objects.get(name='Apress')&gt;&gt;&gt; p.name = 'Apress Publishing'&gt;&gt;&gt; p.save()</pre><p class="cn" id="cn310">这等同于如下SQL语句：</p><pre class="cn literal-block" id="cn312">SELECT id, name, address, city, state_province, country, websiteFROM books_publisherWHERE name = 'Apress';UPDATE books_publisher SETname = 'Apress Publishing',address = '2855 Telegraph Ave.',city = 'Berkeley',state_province = 'CA',country = 'U.S.A.',website = 'http://www.apress.com'WHERE id = 52;</pre><p class="cn" id="cn313">（注意在这里我们假设Apress的ID为52）</p><p class="cn" id="cn314">在这个例子里我们可以看到Django的save()方法更新了不仅仅是name列的值，还有更新了所有的列。 若name以外的列有可能会被其他的进程所改动的情况下，只更改name列显然是更加明智的。 更改某一指定的列，我们可以调用结果集（QuerySet）对象的update()方法： 示例如下：</p><pre class="cn literal-block" id="cn316">&gt;&gt;&gt; Publisher.objects.filter(id=52).update(name='Apress Publishing')</pre><p class="cn" id="cn317">与之等同的SQL语句变得更高效，并且不会引起竞态条件。</p><pre class="cn literal-block" id="cn319">UPDATE books_publisherSET name = 'Apress Publishing'WHERE id = 52;</pre><p class="cn" id="cn320">update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录。以下示例演示如何将所有Publisher的country字段值由&#8217;U.S.A&#8217;更改为&#8217;USA&#8217;：</p><pre class="cn literal-block" id="cn322">&gt;&gt;&gt; Publisher.objects.all().update(country='USA')2</pre><p class="cn" id="cn323">update()方法会返回一个整型数值，表示受影响的记录条数。 在上面的例子中，这个值是2。</p></div></div><div class="section" id="id21"><span id="cn324"></span><h2 class="cn" id="cn324">删除对象</h2><p class="cn" id="cn325">删除数据库中的对象只需调用该对象的delete()方法即可：</p><pre class="cn literal-block" id="cn327">&gt;&gt;&gt; p = Publisher.objects.get(name=&quot;O'Reilly&quot;)&gt;&gt;&gt; p.delete()&gt;&gt;&gt; Publisher.objects.all()[&lt;Publisher: Apress Publishing&gt;]</pre><p class="cn" id="cn328">同样我们可以在结果集上调用delete()方法同时删除多条记录。这一点与我们上一小节提到的update()方法相似：</p><pre class="cn literal-block" id="cn330">&gt;&gt;&gt; Publisher.objects.filter(country='USA').delete()&gt;&gt;&gt; Publisher.objects.all().delete()&gt;&gt;&gt; Publisher.objects.all()[]</pre><p class="cn" id="cn331">删除数据时要谨慎！ 为了预防误删除掉某一个表内的所有数据，Django要求在删除表内所有数据时显示使用all()。 比如，下面的操作将会出错：</p><pre class="cn literal-block" id="cn333">&gt;&gt;&gt; Publisher.objects.delete()Traceback (most recent call last):File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;AttributeError: 'Manager' object has no attribute 'delete'</pre><p class="cn" id="cn334">而一旦使用all()方法，所有数据将会被删除：</p><pre class="cn literal-block" id="cn336">&gt;&gt;&gt; Publisher.objects.all().delete()</pre><p class="cn" id="cn337">如果只需要删除部分的数据，就不需要调用all()方法。再看一下之前的例子：</p><pre class="cn literal-block" id="cn339">&gt;&gt;&gt; Publisher.objects.filter(country='USA').delete()</pre></div><div class="section" id="id22"><span id="cn340"></span><h2 class="cn" id="cn340">下一章</h2><p class="cn" id="cn341">通过本章的学习，你应该可以熟练地使用Django模型来编写一些简单的数据库应用程序。 在第十章我们将讨论Django数据库层的高级应用。</p><p class="cn" id="cn342">一旦你定义了你的模型，接下来就是要把数据导入数据库里了。 你可能已经有现成的数据了，请看第十八章以获得有关如何集成现有数据库的建议。也可能数据是用户提供的，第七章中还会教你怎么处理用户提交的数据。</p><p class="cn" id="cn343">有时候，你和你的团队成员也需要手工输入数据，这时候如果有一个基于Web的数据输入和管理的界面就会很有帮助。 下一章将介绍解决手工录入问题的方法——Django管理界面。</p><p class="cn" id="cn344">the GNU Free Document License Hosting graciously provided by</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter04.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter06.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>