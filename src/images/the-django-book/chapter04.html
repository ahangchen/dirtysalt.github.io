<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第四章：模版</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter03.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter05.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第四章 模板</h1><p class="cn" id="cn1">在前一章中，你可能已经注意到我们在例子视图中返回文本的方式有点特别。 也就是说，HTML被直接硬编码在 Python 代码之中。</p><pre class="cn literal-block" id="cn3">def current_datetime(request):now = datetime.datetime.now()html = &quot;&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;&quot; % nowreturn HttpResponse(html)</pre><p class="cn" id="cn4">尽管这种技术便于解释视图是如何工作的，但直接将HTML硬编码到你的视图里却并不是一个好主意。 让我们来看一下为什么：</p><ul class="simple"><li class="cn" id="cn5"><p class="first cn" id="cn5">对页面设计进行的任何改变都必须对 Python 代码进行相应的修改。 站点设计的修改往往比底层 Python 代码的修改要频繁得多，因此如果可以在不进行 Python 代码修改的情况下变更设计，那将会方便得多。</p></li></ul><ul class="simple"><li class="cn" id="cn6"><p class="first cn" id="cn6">Python 代码编写和 HTML 设计是两项不同的工作，大多数专业的网站开发环境都将他们分配给不同的人员（甚至不同部门）来完成。 设计者和HTML/CSS的编码人员不应该被要求去编辑Python的代码来完成他们的工作。</p></li></ul><ul class="simple"><li class="cn" id="cn7"><p class="first cn" id="cn7">程序员编写 Python代码和设计人员制作模板两项工作同时进行的效率是最高的，远胜于让一个人等待另一个人完成对某个既包含 Python又包含 HTML 的文件的编辑工作。</p></li></ul><p class="cn" id="cn8">基于这些原因，将页面的设计和Python的代码分离开会更干净简洁更容易维护。 我们可以使用 Django的 <em>模板系统</em> (Template System)来实现这种模式，这就是本章要具体讨论的问题。</p><div class="section" id="id2"><span id="cn9"></span><h2 class="cn" id="cn9">模板系统基本知识</h2><p class="cn" id="cn10">模板是一个文本，用于分离文档的表现形式和内容。 模板定义了占位符以及各种用于规范文档该如何显示的各部分基本逻辑（模板标签）。 模板通常用于产生HTML，但是Django的模板也能产生任何基于文本格式的文档。</p><p class="cn" id="cn11">让我们从一个简单的例子模板开始。 该模板描述了一个向某个与公司签单人员致谢 HTML 页面。 可将其视为一个格式信函：</p><pre class="cn literal-block" id="cn13">&lt;html&gt;&lt;head&gt;&lt;title&gt;Ordering notice&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ordering notice&lt;/h1&gt;&lt;p&gt;Dear {{ person_name }},&lt;/p&gt;&lt;p&gt;Thanks for placing an order from {{ company }}. It's scheduled toship on {{ ship_date|date:&quot;F j, Y&quot; }}.&lt;/p&gt;&lt;p&gt;Here are the items you've ordered:&lt;/p&gt;&lt;ul&gt;{% for item in item_list %}&lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;{% if ordered_warranty %}&lt;p&gt;Your warranty information will be included in the packaging.&lt;/p&gt;{% else %}&lt;p&gt;You didn't order a warranty, so you're on your own whenthe products inevitably stop working.&lt;/p&gt;{% endif %}&lt;p&gt;Sincerely,&lt;br /&gt;{{ company }}&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><p class="cn" id="cn14">该模板是一段添加了些许变量和模板标签的基础 HTML 。 让我们逐步分析一下：</p><blockquote><p class="cn" id="cn15">用两个大括号括起来的文字（例如 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">person_name</span> <span class="pre">}}</span></tt> ）称为 <em>变量(variable)</em> 。这意味着在此处插入指定变量的值。 如何指定变量的值呢？ 稍后就会说明。</p><p class="cn" id="cn16">被大括号和百分号包围的文本(例如 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">ordered_warranty</span> <span class="pre">%}</span></tt> )是 <em>模板标签(template tag)</em> 。标签(tag)定义比较明确，即： 仅通知模板系统完成某些工作的标签。</p><p class="cn" id="cn17">这个例子中的模板包含一个<tt class="docutils literal"><span class="pre">for</span></tt>标签（ <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">item_list</span> <span class="pre">%}</span></tt> ）和一个<tt class="docutils literal"><span class="pre">if</span></tt>  标签（<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">ordered_warranty</span> <span class="pre">%}</span></tt> ）</p><p class="cn" id="cn18">for标签类似Python的for语句，可让你循环访问序列里的每一个项目。 <tt class="docutils literal"><span class="pre">if</span></tt> 标签，正如你所料，是用来执行逻辑判断的。 在这里，tag标签检查ordered_warranty值是否为True。如果是，模板系统将显示{% if ordered_warranty %}和{%else %}之间的内容；否则将显示{% else%}和{% endif %}之间的内容。{% else %}是可选的。</p><p class="cn" id="cn19">最后，这个模板的第二段中有一个关于<em>filter</em>过滤器的例子，它是一种最便捷的转换变量输出格式的方式。 如这个例子中的{{ship_date|date:&#8221;F j, Y&#8221; }}，我们将变量ship_date传递给date过滤器，同时指定参数&#8221;F j,Y&#8221;。date过滤器根据参数进行格式输出。 过滤器是用管道符(|)来调用的，具体可以参见Unix管道符。</p></blockquote><p class="cn" id="cn20">Django 模板含有很多内置的tags和filters,我们将陆续进行学习. 附录F列出了很多的tags和filters的列表,熟悉这些列表对你来说是个好建议. 你依然可以利用它创建自己的tag和filters。这些我们在第9章会讲到。</p></div><div class="section" id="id3"><span id="cn21"></span><h2 class="cn" id="cn21">如何使用模板系统</h2><p class="cn" id="cn22">让我们深入研究模板系统，你将会明白它是如何工作的。但我们暂不打算将它与先前创建的视图结合在一起，因为我们现在的目的是了解它是如何独立工作的。 。 （换言之， 通常你会将模板和视图一起使用，但是我们只是想突出模板系统是一个Python库，你可以在任何地方使用它，而不仅仅是在Django视图中。）</p><p class="cn" id="cn23">在Python代码中使用Django模板的最基本方式如下：</p><ol class="arabic simple"><li class="cn" id="cn24"><p class="first cn" id="cn24">可以用原始的模板代码字符串创建一个 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象， Django同样支持用指定模板文件路径的方式来创建 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象;</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn25"><p class="first cn" id="cn25">调用模板对象的render方法，并且传入一套变量context。它将返回一个基于模板的展现字符串，模板中的变量和标签会被context值替换。</p></li></ol><p class="cn" id="cn26">代码如下：</p><pre class="cn literal-block" id="cn28">&gt;&gt;&gt; from django import template&gt;&gt;&gt; t = template.Template('My name is {{ name }}.')&gt;&gt;&gt; c = template.Context({'name': 'Adrian'})&gt;&gt;&gt; print t.render(c)My name is Adrian.&gt;&gt;&gt; c = template.Context({'name': 'Fred'})&gt;&gt;&gt; print t.render(c)My name is Fred.</pre><p class="cn" id="cn29">以下部分逐步的详细介绍</p><div class="section" id="id4"><span id="cn30"></span><h3 class="cn" id="cn30">创建模板对象</h3><p class="cn" id="cn31">创建一个 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象最简单的方法就是直接实例化它。 <tt class="docutils literal"><span class="pre">Template</span></tt> 类就在 <tt class="docutils literal"><span class="pre">django.template</span></tt> 模块中，构造函数接受一个参数，原始模板代码。 让我们深入挖掘一下 Python的解释器看看它是怎么工作的。</p><p class="cn" id="cn32">转到project目录（在第二章由 <tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">startproject</span></tt> 命令创建）， 输入命令 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">shell</span></tt> 启动交互界面。</p><p class="cn" id="cn33">一个特殊的Python提示符</p><p class="cn" id="cn34">如果你曾经使用过Python，你一定好奇，为什么我们运行<tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span><span class="pre">shell</span></tt>而不是<tt class="docutils literal"><span class="pre">python</span></tt>。这两个命令都会启动交互解释器，但是<tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">shell</span></tt>命令有一个重要的不同： 在启动解释器之前，它告诉Django使用哪个设置文件。 Django框架的大部分子系统，包括模板系统，都依赖于配置文件；如果Django不知道使用哪个配置文件，这些系统将不能工作。</p><p class="cn" id="cn35">如果你想知道，这里将向你解释它背后是如何工作的。 Django搜索DJANGO_SETTINGS_MODULE环境变量，它被设置在settings.py中。例如，假设mysite在你的Python搜索路径中，那么DJANGO_SETTINGS_MODULE应该被设置为：&#8217;mysite.settings&#8217;。</p><p class="cn" id="cn36">当你运行命令：python manage.py shell，它将自动帮你处理DJANGO_SETTINGS_MODULE。 在当前的这些示例中，我们鼓励你使用`` python manage.pyshell``这个方法，这样可以免去你大费周章地去配置那些你不熟悉的环境变量。</p><p class="cn" id="cn37">随着你越来越熟悉Django，你可能会偏向于废弃使用`` manage.py shell``，而是在你的配置文件<tt class="docutils literal"><span class="pre">.bash_profile</span></tt>中手动添加 <tt class="docutils literal"><span class="pre">DJANGO_SETTINGS_MODULE</span></tt>这个环境变量。</p><p class="cn" id="cn38">让我们来了解一些模板系统的基本知识：</p><pre class="cn literal-block" id="cn40">&gt;&gt;&gt; from django.template import Template&gt;&gt;&gt; t = Template('My name is {{ name }}.')&gt;&gt;&gt; print t</pre><p class="cn" id="cn41">如果你跟我们一起做，你将会看到下面的内容：</p><pre class="cn literal-block" id="cn43">&lt;django.template.Template object at 0xb7d5f24c&gt;</pre><p class="cn" id="cn44"><tt class="docutils literal"><span class="pre">0xb7d5f24c</span></tt> 每次都会不一样，这没什么关系；这只是Python运行时 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象的ID。</p><p class="cn" id="cn45">当你创建一个 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象，模板系统在内部编译这个模板到内部格式，并做优化，做好 渲染的准备。 如果你的模板语法有错误，那么在调用 <tt class="docutils literal"><span class="pre">Template()</span></tt> 时就会抛出 <tt class="docutils literal"><span class="pre">TemplateSyntaxError</span></tt> 异常：</p><pre class="cn literal-block" id="cn47">&gt;&gt;&gt; from django.template import Template&gt;&gt;&gt; t = Template('{% notatag %}')Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in ?...django.template.TemplateSyntaxError: Invalid block tag: 'notatag'</pre><p class="cn" id="cn48">这里，块标签(block tag)指向的是`` {% notatag %}``，块标签与模板标签是同义的。</p><p class="cn" id="cn49">系统会在下面的情形抛出 <tt class="docutils literal"><span class="pre">TemplateSyntaxError</span></tt> 异常：</p><ul class="simple"><li class="cn" id="cn50"><p class="first cn" id="cn50">无效的tags</p></li></ul><ul class="simple"><li class="cn" id="cn51"><p class="first cn" id="cn51">标签的参数无效</p></li></ul><ul class="simple"><li class="cn" id="cn52"><p class="first cn" id="cn52">无效的过滤器</p></li></ul><ul class="simple"><li class="cn" id="cn53"><p class="first cn" id="cn53">过滤器的参数无效</p></li></ul><ul class="simple"><li class="cn" id="cn54"><p class="first cn" id="cn54">无效的模板语法</p></li></ul><ul class="simple"><li class="cn" id="cn55"><p class="first cn" id="cn55">未封闭的块标签 （针对需要封闭的块标签）</p></li></ul></div><div class="section" id="id5"><span id="cn56"></span><h3 class="cn" id="cn56">模板渲染</h3><p class="cn" id="cn57">一旦你创建一个 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象，你可以用 <em>context</em> 来传递数据给它。 一个context是一系列变量和它们值的集合。</p><p class="cn" id="cn58">context在Django里表现为 <tt class="docutils literal"><span class="pre">Context</span></tt> 类，在 <tt class="docutils literal"><span class="pre">django.template</span></tt> 模块里。 她的构造函数带有一个可选的参数： 一个字典映射变量和它们的值。 调用 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象 的 <tt class="docutils literal"><span class="pre">render()</span></tt> 方法并传递context来填充模板：</p><pre class="cn literal-block" id="cn60">&gt;&gt;&gt; from django.template import Context, Template&gt;&gt;&gt; t = Template('My name is {{ name }}.')&gt;&gt;&gt; c = Context({'name': 'Stephane'})&gt;&gt;&gt; t.render(c)u'My name is Stephane.'</pre><p class="cn" id="cn61">我们必须指出的一点是，<tt class="docutils literal"><span class="pre">t.render(c)</span></tt>返回的值是一个Unicode对象，不是普通的Python字符串。 你可以通过字符串前的<tt class="docutils literal"><span class="pre">u</span></tt>来区分。 在框架中，Django会一直使用Unicode对象而不是普通的字符串。 如果你明白这样做给你带来了多大便利的话，尽可能地感激Django在幕后有条不紊地为你所做这这么多工作吧。 如果不明白你从中获益了什么，别担心。你只需要知道Django对Unicode的支持，将让你的应用程序轻松地处理各式各样的字符集，而不仅仅是基本的A-Z英文字符。</p><p class="cn" id="cn62">字典和Contexts</p><p class="cn" id="cn63">Python的字典数据类型就是关键字和它们值的一个映射。 <tt class="docutils literal"><span class="pre">Context</span></tt> 和字典很类似， <tt class="docutils literal"><span class="pre">Context</span></tt> 还提供更多的功能，请看第九章。</p><p class="cn" id="cn64">变量名必须由英文字符开始 （A-Z或a-z）并可以包含数字字符、下划线和小数点。 （小数点在这里有特别的用途，稍后我们会讲到）变量是大小写敏感的。</p><p class="cn" id="cn65">下面是编写模板并渲染的示例：</p><pre class="cn literal-block" id="cn67">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; raw_template = &quot;&quot;&quot;&lt;p&gt;Dear {{ person_name }},&lt;/p&gt;...... &lt;p&gt;Thanks for placing an order from {{ company }}. It's scheduled to... ship on {{ ship_date|date:&quot;F j, Y&quot; }}.&lt;/p&gt;...... {% if ordered_warranty %}... &lt;p&gt;Your warranty information will be included in the packaging.&lt;/p&gt;... {% else %}... &lt;p&gt;You didn't order a warranty, so you're on your own when... the products inevitably stop working.&lt;/p&gt;... {% endif %}...... &lt;p&gt;Sincerely,&lt;br /&gt;{{ company }}&lt;/p&gt;&quot;&quot;&quot;&gt;&gt;&gt; t = Template(raw_template)&gt;&gt;&gt; import datetime&gt;&gt;&gt; c = Context({'person_name': 'John Smith',...     'company': 'Outdoor Equipment',...     'ship_date': datetime.date(2009, 4, 2),...     'ordered_warranty': False})&gt;&gt;&gt; t.render(c)u&quot;&lt;p&gt;Dear John Smith,&lt;/p&gt;\n\n&lt;p&gt;Thanks for placing an order from OutdoorEquipment. It's scheduled to\nship on April 2, 2009.&lt;/p&gt;\n\n\n&lt;p&gt;Youdidn't order a warranty, so you're on your own when\nthe productsinevitably stop working.&lt;/p&gt;\n\n\n&lt;p&gt;Sincerely,&lt;br /&gt;Outdoor Equipment&lt;/p&gt;&quot;</pre><p class="cn" id="cn68">让我们逐步来分析下这段代码：</p><blockquote><p class="cn" id="cn69">首先我们导入 （import）类 <tt class="docutils literal"><span class="pre">Template</span></tt> 和 <tt class="docutils literal"><span class="pre">Context</span></tt> ，它们都在模块 <tt class="docutils literal"><span class="pre">django.template</span></tt> 里。</p><p class="cn" id="cn70">我们把模板原始文本保存到变量 <tt class="docutils literal"><span class="pre">raw_template</span></tt> 。注意到我们使用了三个引号来 标识这些文本，因为这样可以包含多行。</p><p class="cn" id="cn71">接下来，我们创建了一个模板对象 <tt class="docutils literal"><span class="pre">t</span></tt> ，把 <tt class="docutils literal"><span class="pre">raw_template</span></tt> 作为 <tt class="docutils literal"><span class="pre">Template</span></tt> 类构造函数的参数。</p><p class="cn" id="cn72">我们从Python的标准库导入 <tt class="docutils literal"><span class="pre">datetime</span></tt> 模块，以后我们将会使用它。</p><p class="cn" id="cn73">然后，我们创建一个 <tt class="docutils literal"><span class="pre">Context</span></tt> 对象， <tt class="docutils literal"><span class="pre">c</span></tt> 。 <tt class="docutils literal"><span class="pre">Context</span></tt> 构造的参数是Python 字典数据类型。 在这里，我们指定参数 <tt class="docutils literal"><span class="pre">person_name</span></tt> 的值是 <tt class="docutils literal"><span class="pre">'John</span> <span class="pre">Smith'</span></tt> , 参数company 的值为 &#8216;OutdoorEquipment&#8217; ，等等。</p><p class="cn" id="cn74">最后，我们在模板对象上调用 <tt class="docutils literal"><span class="pre">render()</span></tt> 方法，传递 context参数给它。 这是返回渲染后的模板的方法，它会替换模板变量为真实的值和执行块标签。</p><p class="cn" id="cn75">注意，warranty paragraph显示是因为 <tt class="docutils literal"><span class="pre">ordered_warranty</span></tt> 的值为 <tt class="docutils literal"><span class="pre">True</span></tt> . 注意时间的显示， <tt class="docutils literal"><span class="pre">April</span> <span class="pre">2,</span> <span class="pre">2009</span></tt> , 它是按 <tt class="docutils literal"><span class="pre">'F</span> <span class="pre">j,</span> <span class="pre">Y'</span></tt> 格式显示的。</p><p class="cn" id="cn76">如果你是Python初学者，你可能在想为什么输出里有回车换行的字符(<tt class="docutils literal"><span class="pre">'\n'</span></tt> )而不是 显示回车换行？ 因为这是Python交互解释器的缘故： 调用 <tt class="docutils literal"><span class="pre">t.render(c)</span></tt> 返回字符串， 解释器缺省显示这些字符串的 <em>真实内容呈现</em> ，而不是打印这个变量的值。 要显示换行而不是 <tt class="docutils literal"><span class="pre">'\n'</span></tt> ，使用 <tt class="docutils literal"><span class="pre">print</span></tt> 语句： <tt class="docutils literal"><span class="pre">print</span> <span class="pre">t.render(c)</span></tt> 。</p></blockquote><p class="cn" id="cn77">这就是使用Django模板系统的基本规则： 写模板，创建 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象，创建 <tt class="docutils literal"><span class="pre">Context</span></tt> ， 调用 <tt class="docutils literal"><span class="pre">render()</span></tt> 方法。</p></div><div class="section" id="id6"><span id="cn78"></span><h3 class="cn" id="cn78">同一模板，多个上下文</h3><p class="cn" id="cn79">一旦有了 <tt class="docutils literal"><span class="pre">模板</span></tt> 对象，你就可以通过它渲染多个context， 例如：</p><pre class="cn literal-block" id="cn81">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('Hello, {{ name }}')&gt;&gt;&gt; print t.render(Context({'name': 'John'}))Hello, John&gt;&gt;&gt; print t.render(Context({'name': 'Julie'}))Hello, Julie&gt;&gt;&gt; print t.render(Context({'name': 'Pat'}))Hello, Pat</pre><p class="cn" id="cn82">无论何时我们都可以像这样使用同一模板源渲染多个context，只进行 <tt class="docutils literal"><span class="pre">一次</span></tt>模板创建然后多次调用render()方法渲染会更为高效：</p><pre class="cn literal-block" id="cn84"># Badfor name in ('John', 'Julie', 'Pat'):t = Template('Hello, {{ name }}')print t.render(Context({'name': name}))# Goodt = Template('Hello, {{ name }}')for name in ('John', 'Julie', 'Pat'):print t.render(Context({'name': name}))</pre><p class="cn" id="cn85">Django 模板解析非常快捷。 大部分的解析工作都是在后台通过对简短正则表达式一次性调用来完成。 这和基于 XML 的模板引擎形成鲜明对比，那些引擎承担了 XML 解析器的开销，且往往比 Django 模板渲染引擎要慢上几个数量级。</p></div><div class="section" id="id7"><span id="cn86"></span><h3 class="cn" id="cn86">深度变量的查找</h3><p class="cn" id="cn87">在到目前为止的例子中，我们通过 context 传递的简单参数值主要是字符串，还有一个 <tt class="docutils literal"><span class="pre">datetime.date</span></tt> 范例。 然而，模板系统能够非常简洁地处理更加复杂的数据结构，例如list、dictionary和自定义的对象。</p><p class="cn" id="cn88">在 Django 模板中遍历复杂数据结构的关键是句点字符 (<tt class="docutils literal"><span class="pre">.</span></tt>)。</p><p class="cn" id="cn89">最好是用几个例子来说明一下。 比如，假设你要向模板传递一个 Python 字典。 要通过字典键访问该字典的值，可使用一个句点：</p><pre class="cn literal-block" id="cn91">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; person = {'name': 'Sally', 'age': '43'}&gt;&gt;&gt; t = Template('{{ person.name }} is {{ person.age }} years old.')&gt;&gt;&gt; c = Context({'person': person})&gt;&gt;&gt; t.render(c)u'Sally is 43 years old.'</pre><p class="cn" id="cn92">同样，也可以通过句点来访问对象的属性。 比方说， Python 的 <tt class="docutils literal"><span class="pre">datetime.date</span></tt> 对象有 <tt class="docutils literal"><span class="pre">year</span></tt> 、 <tt class="docutils literal"><span class="pre">month</span></tt> 和 <tt class="docutils literal"><span class="pre">day</span></tt> 几个属性，你同样可以在模板中使用句点来访问这些属性：</p><pre class="cn literal-block" id="cn94">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; import datetime&gt;&gt;&gt; d = datetime.date(1993, 5, 2)&gt;&gt;&gt; d.year1993&gt;&gt;&gt; d.month5&gt;&gt;&gt; d.day2&gt;&gt;&gt; t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')&gt;&gt;&gt; c = Context({'date': d})&gt;&gt;&gt; t.render(c)u'The month is 5 and the year is 1993.'</pre><p class="cn" id="cn95">这个例子使用了一个自定义的类，演示了通过实例变量加一点(dots)来访问它的属性，这个方法适用于任意的对象。</p><pre class="cn literal-block" id="cn97">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; class Person(object):...     def __init__(self, first_name, last_name):...         self.first_name, self.last_name = first_name, last_name&gt;&gt;&gt; t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')&gt;&gt;&gt; c = Context({'person': Person('John', 'Smith')})&gt;&gt;&gt; t.render(c)u'Hello, John Smith.'</pre><p class="cn" id="cn98">点语法也可以用来引用对象的* 方法*。 例如，每个 Python 字符串都有 <tt class="docutils literal"><span class="pre">upper()</span></tt> 和 <tt class="docutils literal"><span class="pre">isdigit()</span></tt> 方法，你在模板中可以使用同样的句点语法来调用它们：</p><pre class="cn literal-block" id="cn100">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')&gt;&gt;&gt; t.render(Context({'var': 'hello'}))u'hello -- HELLO -- False'&gt;&gt;&gt; t.render(Context({'var': '123'}))u'123 -- 123 -- True'</pre><p class="cn" id="cn101">注意这里调用方法时并* 没有* 使用圆括号 而且也无法给该方法传递参数；你只能调用不需参数的方法。 （我们将在本章稍后部分解释该设计观。）</p><p class="cn" id="cn102">最后，句点也可用于访问列表索引，例如：</p><pre class="cn literal-block" id="cn104">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('Item 2 is {{ items.2 }}.')&gt;&gt;&gt; c = Context({'items': ['apples', 'bananas', 'carrots']})&gt;&gt;&gt; t.render(c)u'Item 2 is carrots.'</pre><p class="cn" id="cn105">不允许使用负数列表索引。 像 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">items.-1</span> <span class="pre">}}</span></tt> 这样的模板变量将会引发`` TemplateSyntaxError``</p><p class="cn" id="cn106">Python 列表类型</p><p class="cn" id="cn107">一点提示： Python的列表是从0开始索引。 第一项的索引是0，第二项的是1，依此类推。</p><p class="cn" id="cn108">句点查找规则可概括为： 当模板系统在变量名中遇到点时，按照以下顺序尝试进行查找：</p><ul class="simple"><li class="cn" id="cn109"><p class="first cn" id="cn109">字典类型查找 （比如 <tt class="docutils literal"><span class="pre">foo[&quot;bar&quot;]</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn110"><p class="first cn" id="cn110">属性查找 (比如 <tt class="docutils literal"><span class="pre">foo.bar</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn111"><p class="first cn" id="cn111">方法调用 （比如 <tt class="docutils literal"><span class="pre">foo.bar()</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn112"><p class="first cn" id="cn112">列表类型索引查找 (比如 <tt class="docutils literal"><span class="pre">foo[bar]</span></tt> )</p></li></ul><p class="cn" id="cn113">系统使用找到的第一个有效类型。 这是一种短路逻辑。</p><p class="cn" id="cn114">句点查找可以多级深度嵌套。 例如在下面这个例子中 <tt class="docutils literal"><span class="pre">{{person.name.upper}}</span></tt> 会转换成字典类型查找（ <tt class="docutils literal"><span class="pre">person['name']</span></tt> ) 然后是方法调用（ <tt class="docutils literal"><span class="pre">upper()</span></tt> ):</p><pre class="cn literal-block" id="cn116">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; person = {'name': 'Sally', 'age': '43'}&gt;&gt;&gt; t = Template('{{ person.name.upper }} is {{ person.age }} years old.')&gt;&gt;&gt; c = Context({'person': person})&gt;&gt;&gt; t.render(c)u'SALLY is 43 years old.'</pre><div class="section" id="id8"><span id="cn117"></span><h4 class="cn" id="cn117">方法调用行为</h4><p class="cn" id="cn118">方法调用比其他类型的查找略为复杂一点。 以下是一些注意事项：</p><blockquote><p class="cn" id="cn119">在方法查找过程中，如果某方法抛出一个异常，除非该异常有一个 <tt class="docutils literal"><span class="pre">silent_variable_failure</span></tt> 属性并且值为 <tt class="docutils literal"><span class="pre">True</span></tt> ，否则的话它将被传播。如果异常被传播，模板里的指定变量会被置为空字符串，比如:</p></blockquote><pre class="cn literal-block" id="cn121">&gt;&gt;&gt; t = Template(&quot;My name is {{ person.first_name }}.&quot;)&gt;&gt;&gt; class PersonClass3:...     def first_name(self):...         raise AssertionError, &quot;foo&quot;&gt;&gt;&gt; p = PersonClass3()&gt;&gt;&gt; t.render(Context({&quot;person&quot;: p}))Traceback (most recent call last):...AssertionError: foo&gt;&gt;&gt; class SilentAssertionError(AssertionError):...     silent_variable_failure = True&gt;&gt;&gt; class PersonClass4:...     def first_name(self):...         raise SilentAssertionError&gt;&gt;&gt; p = PersonClass4()&gt;&gt;&gt; t.render(Context({&quot;person&quot;: p}))u'My name is .'</pre><blockquote><p class="cn" id="cn122">仅在方法无需传入参数时，其调用才有效。 否则，系统将会转移到下一个查找类型（列表索引查找）。</p><p class="cn" id="cn123">显然，有些方法是有副作用的，好的情况下允许模板系统访问它们可能只是干件蠢事，坏的情况下甚至会引发安全漏洞。</p><p class="cn" id="cn124">例如，你的一个 <tt class="docutils literal"><span class="pre">BankAccount</span></tt> 对象有一个 <tt class="docutils literal"><span class="pre">delete()</span></tt> 方法。如果某个模板中包含了像 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">account.delete</span> <span class="pre">}}</span></tt>这样的标签，其中`` account`` 又是<tt class="docutils literal"><span class="pre">BankAccount</span></tt> 的一个实例，请注意在这个模板载入时，account对象将被删除。</p><p class="cn" id="cn125">要防止这样的事情发生，必须设置该方法的 <tt class="docutils literal"><span class="pre">alters_data</span></tt> 函数属性：</p></blockquote><pre class="cn literal-block" id="cn127">def delete(self):# Delete the accountdelete.alters_data = True</pre><blockquote><p class="cn" id="cn128">模板系统不会执行任何以该方式进行标记的方法。 接上面的例子，如果模板文件里包含了 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">account.delete</span> <span class="pre">}}</span></tt> ，对象又具有 <tt class="docutils literal"><span class="pre">delete()</span></tt>方法，而且<tt class="docutils literal"><span class="pre">delete()</span></tt> 有<tt class="docutils literal"><span class="pre">alters_data=True</span></tt>这个属性，那么在模板载入时， <tt class="docutils literal"><span class="pre">delete()</span></tt>方法将不会被执行。 它将静静地错误退出。</p></blockquote></div><div class="section" id="id9"><span id="cn129"></span><h4 class="cn" id="cn129">如何处理无效变量</h4><p class="cn" id="cn130">默认情况下，如果一个变量不存在，模板系统会把它展示为空字符串，不做任何事情来表示失败。 例如：</p><pre class="cn literal-block" id="cn132">&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('Your name is {{ name }}.')&gt;&gt;&gt; t.render(Context())u'Your name is .'&gt;&gt;&gt; t.render(Context({'var': 'hello'}))u'Your name is .'&gt;&gt;&gt; t.render(Context({'NAME': 'hello'}))u'Your name is .'&gt;&gt;&gt; t.render(Context({'Name': 'hello'}))u'Your name is .'</pre><p class="cn" id="cn133">系统静悄悄地表示失败，而不是引发一个异常，因为这通常是人为错误造成的。 这种情况下，因为变量名有错误的状况或名称， 所有的查询都会失败。 现实世界中，对于一个web站点来说，如果仅仅因为一个小的模板语法错误而造成无法访问，这是不可接受的。</p></div></div><div class="section" id="context"><span id="cn134"></span><h3 class="cn" id="cn134">玩一玩上下文(context)对象</h3><p class="cn" id="cn135">多数时间，你可以通过传递一个完全填充(full populated)的字典给 <tt class="docutils literal"><span class="pre">Context()</span></tt> 来初始化 <tt class="docutils literal"><span class="pre">上下文(Context)</span></tt> 。 但是初始化以后，你也可以使用标准的Python字典语法(syntax)向``上下文(Context)`` 对象添加或者删除条目:</p><pre class="cn literal-block" id="cn137">&gt;&gt;&gt; from django.template import Context&gt;&gt;&gt; c = Context({&quot;foo&quot;: &quot;bar&quot;})&gt;&gt;&gt; c['foo']'bar'&gt;&gt;&gt; del c['foo']&gt;&gt;&gt; c['foo']Traceback (most recent call last):...KeyError: 'foo'&gt;&gt;&gt; c['newvariable'] = 'hello'&gt;&gt;&gt; c['newvariable']'hello'</pre></div></div><div class="section" id="id10"><span id="cn138"></span><h2 class="cn" id="cn138">基本的模板标签和过滤器</h2><p class="cn" id="cn139">像我们以前提到过的，模板系统带有内置的标签和过滤器。下面的章节提供了一个多数通用标签和过滤器的简要说明。</p><div class="section" id="id11"><span id="cn140"></span><h3 class="cn" id="cn140">标签</h3><div class="section" id="if-else"><span id="cn141"></span><h4 class="cn" id="cn141">if/else</h4><p class="cn" id="cn142"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 标签检查(evaluate)一个变量，如果这个变量为真（即，变量存在，非空，不是布尔值假），系统会显示在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endif</span> <span class="pre">%}</span></tt> 之间的任何内容，例如：</p><pre class="cn literal-block" id="cn144">{% if today_is_weekend %}&lt;p&gt;Welcome to the weekend!&lt;/p&gt;{% endif %}</pre><p class="cn" id="cn145"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">else</span> <span class="pre">%}</span></tt> 标签是可选的：</p><pre class="cn literal-block" id="cn147">{% if today_is_weekend %}&lt;p&gt;Welcome to the weekend!&lt;/p&gt;{% else %}&lt;p&gt;Get back to work.&lt;/p&gt;{% endif %}</pre><p class="cn" id="cn148">Python 的“真值”</p><p class="cn" id="cn149">在Python和Django模板系统中，以下这些对象相当于布尔值的<tt class="docutils literal"><span class="pre">False</span></tt></p><ul class="simple"><li class="cn" id="cn150"><p class="first cn" id="cn150">空列表(<tt class="docutils literal"><span class="pre">[]</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn151"><p class="first cn" id="cn151">空元组(<tt class="docutils literal"><span class="pre">()</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn152"><p class="first cn" id="cn152">空字典(<tt class="docutils literal"><span class="pre">{}</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn153"><p class="first cn" id="cn153">空字符串(<tt class="docutils literal"><span class="pre">''</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn154"><p class="first cn" id="cn154">零值(<tt class="docutils literal"><span class="pre">0</span></tt> )</p></li></ul><ul class="simple"><li class="cn" id="cn155"><p class="first cn" id="cn155">特殊对象<tt class="docutils literal"><span class="pre">None</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn156"><p class="first cn" id="cn156">对象<tt class="docutils literal"><span class="pre">False</span></tt>（很明显）</p></li></ul><ul class="simple"><li class="cn" id="cn157"><p class="first cn" id="cn157">提示：你也可以在自定义的对象里定义他们的布尔值属性(这个是python的高级用法)。</p></li></ul><p class="cn" id="cn158">除以上几点以外的所有东西都视为`` True``</p><p class="cn" id="cn159"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 标签接受 <tt class="docutils literal"><span class="pre">and</span></tt> ， <tt class="docutils literal"><span class="pre">or</span></tt> 或者 <tt class="docutils literal"><span class="pre">not</span></tt> 关键字来对多个变量做判断 ，或者对变量取反（ <tt class="docutils literal"><span class="pre">not</span></tt> )，例如： 例如：</p><pre class="cn literal-block" id="cn161">{% if athlete_list and coach_list %}Both athletes and coaches are available.{% endif %}{% if not athlete_list %}There are no athletes.{% endif %}{% if athlete_list or coach_list %}There are some athletes or some coaches.{% endif %}{% if not athlete_list or coach_list %}There are no athletes or there are some coaches.{% endif %}{% if athlete_list and not coach_list %}There are some athletes and absolutely no coaches.{% endif %}</pre><p class="cn" id="cn162"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 标签不允许在同一个标签中同时使用 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> ，因为逻辑上可能模糊的，例如，如下示例是错误的： 比如这样的代码是不合法的：</p><pre class="cn literal-block" id="cn164">{% if athlete_list and coach_list or cheerleader_list %}</pre><p class="cn" id="cn165">系统不支持用圆括号来组合比较操作。 如果你确实需要用到圆括号来组合表达你的逻辑式，考虑将它移到模板之外处理，然后以模板变量的形式传入结果吧。 或者，仅仅用嵌套的<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt>标签替换吧，就像这样：</p><pre class="cn literal-block" id="cn167">{% if athlete_list %}{% if coach_list or cheerleader_list %}We have athletes, and either coaches or cheerleaders!{% endif %}{% endif %}</pre><p class="cn" id="cn168">多次使用同一个逻辑操作符是没有问题的，但是我们不能把不同的操作符组合起来。 例如，这是合法的：</p><pre class="cn literal-block" id="cn170">{% if athlete_list or coach_list or parent_list or teacher_list %}</pre><p class="cn" id="cn171">并没有 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">elif</span> <span class="pre">%}</span></tt> 标签， 请使用嵌套的`` {% if %}``  标签来达成同样的效果：</p><pre class="cn literal-block" id="cn173">{% if athlete_list %}&lt;p&gt;Here are the athletes: {{ athlete_list }}.&lt;/p&gt;{% else %}&lt;p&gt;No athletes are available.&lt;/p&gt;{% if coach_list %}&lt;p&gt;Here are the coaches: {{ coach_list }}.&lt;/p&gt;{% endif %}{% endif %}</pre><p class="cn" id="cn174">一定要用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endif</span> <span class="pre">%}</span></tt> 关闭每一个 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 标签。</p></div><div class="section" id="for"><span id="cn175"></span><h4 class="cn" id="cn175">for</h4><p class="cn" id="cn176"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">%}</span></tt> 允许我们在一个序列上迭代。 与Python的 <tt class="docutils literal"><span class="pre">for</span></tt> 语句的情形类似，循环语法是 <tt class="docutils literal"><span class="pre">for</span> <span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></tt> ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。每一次循环中，模板系统会渲染在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endfor</span> <span class="pre">%}</span></tt> 之间的所有内容。</p><p class="cn" id="cn177">例如，给定一个运动员列表 <tt class="docutils literal"><span class="pre">athlete_list</span></tt> 变量，我们可以使用下面的代码来显示这个列表：</p><pre class="cn literal-block" id="cn179">&lt;ul&gt;{% for athlete in athlete_list %}&lt;li&gt;{{ athlete.name }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;</pre><p class="cn" id="cn180">给标签增加一个 <tt class="docutils literal"><span class="pre">reversed</span></tt> 使得该列表被反向迭代：</p><pre class="cn literal-block" id="cn182">{% for athlete in athlete_list reversed %}...{% endfor %}</pre><p class="cn" id="cn183">可以嵌套使用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">%}</span></tt> 标签：</p><pre class="cn literal-block" id="cn185">{% for athlete in athlete_list %}&lt;h1&gt;{{ athlete.name }}&lt;/h1&gt;&lt;ul&gt;{% for sport in athlete.sports_played %}&lt;li&gt;{{ sport }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;{% endfor %}</pre><p class="cn" id="cn186">在执行循环之前先检测列表的大小是一个通常的做法，当列表为空时输出一些特别的提示。</p><pre class="cn literal-block" id="cn188">{% if athlete_list %}{% for athlete in athlete_list %}&lt;p&gt;{{ athlete.name }}&lt;/p&gt;{% endfor %}{% else %}&lt;p&gt;There are no athletes. Only computer programmers.&lt;/p&gt;{% endif %}</pre><p class="cn" id="cn189">因为这种做法十分常见，所以`` for`` 标签支持一个可选的`` {% empty %}`` 分句，通过它我们可以定义当列表为空时的输出内容 下面的例子与之前那个等价：</p><pre class="cn literal-block" id="cn191">{% for athlete in athlete_list %}&lt;p&gt;{{ athlete.name }}&lt;/p&gt;{% empty %}&lt;p&gt;There are no athletes. Only computer programmers.&lt;/p&gt;{% endfor %}</pre><p class="cn" id="cn192">Django不支持退出循环操作。 如果我们想退出循环，可以改变正在迭代的变量，让其仅仅包含需要迭代的项目。 同理，Django也不支持continue语句，我们无法让当前迭代操作跳回到循环头部。（请参看本章稍后的理念和限制小节，了解下决定这个设计的背后原因）</p><p class="cn" id="cn193">在每个`` {% for %}``循环里有一个称为`` forloop`` 的模板变量。这个变量有一些提示循环进度信息的属性。</p><blockquote><p class="cn" id="cn194"><tt class="docutils literal"><span class="pre">forloop.counter</span></tt> 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的，所以在第一次循环时 <tt class="docutils literal"><span class="pre">forloop.counter</span></tt> 将会被设置为1。</p></blockquote><pre class="cn literal-block" id="cn196">{% for item in todo_list %}&lt;p&gt;{{ forloop.counter }}: {{ item }}&lt;/p&gt;{% endfor %}</pre><blockquote><p class="cn" id="cn197"><tt class="docutils literal"><span class="pre">forloop.counter0</span></tt> 类似于 <tt class="docutils literal"><span class="pre">forloop.counter</span></tt> ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0。</p><p class="cn" id="cn198"><tt class="docutils literal"><span class="pre">forloop.revcounter</span></tt> 是表示循环中剩余项的整型变量。 在循环初次执行时 <tt class="docutils literal"><span class="pre">forloop.revcounter</span></tt> 将被设置为序列中项的总数。 最后一次循环执行中，这个变量将被置1。</p><p class="cn" id="cn199"><tt class="docutils literal"><span class="pre">forloop.revcounter0</span></tt> 类似于 <tt class="docutils literal"><span class="pre">forloop.revcounter</span></tt> ，但它以0做为结束索引。在第一次执行循环时，该变量会被置为序列的项的个数减1。</p><p class="cn" id="cn200"><tt class="docutils literal"><span class="pre">forloop.first</span></tt> 是一个布尔值，如果该迭代是第一次执行，那么它被置为<a href="#id12"><span class="problematic" id="id13">``</span></a>`` 在下面的情形中这个变量是很有用的：</p><div class="system-message" id="id12"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 1071); <em><a href="#id13">backlink</a></em></p><p class="cn" id="cn200">Inline literal start-string without end-string.</p></div></blockquote><pre class="cn literal-block" id="cn202">{% for object in objects %}{% if forloop.first %}&lt;li class=&quot;first&quot;&gt;{% else %}&lt;li&gt;{% endif %}{{ object }}&lt;/li&gt;{% endfor %}</pre><blockquote><p class="cn" id="cn203"><tt class="docutils literal"><span class="pre">forloop.last</span></tt> 是一个布尔值；在最后一次执行循环时被置为True。 一个常见的用法是在一系列的链接之间放置管道符（|）</p></blockquote><pre class="cn literal-block" id="cn205">{% for link in links %}{{ link }}{% if not forloop.last %} | {% endif %}{% endfor %}</pre><blockquote><p class="cn" id="cn206">上面的模板可能会产生如下的结果：</p></blockquote><pre class="cn literal-block" id="cn208">Link1 | Link2 | Link3 | Link4</pre><blockquote><p class="cn" id="cn209">另一个常见的用途是为列表的每个单词的加上逗号。</p></blockquote><pre class="cn literal-block" id="cn211">Favorite places:{% for p in places %}{{ p }}{% if not forloop.last %}, {% endif %}{% endfor %}</pre><blockquote><p class="cn" id="cn212"><tt class="docutils literal"><span class="pre">forloop.parentloop</span></tt> 是一个指向当前循环的上一级循环的 <tt class="docutils literal"><span class="pre">forloop</span></tt> 对象的引用（在嵌套循环的情况下）。 例子在此：</p></blockquote><pre class="cn literal-block" id="cn214">{% for country in countries %}&lt;table&gt;{% for city in country.city_list %}&lt;tr&gt;&lt;td&gt;Country #{{ forloop.parentloop.counter }}&lt;/td&gt;&lt;td&gt;City #{{ forloop.counter }}&lt;/td&gt;&lt;td&gt;{{ city }}&lt;/td&gt;&lt;/tr&gt;{% endfor %}&lt;/table&gt;{% endfor %}</pre><p class="cn" id="cn215"><tt class="docutils literal"><span class="pre">forloop</span></tt> 变量仅仅能够在循环中使用。 在模板解析器碰到<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endfor</span> <span class="pre">%}</span></tt>标签后，<tt class="docutils literal"><span class="pre">forloop</span></tt>就不可访问了。</p><p class="cn" id="cn216">Context和forloop变量</p><p class="cn" id="cn217">在一个 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">%}</span></tt> 块中，已存在的变量会被移除，以避免 <tt class="docutils literal"><span class="pre">forloop</span></tt> 变量被覆盖。 Django会把这个变量移动到 <tt class="docutils literal"><span class="pre">forloop.parentloop</span></tt> 中。通常我们不用担心这个问题，但是一旦我们在模板中定义了 <tt class="docutils literal"><span class="pre">forloop</span></tt> 这个变量（当然我们反对这样做），在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">%}</span></tt> 块中它会在 <tt class="docutils literal"><span class="pre">forloop.parentloop</span></tt> 被重新命名。</p></div><div class="section" id="ifequal-ifnotequal"><span id="cn218"></span><h4 class="cn" id="cn218">ifequal/ifnotequal</h4><p class="cn" id="cn219">Django模板系统压根儿就没想过实现一个全功能的编程语言，所以它不允许我们在模板中执行Python的语句（还是那句话，要了解更多请参看理念和限制小节）。 但是比较两个变量的值并且显示一些结果实在是个太常见的需求了，所以Django提供了 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 标签供我们使用。</p><p class="cn" id="cn220"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 标签比较两个值，当他们相等时，显示在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endifequal</span> <span class="pre">%}</span></tt> 之中所有的值。</p><p class="cn" id="cn221">下面的例子比较两个模板变量 <tt class="docutils literal"><span class="pre">user</span></tt> 和 <tt class="docutils literal"><span class="pre">currentuser</span></tt> :</p><pre class="cn literal-block" id="cn223">{% ifequal user currentuser %}&lt;h1&gt;Welcome!&lt;/h1&gt;{% endifequal %}</pre><p class="cn" id="cn224">参数可以是硬编码的字符串，随便用单引号或者双引号引起来，所以下列代码都是正确的：</p><pre class="cn literal-block" id="cn226">{% ifequal section 'sitenews' %}&lt;h1&gt;Site News&lt;/h1&gt;{% endifequal %}{% ifequal section &quot;community&quot; %}&lt;h1&gt;Community&lt;/h1&gt;{% endifequal %}</pre><p class="cn" id="cn227">和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 类似， <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 支持可选的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">else%}</span></tt> 标签：</p><pre class="cn literal-block" id="cn229">{% ifequal section 'sitenews' %}&lt;h1&gt;Site News&lt;/h1&gt;{% else %}&lt;h1&gt;No News Here&lt;/h1&gt;{% endifequal %}</pre><p class="cn" id="cn230">只有模板变量，字符串，整数和小数可以作为 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 标签的参数。下面是合法参数的例子：</p><pre class="cn literal-block" id="cn232">{% ifequal variable 1 %}{% ifequal variable 1.23 %}{% ifequal variable 'foo' %}{% ifequal variable &quot;foo&quot; %}</pre><p class="cn" id="cn233">其他任何类型，例如Python的字典类型、列表类型、布尔类型，不能用在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 中。 下面是些错误的例子：</p><pre class="cn literal-block" id="cn235">{% ifequal variable True %}{% ifequal variable [1, 2, 3] %}{% ifequal variable {'key': 'value'} %}</pre><p class="cn" id="cn236">如果你需要判断变量是真还是假，请使用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 来替代 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 。</p></div><div class="section" id="id14"><span id="cn237"></span><h4 class="cn" id="cn237">注释</h4><p class="cn" id="cn238">就像HTML或者Python，Django模板语言同样提供代码注释。 注释使用 <tt class="docutils literal"><span class="pre">{#</span> <span class="pre">#}</span></tt> ：</p><pre class="cn literal-block" id="cn240">{# This is a comment #}</pre><p class="cn" id="cn241">注释的内容不会在模板渲染时输出。</p><p class="cn" id="cn242">用这种语法的注释不能跨越多行。 这个限制是为了提高模板解析的性能。 在下面这个模板中，输出结果和模板本身是 完全一样的（也就是说，注释标签并没有被解析为注释）：</p><pre class="cn literal-block" id="cn244">This is a {# this is nota comment #}test.</pre><p class="cn" id="cn245">如果要实现多行注释，可以使用`` {% comment %}`` 模板标签，就像这样：</p><pre class="cn literal-block" id="cn247">{% comment %}This is amulti-line comment.{% endcomment %}</pre></div></div><div class="section" id="id15"><span id="cn248"></span><h3 class="cn" id="cn248">过滤器</h3><p class="cn" id="cn249">就象本章前面提到的一样，模板过滤器是在变量被显示前修改它的值的一个简单方法。 过滤器使用管道字符，如下所示：</p><pre class="cn literal-block" id="cn251">{{ name|lower }}</pre><p class="cn" id="cn252">显示的内容是变量 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">name</span> <span class="pre">}}</span></tt> 被过滤器 <tt class="docutils literal"><span class="pre">lower</span></tt> 处理后的结果，它功能是转换文本为小写。</p><p class="cn" id="cn253">过滤管道可以被* 套接* ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入，如此下去。 下面的例子实现查找列表的第一个元素并将其转化为大写。</p><pre class="cn literal-block" id="cn255">{{ my_list|first|upper }}</pre><p class="cn" id="cn256">有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：</p><pre class="cn literal-block" id="cn258">{{ bio|truncatewords:&quot;30&quot; }}</pre><p class="cn" id="cn259">这个将显示变量 <tt class="docutils literal"><span class="pre">bio</span></tt> 的前30个词。</p><p class="cn" id="cn260">以下几个是最为重要的过滤器的一部分。 附录F包含其余的过滤器。</p><blockquote><p class="cn" id="cn261"><tt class="docutils literal"><span class="pre">addslashes</span></tt> : 添加反斜杠到任何反斜杠、单引号或者双引号前面。 这在处理包含JavaScript的文本时是非常有用的。</p><p class="cn" id="cn262"><tt class="docutils literal"><span class="pre">date</span></tt> : 按指定的格式字符串参数格式化 <tt class="docutils literal"><span class="pre">date</span></tt> 或者 <tt class="docutils literal"><span class="pre">datetime</span></tt> 对象， 范例：</p></blockquote><pre class="cn literal-block" id="cn264">{{ pub_date|date:&quot;F j, Y&quot; }}</pre><blockquote><p class="cn" id="cn265">格式参数的定义在附录F中。</p><p class="cn" id="cn266"><tt class="docutils literal"><span class="pre">length</span></tt> : 返回变量的长度。 对于列表，这个参数将返回列表元素的个数。 对于字符串，这个参数将返回字符串中字符的个数。 你可以对列表或者字符串，或者任何知道怎么测定长度的Python 对象使用这个方法（也就是说，有 <tt class="docutils literal"><span class="pre">__len__()</span></tt> 方法的对象）。</p></blockquote></div></div><div class="section" id="id16"><span id="cn267"></span><h2 class="cn" id="cn267">理念与局限</h2><p class="cn" id="cn268">现在你已经对Django的模板语言有一些认识了，我们将指出一些特意设置的限制和为什么要这样做 背后的一些设计哲学。</p><p class="cn" id="cn269">相对与其他的网络应用的组件，模板的语法很具主观性，因此可供程序员的选择方案也很广泛。 事实上，Python有成十上百的 开放源码的模板语言实现。 每个实现都是因为开发者认为现存的模板语言不够用。（事实上，对一个 Python开发者来说，写一个自己的模板语言就象是某种“成人礼”一样！ 如果你还没有完成一个自己的 模板语言，好好考虑写一个，这是一个非常有趣的锻炼。 ）</p><p class="cn" id="cn270">明白了这个，你也许有兴趣知道事实上Django并不强制要求你必须使用它的模板语言。 因为Django 虽然被设计成一个FULL-Stack的Web框架，它提供了开发者所必需的所有组件，而且在大多数情况 使用Django模板系统会比其他的Python模板库要 <em>更方便</em> 一点，但是并不是严格要求你必须使用 它。 你将在后续的“视图中应用模板”这一章节中看到，你还可以非常容易地在Django中使用其他的模板语言。</p><p class="cn" id="cn271">虽然如此，很明显，我们对Django模板语言的工作方式有着强烈的偏爱。 这个模板语言来源于World Online的开发经验和Django创造者们集体智慧的结晶。 下面是关于它的一些设计哲学理念：</p><blockquote><p class="cn" id="cn272"><em>业务逻辑应该和表现逻辑相对分开</em> 。我们将模板系统视为控制表现及表现相关逻辑的工具，仅此而已。 模板系统不应提供超出此基本目标的功能。</p><p class="cn" id="cn273">出于这个原因，在 Django 模板中是不可能直接调用 Python 代码的。 所有的编程工作基本上都被局限于模板标签的能力范围。 当然， <em>是</em> 有可能写出自定义的模板标签来完成任意工作，但这些“超范围”的 Django 模板标签有意地不允许执行任何 Python 代码。</p><p class="cn" id="cn274"><em>语法不应受到 HTML/XML 的束缚</em> 。尽管 Django 模板系统主要用于生成 HTML，它还是被有意地设计为可生成非 HTML 格式，如纯文本。 一些其它的模板语言是基于 XML 的，将所有的模板逻辑置于 XML 标签与属性之中，而 Django 有意地避开了这种限制。 强制要求使用有效 XML 编写模板将会引发大量的人为错误和难以理解的错误信息，而且使用 XML 引擎解析模板也会导致令人无法容忍的模板处理开销。</p><p class="cn" id="cn275"><em>假定设计师精通 HTML 编码</em> 。模板系统的设计意图并不是为了让模板一定能够很好地显示在 Dreamweaver 这样的所见即所得编辑器中。 这种限制过于苛刻，而且会使得语法不能像目前这样的完美。 Django 要求模板创作人员对直接编辑 HTML 非常熟悉。</p><p class="cn" id="cn276"><em>假定设计师不是 Python 程序员</em> 。模板系统开发人员认为：模板通常由设计师而非程序员来编写，因此不应被假定拥有Python开发知识。</p><p class="cn" id="cn277">当然，系统同样也特意地提供了对那些 <em>由</em> Python 程序员进行模板制作的小型团队的支持。 它提供了一种工作模式，允许通过编写原生 Python 代码进行系统语法拓展。 （详见第十章）</p><p class="cn" id="cn278"><em>目标并不是要发明一种编程语言</em> 。目标是恰到好处地提供如分支和循环这一类编程式功能，这是进行与表现相关判断的基础。</p></blockquote></div><div class="section" id="id17"><span id="cn279"></span><h2 class="cn" id="cn279">在视图中使用模板</h2><p class="cn" id="cn280">在学习了模板系统的基础之后，现在让我们使用相关知识来创建视图。 重新打开我们在前一章在 <tt class="docutils literal"><span class="pre">mysite.views</span></tt> 中创建的 <tt class="docutils literal"><span class="pre">current_datetime</span></tt> 视图。 以下是其内容：</p><pre class="cn literal-block" id="cn282">from django.http import HttpResponseimport datetimedef current_datetime(request):now = datetime.datetime.now()html = &quot;&lt;html&gt;&lt;body&gt;It is now %s.&lt;/body&gt;&lt;/html&gt;&quot; % nowreturn HttpResponse(html)</pre><p class="cn" id="cn283">让我们用 Django 模板系统来修改该视图。 第一步，你可能已经想到了要做下面这样的修改：</p><pre class="cn literal-block" id="cn285">from django.template import Template, Contextfrom django.http import HttpResponseimport datetimedef current_datetime(request):now = datetime.datetime.now()t = Template(&quot;&lt;html&gt;&lt;body&gt;It is now {{ current_date }}.&lt;/body&gt;&lt;/html&gt;&quot;)html = t.render(Context({'current_date': now}))return HttpResponse(html)</pre><p class="cn" id="cn286">没错，它确实使用了模板系统，但是并没有解决我们在本章开头所指出的问题。 也就是说，模板仍然嵌入在Python代码里，并未真正的实现数据与表现的分离。 让我们将模板置于一个 <em>单独的文件</em> 中，并且让视图加载该文件来解决此问题。</p><p class="cn" id="cn287">你可能首先考虑把模板保存在文件系统的某个位置并用 Python 内建的文件操作函数来读取文件内容。假设文件保存在 <tt class="docutils literal"><span class="pre">/home/djangouser/templates/mytemplate.html</span></tt> 中的话，代码就会像下面这样:</p><pre class="cn literal-block" id="cn289">from django.template import Template, Contextfrom django.http import HttpResponseimport datetimedef current_datetime(request):now = datetime.datetime.now()# Simple way of using templates from the filesystem.# This is BAD because it doesn't account for missing files!fp = open('/home/djangouser/templates/mytemplate.html')t = Template(fp.read())fp.close()html = t.render(Context({'current_date': now}))return HttpResponse(html)</pre><p class="cn" id="cn290">然而，基于以下几个原因，该方法还算不上简洁：</p><ul class="simple"><li class="cn" id="cn291"><p class="first cn" id="cn291">它没有对文件丢失的情况做出处理。 如果文件 <tt class="docutils literal"><span class="pre">mytemplate.html</span></tt> 不存在或者不可读， <tt class="docutils literal"><span class="pre">open()</span></tt> 函数调用将会引发 <tt class="docutils literal"><span class="pre">IOError</span></tt> 异常。</p></li></ul><ul class="simple"><li class="cn" id="cn292"><p class="first cn" id="cn292">这里对模板文件的位置进行了硬编码。 如果你在每个视图函数都用该技术，就要不断复制这些模板的位置。 更不用说还要带来大量的输入工作！</p></li></ul><ul class="simple"><li class="cn" id="cn293"><p class="first cn" id="cn293">它包含了大量令人生厌的重复代码。 与其在每次加载模板时都调用 <tt class="docutils literal"><span class="pre">open()</span></tt> 、 <tt class="docutils literal"><span class="pre">fp.read()</span></tt> 和 <tt class="docutils literal"><span class="pre">fp.close()</span></tt> ，还不如做出更佳选择。</p></li></ul><p class="cn" id="cn294">为了解决这些问题，我们采用了 <em>模板自加载</em> 跟 <em>模板目录</em> 的技巧.</p></div><div class="section" id="id18"><span id="cn295"></span><h2 class="cn" id="cn295">模板加载</h2><p class="cn" id="cn296">为了减少模板加载调用过程及模板本身的冗余代码，Django 提供了一种使用方便且功能强大的 API ，用于从磁盘中加载模板，</p><p class="cn" id="cn297">要使用此模板加载API，首先你必须将模板的保存位置告诉框架。 设置的保存文件就是我们前一章节讲述<tt class="docutils literal"><span class="pre">ROOT_URLCONF</span></tt>配置的时候提到的<tt class="docutils literal"><span class="pre">settings.py</span></tt>。</p><p class="cn" id="cn298">如果你是一步步跟随我们学习过来的，马上打开你的<tt class="docutils literal"><span class="pre">settings.py</span></tt>配置文件，找到<tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt>这项设置吧。 它的默认设置是一个空元组（tuple），加上一些自动生成的注释。</p><pre class="cn literal-block" id="cn300">TEMPLATE_DIRS = (# Put strings here, like &quot;/home/html/django_templates&quot; or &quot;C:/www/django/templates&quot;.# Always use forward slashes, even on Windows.# Don't forget to use absolute paths, not relative paths.)</pre><p class="cn" id="cn301">该设置告诉 Django 的模板加载机制在哪里查找模板。 选择一个目录用于存放模板并将其添加到 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 中：</p><pre class="cn literal-block" id="cn303">TEMPLATE_DIRS = ('/home/django/mysite/templates',)</pre><p class="cn" id="cn304">下面是一些注意事项：</p><blockquote><p class="cn" id="cn305">你可以任意指定想要的目录，只要运行 Web 服务器的用户可以读取该目录的子目录和模板文件。 如果实在想不出合适的位置来放置模板，我们建议在 Django 项目中创建一个 <tt class="docutils literal"><span class="pre">templates</span></tt> 目录（也就是说，如果你一直都按本书的范例操作的话，在第二章创建的 <tt class="docutils literal"><span class="pre">mysite</span></tt> 目录中）。</p><p class="cn" id="cn306">如果你的 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt>只包含一个目录，别忘了在该目录后加上个逗号。</p><p class="cn" id="cn307">Bad:</p></blockquote><pre class="cn literal-block" id="cn309"># Missing comma!TEMPLATE_DIRS = ('/home/django/mysite/templates')</pre><blockquote><p class="cn" id="cn310">Good:</p></blockquote><pre class="cn literal-block" id="cn312"># Comma correctly in place.TEMPLATE_DIRS = ('/home/django/mysite/templates',)</pre><blockquote><p class="cn" id="cn313">Python 要求单元素元组中必须使用逗号，以此消除与圆括号表达式之间的歧义。 这是新手常犯的错误。</p><p class="cn" id="cn314">如果使用的是 Windows 平台，请包含驱动器符号并使用Unix风格的斜杠（/）而不是反斜杠（）,就像下面这样：</p></blockquote><pre class="cn literal-block" id="cn316">TEMPLATE_DIRS = ('C:/www/django/templates',)</pre><blockquote><p class="cn" id="cn317">最省事的方式是使用绝对路径（即从文件系统根目录开始的目录路径）。 如果想要更灵活一点并减少一些负面干扰，可利用 Django 配置文件就是 Python 代码这一点来动态构建 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 的内容，如： 例如：</p></blockquote><pre class="cn literal-block" id="cn319">import os.pathTEMPLATE_DIRS = (os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),)</pre><blockquote><p class="cn" id="cn320">这个例子使用了神奇的 Python 内部变量 <tt class="docutils literal"><span class="pre">__file__</span></tt> ，该变量被自动设置为代码所在的 Python 模块文件名。 `` os.path.dirname(__file__)`` 将会获取自身所在的文件，即<tt class="docutils literal"><span class="pre">settings.py</span></tt> 所在的目录，然后由<tt class="docutils literal"><span class="pre">os.path.join</span></tt> 这个方法将这目录与 <tt class="docutils literal"><span class="pre">templates</span></tt> 进行连接。如果在windows下，它会智能地选择正确的后向斜杠&#8221;&#8220;进行连接，而不是前向斜杠&#8221;/&#8221;。</p><p class="cn" id="cn321">在这里我们面对的是动态语言python代码，我需要提醒你的是，不要在你的设置文件里写入错误的代码，这很重要。 如果你在这里引入了语法错误，或运行错误，你的Django-powered站点将很可能就要被崩溃掉。</p></blockquote><p class="cn" id="cn322">完成 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 设置后，下一步就是修改视图代码，让它使用 Django 模板加载功能而不是对模板路径硬编码。 返回 <tt class="docutils literal"><span class="pre">current_datetime</span></tt> 视图，进行如下修改：</p><pre class="cn literal-block" id="cn324">from django.template.loader import get_templatefrom django.template import Contextfrom django.http import HttpResponseimport datetimedef current_datetime(request):now = datetime.datetime.now()t = get_template('current_datetime.html')html = t.render(Context({'current_date': now}))return HttpResponse(html)</pre><p class="cn" id="cn325">此范例中，我们使用了函数 <tt class="docutils literal"><span class="pre">django.template.loader.get_template()</span></tt> ，而不是手动从文件系统加载模板。 该 <tt class="docutils literal"><span class="pre">get_template()</span></tt> 函数以模板名称为参数，在文件系统中找出模块的位置，打开文件并返回一个编译好的 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象。</p><p class="cn" id="cn326">在这个例子里，我们选择的模板文件是<tt class="docutils literal"><span class="pre">current_datetime.html</span></tt>，但这个与<tt class="docutils literal"><span class="pre">.html</span></tt>后缀没有直接的联系。 你可以选择任意后缀的任意文件，只要是符合逻辑的都行。甚至选择没有后缀的文件也不会有问题。</p><p class="cn" id="cn327">要确定某个模板文件在你的系统里的位置， <tt class="docutils literal"><span class="pre">get_template()</span></tt>方法会自动为你连接已经设置的 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt>目录和你传入该法的模板名称参数。比如，你的 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt>目录设置为<tt class="docutils literal"><span class="pre">'/home/django/mysite/templates'</span></tt>，上面的 <tt class="docutils literal"><span class="pre">get_template()</span></tt>调用就会为你找到 <tt class="docutils literal"><span class="pre">/home/django/mysite/templates/current_datetime.html</span></tt> 这样一个位置。</p><p class="cn" id="cn328">如果 <tt class="docutils literal"><span class="pre">get_template()</span></tt> 找不到给定名称的模板，将会引发一个 <tt class="docutils literal"><span class="pre">TemplateDoesNotExist</span></tt> 异常。 要了解究竟会发生什么，让我们按照第三章内容，在 Django 项目目录中运行 <tt class="docutils literal"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">runserver</span></tt> 命令，再次启动Django开发服务器。 接着，告诉你的浏览器，使其定位到指定页面以激活<tt class="docutils literal"><span class="pre">current_datetime</span></tt>视图（如 <tt class="docutils literal"><span class="pre">http://127.0.0.1:8000/time/</span></tt> ）。假设你的<tt class="docutils literal"><span class="pre">DEBUG</span></tt>项设置为 <tt class="docutils literal"><span class="pre">True</span></tt>，而你有没有建立<tt class="docutils literal"><span class="pre">current_datetime.html</span></tt> 这个模板文件，你会看到Django的错误提示网页，告诉你发生了<tt class="docutils literal"><span class="pre">TemplateDoesNotExist</span></tt> 错误。</p><img alt="Screenshot of a TemplateDoesNotExist error." src="http://new-media.djangobook.com/content/en/1.0/chapter04.htmlmissing_template.png" /><p class="cn" id="cn307">图 4-1: 模板文件无法找到时，将会发送提示错误的网页给用户。</p><p class="cn" id="cn331">该页面与我们在第三章解释过的错误页面相似，只不过多了一块调试信息区： 模板加载器事后检查区。 该区域显示 Django 要加载哪个模板、每次尝试出错的原因（如：文件不存在等）。 当你尝试调试模板加载错误时，这些信息会非常有帮助。</p><p class="cn" id="cn332">接下来，在模板目录中创建包括以下模板代码 <tt class="docutils literal"><span class="pre">current_datetime.html</span></tt> 文件：</p><pre class="cn literal-block" id="cn334">&lt;html&gt;&lt;body&gt;It is now {{ current_date }}.&lt;/body&gt;&lt;/html&gt;</pre><p class="cn" id="cn335">在网页浏览器中刷新该页，你将会看到完整解析后的页面。</p><div class="section" id="render-to-response"><span id="cn336"></span><h3 class="cn" id="cn336">render_to_response()</h3><p class="cn" id="cn337">我们已经告诉你如何载入一个模板文件，然后用 <tt class="docutils literal"><span class="pre">Context</span></tt>渲染它，最后返回这个处理好的<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>对象给用户。 我们已经优化了方案，使用 <tt class="docutils literal"><span class="pre">get_template()</span></tt> 方法代替繁杂的用代码来处理模板及其路径的工作。 但这仍然需要一定量的时间来敲出这些简化的代码。 这是一个普遍存在的重复苦力劳动。Django为此提供了一个捷径，让你一次性地载入某个模板文件，渲染它，然后将此作为<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>返回。</p><p class="cn" id="cn338">该捷径就是位于 <tt class="docutils literal"><span class="pre">django.shortcuts</span></tt> 模块中名为 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 的函数。大多数情况下，你会使用<a href="#id19"><span class="problematic" id="id20">``</span></a><tt class="docutils literal"><span class="pre">\</span> <span class="pre">``</span></tt><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">``</span></a>对象，除非你的老板以代码行数来衡量你的工作。</p><div class="system-message" id="id19"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 1736); <em><a href="#id20">backlink</a></em></p><p class="cn" id="cn338">Inline literal start-string without end-string.</p></div><div class="system-message" id="id21"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 1736); <em><a href="#id22">backlink</a></em></p><p class="cn" id="cn338">Inline literal start-string without end-string.</p></div><div class="system-message" id="id23"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 1736); <em><a href="#id24">backlink</a></em></p><p class="cn" id="cn338">Inline literal start-string without end-string.</p></div><p class="cn" id="cn339">下面就是使用 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 重新编写过的 <tt class="docutils literal"><span class="pre">current_datetime</span></tt> 范例。</p><pre class="cn literal-block" id="cn341">from django.shortcuts import render_to_responseimport datetimedef current_datetime(request):now = datetime.datetime.now()return render_to_response('current_datetime.html', {'current_date': now})</pre><p class="cn" id="cn342">大变样了！ 让我们逐句看看代码发生的变化：</p><ul class="simple"><li class="cn" id="cn343"><p class="first cn" id="cn343">我们不再需要导入 <tt class="docutils literal"><span class="pre">get_template</span></tt> 、 <tt class="docutils literal"><span class="pre">Template</span></tt> 、 <tt class="docutils literal"><span class="pre">Context</span></tt> 和 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 。相反，我们导入 <tt class="docutils literal"><span class="pre">django.shortcuts.render_to_response</span></tt> 。 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">datetime</span></tt> 继续保留.</p></li></ul><ul class="simple"><li class="cn" id="cn344"><p class="first cn" id="cn344">在 <tt class="docutils literal"><span class="pre">current_datetime</span></tt> 函数中，我们仍然进行 <tt class="docutils literal"><span class="pre">now</span></tt> 计算，但模板加载、上下文创建、模板解析和 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 创建工作均在对 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 的调用中完成了。 由于 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 返回 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 对象，因此我们仅需在视图中 <tt class="docutils literal"><span class="pre">return</span></tt> 该值。</p></li></ul><p class="cn" id="cn345"><tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 的第一个参数必须是要使用的模板名称。 如果要给定第二个参数，那么该参数必须是为该模板创建 <tt class="docutils literal"><span class="pre">Context</span></tt> 时所使用的字典。 如果不提供第二个参数， <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 使用一个空字典。</p></div><div class="section" id="locals"><span id="cn346"></span><h3 class="cn" id="cn346">locals() 技巧</h3><p class="cn" id="cn347">思考一下我们对 <tt class="docutils literal"><span class="pre">current_datetime</span></tt> 的最后一次赋值:</p><pre class="cn literal-block" id="cn349">def current_datetime(request):now = datetime.datetime.now()return render_to_response('current_datetime.html', {'current_date': now})</pre><p class="cn" id="cn350">很多时候，就像在这个范例中那样，你发现自己一直在计算某个变量，保存结果到变量中（比如前面代码中的 now ），然后将这些变量发送给模板。 尤其喜欢偷懒的程序员应该注意到了，不断地为临时变量<em>和</em>临时模板命名有那么一点点多余。不仅多余，而且需要额外的输入。</p><p class="cn" id="cn351">如果你是个喜欢偷懒的程序员并想让代码看起来更加简明，可以利用 Python 的内建函数 <tt class="docutils literal"><span class="pre">locals()</span></tt> 。它返回的字典对所有局部变量的名称与值进行映射。 因此，前面的视图可以重写成下面这个样子：</p><pre class="cn literal-block" id="cn353">def current_datetime(request):current_date = datetime.datetime.now()return render_to_response('current_datetime.html', locals())</pre><p class="cn" id="cn354">在此，我们没有像之前那样手工指定 context 字典，而是传入了 <tt class="docutils literal"><span class="pre">locals()</span></tt> 的值，它囊括了函数执行到该时间点时所定义的一切变量。 因此，我们将 <tt class="docutils literal"><span class="pre">now</span></tt> 变量重命名为 <tt class="docutils literal"><span class="pre">current_date</span></tt> ，因为那才是模板所预期的变量名称。 在本例中， <tt class="docutils literal"><span class="pre">locals()</span></tt> 并没有带来多 <em>大</em> 的改进，但是如果有多个模板变量要界定而你又想偷懒，这种技术可以减少一些键盘输入。</p><p class="cn" id="cn355">使用 <tt class="docutils literal"><span class="pre">locals()</span></tt> 时要注意是它将包括 <em>所有</em> 的局部变量，它们可能比你想让模板访问的要多。 在前例中， <tt class="docutils literal"><span class="pre">locals()</span></tt> 还包含了 <tt class="docutils literal"><span class="pre">request</span></tt> 。对此如何取舍取决你的应用程序。</p></div><div class="section" id="get-template"><span id="cn356"></span><h3 class="cn" id="cn356">get_template()中使用子目录</h3><p class="cn" id="cn357">把所有的模板都存放在一个目录下可能会让事情变得难以掌控。 你可能会考虑把模板存放在你模板目录的子目录中，这非常好。 事实上，我们推荐这样做；一些Django的高级特性（例如将在第十一章讲到的通用视图系统）的缺省约定就是期望使用这种模板布局。</p><p class="cn" id="cn358">把模板存放于模板目录的子目录中是件很轻松的事情。 只需在调用 <tt class="docutils literal"><span class="pre">get_template()</span></tt> 时，把子目录名和一条斜杠添加到模板名称之前，如：</p><pre class="cn literal-block" id="cn360">t = get_template('dateapp/current_datetime.html')</pre><p class="cn" id="cn361">由于 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 只是对 <tt class="docutils literal"><span class="pre">get_template()</span></tt> 的简单封装， 你可以对 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 的第一个参数做相同处理。</p><pre class="cn literal-block" id="cn363">return render_to_response('dateapp/current_datetime.html', {'current_date': now})</pre><p class="cn" id="cn364">对子目录树的深度没有限制，你想要多少层都可以。 只要你喜欢，用多少层的子目录都无所谓。</p><p class="cn" id="cn365">注意</p><p class="cn" id="cn366">Windows用户必须使用斜杠而不是反斜杠。<tt class="docutils literal"><span class="pre">get_template()</span></tt> 假定的是 Unix 风格的文件名符号约定。</p></div><div class="section" id="include"><span id="cn367"></span><h3 class="cn" id="cn367"><tt class="docutils literal"><span class="pre">include</span></tt> 模板标签</h3><p class="cn" id="cn368">在讲解了模板加载机制之后，我们再介绍一个利用该机制的内建模板标签： <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">include</span> <span class="pre">%}</span></tt> 。该标签允许在（模板中）包含其它的模板的内容。 标签的参数是所要包含的模板名称，可以是一个变量，也可以是用单/双引号硬编码的字符串。 每当在多个模板中出现相同的代码时，就应该考虑是否要使用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">include</span> <span class="pre">%}</span></tt> 来减少重复。</p><p class="cn" id="cn369">下面这两个例子都包含了 <tt class="docutils literal"><span class="pre">nav.html</span></tt> 模板。这两个例子是等价的，它们证明单/双引号都是允许的。</p><pre class="cn literal-block" id="cn371">{% include 'nav.html' %}{% include &quot;nav.html&quot; %}</pre><p class="cn" id="cn372">下面的例子包含了 <tt class="docutils literal"><span class="pre">includes/nav.html</span></tt> 模板的内容:</p><pre class="cn literal-block" id="cn374">{% include 'includes/nav.html' %}</pre><p class="cn" id="cn375">下面的例子包含了以变量 <tt class="docutils literal"><span class="pre">template_name</span></tt> 的值为名称的模板内容：</p><pre class="cn literal-block" id="cn377">{% include template_name %}</pre><p class="cn" id="cn378">和在 <tt class="docutils literal"><span class="pre">get_template()</span></tt> 中一样， 对模板的文件名进行判断时会在所调取的模板名称之前加上来自 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 的模板目录。</p><p class="cn" id="cn379">所包含的模板执行时的 context 和包含它们的模板是一样的。举例说，考虑下面两个模板文件：</p><pre class="cn literal-block" id="cn381"># mypage.html&lt;html&gt;&lt;body&gt;{% include &quot;includes/nav.html&quot; %}&lt;h1&gt;{{ title }}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;# includes/nav.html&lt;div id=&quot;nav&quot;&gt;You are in: {{ current_section }}&lt;/div&gt;</pre><p class="cn" id="cn382">如果你用一个包含 <tt class="docutils literal"><span class="pre">current_section</span></tt>的上下文去渲染 <tt class="docutils literal"><span class="pre">mypage.html</span></tt>这个模板文件，这个变量将存在于它所包含（include）的模板里，就像你想象的那样。</p><p class="cn" id="cn383">如果<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">include</span> <span class="pre">%}</span></tt>标签指定的模板没找到，Django将会在下面两个处理方法中选择一个：</p><ul class="simple"><li class="cn" id="cn384"><p class="first cn" id="cn384">如果 <tt class="docutils literal"><span class="pre">DEBUG</span></tt> 设置为 <tt class="docutils literal"><span class="pre">True</span></tt> ，你将会在 Django 错误信息页面看到 <tt class="docutils literal"><span class="pre">TemplateDoesNotExist</span></tt> 异常。</p></li></ul><ul class="simple"><li class="cn" id="cn385"><p class="first cn" id="cn385">如果 <tt class="docutils literal"><span class="pre">DEBUG</span></tt> 设置为 <tt class="docutils literal"><span class="pre">False</span></tt> ，该标签不会引发错误信息，在标签位置不显示任何东西。</p></li></ul></div></div><div class="section" id="id25"><span id="cn386"></span><h2 class="cn" id="cn386">模板继承</h2><p class="cn" id="cn387">到目前为止，我们的模板范例都只是些零星的 HTML 片段，但在实际应用中，你将用 Django 模板系统来创建整个 HTML 页面。 这就带来一个常见的 Web 开发问题： 在整个网站中，如何减少共用页面区域（比如站点导航）所引起的重复和冗余代码？</p><p class="cn" id="cn388">解决该问题的传统做法是使用 <em>服务器端的 includes</em> ，你可以在 HTML 页面中使用该指令将一个网页嵌入到另一个中。 事实上， Django 通过刚才讲述的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">include</span> <span class="pre">%}</span></tt> 支持了这种方法。 但是用 Django 解决此类问题的首选方法是使用更加优雅的策略—— <em>模板继承</em> 。</p><p class="cn" id="cn389">本质上来说，模板继承就是先构造一个基础框架模板，而后在其子模板中对它所包含站点公用部分和定义块进行重载。</p><p class="cn" id="cn390">让我们通过修改 <tt class="docutils literal"><span class="pre">current_datetime.html</span></tt> 文件，为 <tt class="docutils literal"><span class="pre">current_datetime</span></tt> 创建一个更加完整的模板来体会一下这种做法：</p><pre class="cn literal-block" id="cn392">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;The current time&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My helpful timestamp site&lt;/h1&gt;&lt;p&gt;It is now {{ current_date }}.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Thanks for visiting my site.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><p class="cn" id="cn393">这看起来很棒，但如果我们要为第三章的 <tt class="docutils literal"><span class="pre">hours_ahead</span></tt> 视图创建另一个模板会发生什么事情呢？</p><pre class="cn literal-block" id="cn395">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;Future time&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My helpful timestamp site&lt;/h1&gt;&lt;p&gt;In {{ hour_offset }} hour(s), it will be {{ next_time }}.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Thanks for visiting my site.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><p class="cn" id="cn396">很明显，我们刚才重复了大量的 HTML 代码。 想象一下，如果有一个更典型的网站，它有导航条、样式表，可能还有一些 JavaScript 代码，事情必将以向每个模板填充各种冗余的 HTML 而告终。</p><p class="cn" id="cn397">解决这个问题的服务器端 include 方案是找出两个模板中的共同部分，将其保存为不同的模板片段，然后在每个模板中进行 include。 也许你会把模板头部的一些代码保存为 <tt class="docutils literal"><span class="pre">header.html</span></tt> 文件：</p><pre class="cn literal-block" id="cn399">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;</pre><p class="cn" id="cn400">你可能会把底部保存到文件 <tt class="docutils literal"><span class="pre">footer.html</span></tt> :</p><pre class="cn literal-block" id="cn402">&lt;hr&gt;&lt;p&gt;Thanks for visiting my site.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><p class="cn" id="cn403">对基于 include 的策略，头部和底部的包含很简单。 麻烦的是中间部分。 在此范例中，每个页面都有一个 <tt class="docutils literal"><span class="pre">&lt;h1&gt;My</span> <span class="pre">helpful</span> <span class="pre">timestamp</span> <span class="pre">site&lt;/h1&gt;</span></tt> 标题，但是这个标题不能放在 <tt class="docutils literal"><span class="pre">header.html</span></tt> 中，因为每个页面的 <tt class="docutils literal"><span class="pre">&lt;title&gt;</span></tt> 是不同的。 如果我们将 <tt class="docutils literal"><span class="pre">&lt;h1&gt;</span></tt> 包含在头部，我们就不得不包含 <tt class="docutils literal"><span class="pre">&lt;title&gt;</span></tt> ，但这样又不允许在每个页面对它进行定制。 何去何从呢？</p><p class="cn" id="cn404">Django 的模板继承系统解决了这些问题。 你可以将其视为服务器端 include 的逆向思维版本。 你可以对那些 <em>不同</em> 的代码段进行定义，而不是 <em>共同</em> 代码段。</p><p class="cn" id="cn405">第一步是定义 <em>基础模板</em> ， 该框架之后将由 <em>子模板</em> 所继承。 以下是我们目前所讲述范例的基础模板：</p><pre class="cn literal-block" id="cn407">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My helpful timestamp site&lt;/h1&gt;{% block content %}{% endblock %}{% block footer %}&lt;hr&gt;&lt;p&gt;Thanks for visiting my site.&lt;/p&gt;{% endblock %}&lt;/body&gt;&lt;/html&gt;</pre><p class="cn" id="cn408">这个叫做 <tt class="docutils literal"><span class="pre">base.html</span></tt> 的模板定义了一个简单的 HTML 框架文档，我们将在本站点的所有页面中使用。 子模板的作用就是重载、添加或保留那些块的内容。 （如果你一直按顺序学习到这里，保存这个文件到你的template目录下，命名为 <tt class="docutils literal"><span class="pre">base.html</span></tt> .）</p><p class="cn" id="cn409">我们使用一个以前已经见过的模板标签： <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 。 所有的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 标签告诉模板引擎，子模板可以重载这些部分。每个<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt>标签所要做的是告诉模板引擎，该模板下的这一块内容将有可能被子模板覆盖。</p><p class="cn" id="cn410">现在我们已经有了一个基本模板，我们可以修改 <tt class="docutils literal"><span class="pre">current_datetime.html</span></tt> 模板来 使用它：</p><pre class="cn literal-block" id="cn412">{% extends &quot;base.html&quot; %}{% block title %}The current time{% endblock %}{% block content %}&lt;p&gt;It is now {{ current_date }}.&lt;/p&gt;{% endblock %}</pre><p class="cn" id="cn413">再为 <tt class="docutils literal"><span class="pre">hours_ahead</span></tt> 视图创建一个模板，看起来是这样的：</p><pre class="cn literal-block" id="cn415">{% extends &quot;base.html&quot; %}{% block title %}Future time{% endblock %}{% block content %}&lt;p&gt;In {{ hour_offset }} hour(s), it will be {{ next_time }}.&lt;/p&gt;{% endblock %}</pre><p class="cn" id="cn416">看起来很漂亮是不是？ 每个模板只包含对自己而言 <em>独一无二</em> 的代码。 无需多余的部分。 如果想进行站点级的设计修改，仅需修改 <tt class="docutils literal"><span class="pre">base.html</span></tt> ，所有其它模板会立即反映出所作修改。</p><p class="cn" id="cn417">以下是其工作方式。 在加载 <tt class="docutils literal"><span class="pre">current_datetime.html</span></tt> 模板时，模板引擎发现了 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">extends</span> <span class="pre">%}</span></tt> 标签， 注意到该模板是一个子模板。模板引擎立即装载其父模板，即本例中的 <tt class="docutils literal"><span class="pre">base.html</span></tt> 。</p><p class="cn" id="cn418">此时，模板引擎注意到 <tt class="docutils literal"><span class="pre">base.html</span></tt> 中的三个 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 标签，并用子模板的内容替换这些 block 。因此，引擎将会使用我们在 <tt class="docutils literal"><span class="pre">{</span> <span class="pre">block</span> <span class="pre">title</span> <span class="pre">%}</span></tt> 中定义的标题，对 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">content</span> <span class="pre">%}</span></tt> 也是如此。 所以，网页标题一块将由 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">title</span> <span class="pre">%}</span></tt>替换，同样地，网页的内容一块将由 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span><span class="pre">content</span> <span class="pre">%}</span></tt>替换。</p><p class="cn" id="cn419">注意由于子模板并没有定义 <tt class="docutils literal"><span class="pre">footer</span></tt> 块，模板系统将使用在父模板中定义的值。 父模板 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 标签中的内容总是被当作一条退路。</p><p class="cn" id="cn420">继承并不会影响到模板的上下文。 换句话说，任何处在继承树上的模板都可以访问到你传到模板中的每一个模板变量。</p><p class="cn" id="cn421">你可以根据需要使用任意多的继承次数。 使用继承的一种常见方式是下面的三层法：</p><ol class="arabic simple"><li class="cn" id="cn422"><p class="first cn" id="cn422">创建 <tt class="docutils literal"><span class="pre">base.html</span></tt> 模板，在其中定义站点的主要外观感受。 这些都是不常修改甚至从不修改的部分。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn423"><p class="first cn" id="cn423">为网站的每个区域创建 <tt class="docutils literal"><span class="pre">base_SECTION.html</span></tt> 模板(例如, <tt class="docutils literal"><span class="pre">base_photos.html</span></tt> 和 <tt class="docutils literal"><span class="pre">base_forum.html</span></tt> )。这些模板对 <tt class="docutils literal"><span class="pre">base.html</span></tt> 进行拓展，并包含区域特定的风格与设计。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn424"><p class="first cn" id="cn424">为每种类型的页面创建独立的模板，例如论坛页面或者图片库。 这些模板拓展相应的区域模板。</p></li></ol><p class="cn" id="cn425">这个方法可最大限度地重用代码，并使得向公共区域（如区域级的导航）添加内容成为一件轻松的工作。</p><p class="cn" id="cn426">以下是使用模板继承的一些诀窍：</p><ul class="simple"><li class="cn" id="cn427"><p class="first cn" id="cn427">如果在模板中使用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">extends</span> <span class="pre">%}</span></tt> ，必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作用。</p></li></ul><ul class="simple"><li class="cn" id="cn428"><p class="first cn" id="cn428">一般来说，基础模板中的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 标签越多越好。记住，子模板不必定义父模板中所有的代码块，因此你可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。 俗话说，钩子越多越好。</p></li></ul><ul class="simple"><li class="cn" id="cn429"><p class="first cn" id="cn429">如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 中。</p></li></ul><ul class="simple"><li class="cn" id="cn430"><p class="first cn" id="cn430">如果你需要访问父模板中的块的内容，使用 <tt class="docutils literal"><span class="pre">{{</span><span class="pre">block.super</span> <span class="pre">}}</span></tt>这个标签吧，这一个魔法变量将会表现出父模板中的内容。 如果只想在上级代码块基础上添加内容，而不是全部重载，该变量就显得非常有用了。</p></li></ul><ul class="simple"><li class="cn" id="cn431"><p class="first cn" id="cn431">不允许在同一个模板中定义多个同名的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">block</span> <span class="pre">%}</span></tt> 。 存在这样的限制是因为block 标签的工作方式是双向的。 也就是说，block 标签不仅挖了一个要填的坑，也定义了在<em>父</em>模板中这个坑所填充的内容。如果模板中出现了两个相同名称的 <em>{% block %}</em> 标签，父模板将无从得知要使用哪个块的内容。</p></li></ul><ul class="simple"><li class="cn" id="cn432"><p class="first cn" id="cn432"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">extends</span> <span class="pre">%}</span></tt> 对所传入模板名称使用的加载方法和 <tt class="docutils literal"><span class="pre">get_template()</span></tt> 相同。 也就是说，会将模板名称被添加到 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 设置之后。</p></li></ul><ul class="simple"><li class="cn" id="cn433"><p class="first cn" id="cn433">多数情况下， <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">extends</span> <span class="pre">%}</span></tt> 的参数应该是字符串，但是如果直到运行时方能确定父模板名，这个参数也可以是个变量。 这使得你能够实现一些很酷的动态功能。</p></li></ul></div><div class="section" id="id26"><span id="cn434"></span><h2 class="cn" id="cn434">下一章</h2><p class="cn" id="cn435">你现在已经掌握了模板系统的基本知识。 接下来呢？</p><p class="cn" id="cn436">时下大多数网站都是 <em>数据库驱动</em> 的：网站的内容都是存储在关系型数据库中。 这使得数据和逻辑能够彻底地分开（视图和模板也以同样方式对逻辑和显示进行了分隔。)</p><p class="cn" id="cn437">下一章将讲述如何与数据库打交道。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter03.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter05.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>