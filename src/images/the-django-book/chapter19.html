<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十九章： 国际化</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter18.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter20.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第十九章： 国际化</h1><p class="cn" id="cn1">Django诞生于美国中部堪萨斯的劳伦斯，距美国的地理中心不到40英里。 像大多数开源项目一样，Djano社区逐渐开始包括来自全球各地的许多参与者。 鉴于Django社区逐渐变的多样性，<em>国际化</em>和<em>本地化</em>逐渐变得很重要。 由于很多开发者对这些措辞比较困惑，所以我们将简明的定义一下它们。</p><ul class="simple"><li class="cn" id="cn2"><p class="first cn" id="cn2">国际化* 是指为了该软件在任何地区的潜在使用而进行程序设计的过程。 它包括了为将来翻译而标记的文本（比如用户界面要素和错误信息等）、日期和时间的抽象显示以便保证不同地区的标准得到遵循、为不同时区提供支持，并且一般确保代码中不会存在关于使用者所在地区的假设。 您会经常看到国际化被缩写为“I18N”(18表示Internationlization这个单词首字母I和结尾字母N之间的字母有18个)。</p></li></ul><ul class="simple"><li class="cn" id="cn3"><p class="first cn" id="cn3">本地化* 是指使一个国际化的程序为了在某个特定地区使用而进行实际翻译的过程。 有时，本地化缩写为 <em>L10N</em> 。</p></li></ul><p class="cn" id="cn4">Django本身是完全国际化了的，所有的字符串均因翻译所需而被标记，并且设定了与地域无关的显示控制值，如时间和日期。 Django是带着50个不同的本地化文件发行的。 即使您的母语不是英语，Django也很有可能已经被翻译为您的母语了。</p><p class="cn" id="cn5">这些本地化文件所使用的国际化框架同样也可以被用在您自己的代码和模板中。</p><p class="cn" id="cn6">您只需要添加少量的挂接代码到您的Python代码和模板中。 这些挂接代码被称为* 翻译字符串* 。它们告诉Django：如果这段文本的译文可用的话，它应被翻译为终端用户指定的语言。</p><p class="cn" id="cn7">Django会根据用户的语言偏好，在线地运用这些挂接指令去翻译Web应用程序。</p><p class="cn" id="cn8">本质上来说，Django做两件事情：</p><ul class="simple"><li class="cn" id="cn9"><p class="first cn" id="cn9">它让开发者和模板的作者指定他们的应用程序的哪些部分应该被翻译。</p></li></ul><ul class="simple"><li class="cn" id="cn10"><p class="first cn" id="cn10">Django根据用户的语言偏好来翻译Web应用程序。</p></li></ul><p class="cn" id="cn11">备注:</p><p class="cn" id="cn12">Django的翻译机制是使用 GNU <tt class="docutils literal"><span class="pre">gettext</span></tt> (<a class="reference external" href="http://www.gnu.org/software/gettext/">http://www.gnu.org/software/gettext/</a>)，具体为Python自带的标准模块 <tt class="docutils literal"><span class="pre">gettext</span></tt> 。</p><p class="cn" id="cn13">如果您不需要国际化:</p><p class="cn" id="cn14">Django的国际化挂接是默认开启的，这可能会给Django的运行增加一点点开销。 如果您不需要国际化支持，那么您可以在您的设置文件中设置 <tt class="docutils literal"><span class="pre">USE_I18N</span> <span class="pre">=</span> <span class="pre">False</span></tt> 。 如果 <tt class="docutils literal"><span class="pre">USE_I18N</span></tt> 被设为 False ，那么Django会进行一些优化，而不加载国际化支持机制。</p><p class="cn" id="cn15">您也可以从您的 <tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt> 设置中移除 <tt class="docutils literal"><span class="pre">'django.core.context_processors.i18n'</span></tt> 。</p><p class="cn" id="cn16">对你的Django应用进行国际化的三个步骤:</p><ol class="arabic simple"><li class="cn" id="cn17"><p class="first cn" id="cn17">第一步：在你的Python代码和模板中嵌入待翻译的字符串。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn18"><p class="first cn" id="cn18">第二步：把那些字符串翻译成你要支持的语言。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn19"><p class="first cn" id="cn19">第三步：在你的Django settings文件中激活本地中间件。</p></li></ol><p class="cn" id="cn20">我们将详细地对以上步骤逐一进行描述。</p><div class="section" id="id2"><span id="cn21"></span><h2 class="cn" id="cn21">1、如何指定待翻译字符串</h2><p class="cn" id="cn22">翻译字符串指定这段需要被翻译的文本。 这些字符串可以出现在您的Python代码和模板中。 而标记出这些翻译字符串则是您的责任；系统仅能翻译出它所知道的东西。</p><div class="section" id="python"><span id="cn23"></span><h3 class="cn" id="cn23">在Python 代码中</h3><div class="section" id="id3"><span id="cn24"></span><h4 class="cn" id="cn24">标准翻译</h4><p class="cn" id="cn25">使用函数 <tt class="docutils literal"><span class="pre">ugettext()</span></tt> 来指定一个翻译字符串。 作为惯例，使用短别名 <tt class="docutils literal"><span class="pre">_</span></tt> 来引入这个函数以节省键入时间.</p><p class="cn" id="cn26">在下面这个例子中，文本 <tt class="docutils literal"><span class="pre">&quot;Welcome</span> <span class="pre">to</span> <span class="pre">my</span> <span class="pre">site&quot;</span></tt> 被标记为待翻译字符串：</p><pre class="cn literal-block" id="cn28">from django.utils.translation import ugettext as _def my_view(request):output = _(&quot;Welcome to my site.&quot;)return HttpResponse(output)</pre><p class="cn" id="cn29">显然，你也可以不使用别名来编码。 下面这个例子和前面两个例子相同：</p><pre class="cn literal-block" id="cn31">from django.utils.translation import ugettextdef my_view(request):output = ugettext(&quot;Welcome to my site.&quot;)return HttpResponse(output)</pre><p class="cn" id="cn32">翻译字符串对于计算出来的值同样有效。 下面这个例子等同前面一种：</p><pre class="cn literal-block" id="cn34">def my_view(request):words = ['Welcome', 'to', 'my', 'site.']output = _(' '.join(words))return HttpResponse(output)</pre><p class="cn" id="cn35">翻译对变量也同样有效。 这里是一个同样的例子：</p><pre class="cn literal-block" id="cn37">def my_view(request):sentence = 'Welcome to my site.'output = _(sentence)return HttpResponse(output)</pre><p class="cn" id="cn38">（以上两个例子中，对于使用变量或计算值，需要注意的一点是Django的待翻译字符串检测工具， <tt class="docutils literal"><span class="pre">make-messages.py</span></tt> ，将不能找到这些字符串。 稍后，在<tt class="docutils literal"><span class="pre">makemessages</span></tt> 中会有更多讨论。）</p><p class="cn" id="cn39">你传递给 <tt class="docutils literal"><span class="pre">_()</span></tt> 或 <tt class="docutils literal"><span class="pre">gettext()</span></tt> 的字符串可以接受占位符，由Python标准命名字符串插入句法指定的。 例如：</p><pre class="cn literal-block" id="cn41">def my_view(request, m, d):output = _('Today is %(month)s %(day)s.') % {'month': m, 'day': d}return HttpResponse(output)</pre><p class="cn" id="cn42">这项技术使得特定语言的译文可以对这段文本进行重新排序。 比如，一段英语译文可能是 <tt class="docutils literal"><span class="pre">&quot;Today</span> <span class="pre">is</span> <span class="pre">November</span> <span class="pre">26.&quot;</span></tt> ，而一段西班牙语译文会是 <tt class="docutils literal"><span class="pre">&quot;Hoy</span> <span class="pre">es</span> <span class="pre">26</span> <span class="pre">de</span> <span class="pre">Noviembre.&quot;</span></tt> 使用占位符（月份和日期）交换它们的位置。</p><p class="cn" id="cn43">由于这个原因，无论何时当你有多于一个单一参数时，你应当使用命名字符串插入（例如： <tt class="docutils literal"><span class="pre">%(day)s</span></tt> ）来替代位置插入（例如： <tt class="docutils literal"><span class="pre">%s</span></tt> or <tt class="docutils literal"><span class="pre">%d</span></tt> ）。 如果你使用位置插入的话，翻译动作将不能重新排序占位符文本。</p></div><div class="section" id="id4"><span id="cn44"></span><h4 class="cn" id="cn44">标记字符串为不操作</h4><p class="cn" id="cn45">使用 <tt class="docutils literal"><span class="pre">django.utils.translation.gettext_noop()</span></tt> 函数来标记一个不需要立即翻译的字符串。 这个串会稍后从变量翻译。</p><p class="cn" id="cn46">使用这种方法的环境是，有字符串必须以原始语言的形式存储（如储存在数据库中的字符串）而在最后需要被翻译出来（如显示给用户时）。</p></div><div class="section" id="id5"><span id="cn47"></span><h4 class="cn" id="cn47">惰性翻译</h4><p class="cn" id="cn48">使用 <tt class="docutils literal"><span class="pre">django.utils.translation.gettext_lazy()</span></tt> 函数，使得其中的值只有在访问时才会被翻译，而不是在 <tt class="docutils literal"><span class="pre">gettext_lazy()</span></tt> 被调用时翻译。</p><p class="cn" id="cn49">例如：要翻译一个模型的 <tt class="docutils literal"><span class="pre">help_text</span></tt>，按以下进行：</p><pre class="cn literal-block" id="cn51">from django.utils.translation import ugettext_lazyclass MyThing(models.Model):name = models.CharField(help_text=ugettext_lazy('This is the help text'))</pre><p class="cn" id="cn52">在这个例子中， <tt class="docutils literal"><span class="pre">ugettext_lazy()</span></tt> 将字符串作为惰性参照存储，而不是实际翻译。 翻译工作将在字符串在字符串上下文中被用到时进行，比如在Django管理页面提交模板时。</p><p class="cn" id="cn53">在Python中，无论何处你要使用一个unicode 字符串（一个<tt class="docutils literal"><span class="pre">unicode</span></tt> 类型的对象），您都可以使用一个 <tt class="docutils literal"><span class="pre">ugettext_lazy()</span></tt> 调用的结果。 一个<tt class="docutils literal"><span class="pre">ugettext_lazy()</span></tt>对象并不知道如何把它自己转换成一个字节串。如果你尝试在一个需要字节串的地方使用它，事情将不会如你期待的那样。 同样，你也不能在一个字节串中使用一个 unicode 字符串。所以，这同常规的Python行为是一致的。 例如：</p><pre class="cn literal-block" id="cn55"># This is fine: putting a unicode proxy into a unicode string.u&quot;Hello %s&quot; % ugettext_lazy(&quot;people&quot;)# This will not work, since you cannot insert a unicode object# into a bytestring (nor can you insert our unicode proxy there)&quot;Hello %s&quot; % ugettext_lazy(&quot;people&quot;)</pre><p class="cn" id="cn56">如果你曾经见到到像<tt class="docutils literal"><span class="pre">&quot;hello&quot;</span></tt>这样的输出，你就可能在一个字节串中插入了<tt class="docutils literal"><span class="pre">ugettext_lazy()</span></tt>的结果。在您的代码中，那是一个漏洞。</p><p class="cn" id="cn57">如果觉得 <tt class="docutils literal"><span class="pre">gettext_lazy</span></tt> 太过冗长，可以用 <tt class="docutils literal"><span class="pre">_</span></tt> （下划线）作为别名，就像这样：</p><pre class="cn literal-block" id="cn59">from django.utils.translation import ugettext_lazy as _class MyThing(models.Model):name = models.CharField(help_text=_('This is the help text'))</pre><p class="cn" id="cn60">在Django模型中总是无一例外的使用惰性翻译。 为了翻译，字段名和表名应该被标记。（否则的话，在管理界面中它们将不会被翻译） 这意味着在<tt class="docutils literal"><span class="pre">Meta</span></tt>类中显式地编写<tt class="docutils literal"><span class="pre">verbose_nane</span></tt>和<tt class="docutils literal"><span class="pre">verbose_name_plural</span></tt>选项，而不是依赖于Django默认的<tt class="docutils literal"><span class="pre">verbose_name</span></tt>和<tt class="docutils literal"><span class="pre">verbose_name_plural</span></tt>（通过检查model的类名得到）。</p><pre class="cn literal-block" id="cn62">from django.utils.translation import ugettext_lazy as _class MyThing(models.Model):name = models.CharField(_('name'), help_text=_('This is the help text'))class Meta:verbose_name = _('my thing')verbose_name_plural = _('mythings')</pre></div><div class="section" id="id6"><span id="cn63"></span><h4 class="cn" id="cn63">复数的处理</h4><p class="cn" id="cn64">使用<tt class="docutils literal"><span class="pre">django.utils.translation.ungettext()</span></tt>来指定以复数形式表示的消息。 例如：</p><pre class="cn literal-block" id="cn66">from django.utils.translation import ungettextdef hello_world(request, count):page = ungettext('there is %(count)d object','there are %(count)d objects', count) % {'count': count,}return HttpResponse(page)</pre><p class="cn" id="cn67"><tt class="docutils literal"><span class="pre">ngettext</span></tt> 函数包括三个参数： 单数形式的翻译字符串，复数形式的翻译字符串，和对象的个数（将以 <tt class="docutils literal"><span class="pre">count</span></tt> 变量传递给需要翻译的语言）。</p></div></div><div class="section" id="id7"><span id="cn68"></span><h3 class="cn" id="cn68">模板代码</h3><p class="cn" id="cn69">Django模板使用两种模板标签，且语法格式与Python代码有些许不同。 为了使得模板访问到标签，需要将 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">i18n</span> <span class="pre">%}</span></tt> 放在模板最前面。</p><p class="cn" id="cn70">这个<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">trans</span> <span class="pre">%}</span></tt>模板标记翻译一个常量字符串 (括以单或双引号) 或 可变内容：</p><pre class="cn literal-block" id="cn72">&lt;title&gt;{% trans &quot;This is the title.&quot; %}&lt;/title&gt;&lt;title&gt;{% trans myvar %}&lt;/title&gt;</pre><p class="cn" id="cn73">如果有<tt class="docutils literal"><span class="pre">noop</span></tt> 选项，变量查询还是有效但翻译会跳过。 当空缺内容要求将来再翻译时，这很有用。</p><pre class="cn literal-block" id="cn75">&lt;title&gt;{% trans &quot;myvar&quot; noop %}&lt;/title&gt;</pre><p class="cn" id="cn76">在一个带 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">trans</span><span class="pre">%}</span></tt> 的字符串中，混进一个模板变量是不可能的。如果你的译文要求字符串带有变量(占位符placeholders)，请使用<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">blocktrans</span> <span class="pre">%}</span></tt> ：</p><pre class="cn literal-block" id="cn78">{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}</pre><p class="cn" id="cn79">使用模板过滤器来翻译一个模板表达式，需要在翻译的这段文本中将表达式绑定到一个本地变量中：</p><pre class="cn literal-block" id="cn81">{% blocktrans with value|filter as myvar %}This will have {{ myvar }} inside.{% endblocktrans %}</pre><p class="cn" id="cn82">如果需要在 <tt class="docutils literal"><span class="pre">blocktrans</span></tt> 标签内绑定多个表达式，可以用 <tt class="docutils literal"><span class="pre">and</span></tt> 来分隔：</p><pre class="cn literal-block" id="cn84">{% blocktrans with book|title as book_t and author|title as author_t %}This is {{ book_t }} by {{ author_t }}{% endblocktrans %}</pre><p class="cn" id="cn85">为了表示单复数相关的内容，需要在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">blocktrans</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endblocktrans</span> <span class="pre">%}</span></tt> 之间使用 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">plural</span> <span class="pre">%}</span></tt> 标签来指定单复数形式，例如：</p><pre class="cn literal-block" id="cn87">{% blocktrans count list|length as counter %}There is only one {{ name }} object.{% plural %}There are {{ counter }} {{ name }} objects.{% endblocktrans %}</pre><p class="cn" id="cn88">其内在机制是，所有的块和内嵌翻译调用相应的 <tt class="docutils literal"><span class="pre">gettext</span></tt> 或 <tt class="docutils literal"><span class="pre">ngettext</span></tt> 。</p><p class="cn" id="cn89">每一个<tt class="docutils literal"><span class="pre">RequestContext</span></tt>可以访问三个指定翻译变量：</p><ul class="simple"><li class="cn" id="cn90"><p class="first cn" id="cn90"><tt class="docutils literal"><span class="pre">{{</span> <span class="pre">LANGUAGES</span> <span class="pre">}}</span></tt> 是一系列元组组成的列表，每个元组的第一个元素是语言代码，第二个元素是用该语言表示的语言名称。</p></li></ul><ul class="simple"><li class="cn" id="cn91"><p class="first cn" id="cn91">作为一二字符串，<tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt>是当前用户的优先语言。例如： <tt class="docutils literal"><span class="pre">en-us</span></tt>。（请参见下面的Django如何发现语言偏好）</p></li></ul><ul class="simple"><li class="cn" id="cn92"><p class="first cn" id="cn92"><tt class="docutils literal"><span class="pre">LANGUAGE_BIDI</span></tt>就是当前地域的说明。 如果为真（True），它就是从右向左书写的语言，例如： 希伯来语，阿拉伯语。 如果为假（False），它就是从左到右书写的语言，如： 英语，法语，德语等。</p></li></ul><p class="cn" id="cn93">如果你不用这个<tt class="docutils literal"><span class="pre">RequestContext</span></tt>扩展，你可以用3个标记到那些值：</p><pre class="cn literal-block" id="cn95">{% get_current_language as LANGUAGE_CODE %}{% get_available_languages as LANGUAGES %}{% get_current_language_bidi as LANGUAGE_BIDI %}</pre><p class="cn" id="cn96">这些标记亦要求一个 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">i18n</span> <span class="pre">%}</span></tt> 。</p><p class="cn" id="cn97">翻译的hook在任何接受常量字符串的模板块标签内也是可以使用的。 此时，使用 <tt class="docutils literal"><span class="pre">_()</span></tt> 表达式来指定翻译字符串，例如：</p><pre class="cn literal-block" id="cn99">{% some_special_tag _(&quot;Page not found&quot;) value|yesno:_(&quot;yes,no&quot;) %}</pre><p class="cn" id="cn100">在这种情况下，标记和过滤器两个都会看到已经翻译的字符串，所有它们并不需要提防翻译操作。</p><p class="cn" id="cn101">备注:</p><p class="cn" id="cn102">在这个例子中，翻译结构将放过字符串<tt class="docutils literal"><span class="pre">&quot;yes,no&quot;</span></tt>，而不是单独的字符串<tt class="docutils literal"><span class="pre">&quot;yes&quot;</span></tt>和<tt class="docutils literal"><span class="pre">&quot;no&quot;</span></tt>。翻译的字符串将需要包括逗号以便过滤器解析代码明白如何分割参数。 例如， 一个德语翻译器可能会翻译字符串 <tt class="docutils literal"><span class="pre">&quot;yes,no&quot;</span></tt> 为 <tt class="docutils literal"><span class="pre">&quot;ja,nein&quot;</span></tt> (保持逗号原封不动)。</p></div><div class="section" id="id8"><span id="cn103"></span><h3 class="cn" id="cn103">与惰性翻译对象一道工作</h3><p class="cn" id="cn104">在模型和公用函数中，使用<tt class="docutils literal"><span class="pre">ugettext_lazy()</span></tt>和<tt class="docutils literal"><span class="pre">ungettext_lazy()</span></tt>来标记字符串是很普遍的操作。 当你在你的代码中其它地方使用这些对象时，你应当确定你不会意外地转换它们成一个字符串，因为它们应被尽量晚地转换（以便正确的地域生效） 这需要使用及个帮助函数。</p><div class="section" id="string-concat"><span id="cn105"></span><h4 class="cn" id="cn105">拼接字符串： string_concat()</h4><p class="cn" id="cn106">标准Python字符串拼接(<tt class="docutils literal"><span class="pre">''.join([...])</span></tt> ) 将不会工作在包括惰性翻译对象的列表上。 作为替代，你可以使用<tt class="docutils literal"><span class="pre">django.utils.translation.string_concat()</span></tt>， 这个函数创建了一个惰性对象，其连接起它的内容 <em>并且</em> 仅当结果被包括在一个字符串中时转换它们为字符串 。 例如：</p><pre class="cn literal-block" id="cn108">from django.utils.translation import string_concat# ...name = ugettext_lazy(u'John Lennon')instrument = ugettext_lazy(u'guitar')result = string_concat([name, ': ', instrument])</pre><div class="system-message"><p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">&lt;string&gt;</tt>, line 519)</p><p class="cn" id="cn108">Error in &#8220;cnid&#8221; directive:no content permitted.</p><pre class="cn literal-block" id="cn108">.. cnid:: 109在这种情况下，当</pre></div><div class="system-message"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 523)</p><p class="cn" id="cn108">Explicit markup ends without a blank line; unexpected unindent.</p></div><p class="cn" id="cn108"><tt class="docutils literal"><span class="pre">result</span></tt> 自己被用与一个字符串时， <tt class="docutils literal"><span class="pre">result</span></tt> 中的惰性翻译将仅被转换为字符串(通常在模板渲染时间)。</p></div><div class="section" id="allow-lazy"><span id="cn110"></span><h4 class="cn" id="cn110">allow_lazy() 修饰符</h4><p class="cn" id="cn111">Django提供很多功能函数（如：取一个字符串作为他们的第一个参数并且对那个字符串做些什么）。(尤其在 <tt class="docutils literal"><span class="pre">django.utils</span></tt> 中) 这些函数被模板过滤器像在其他代码中一样直接使用。</p><p class="cn" id="cn112">如果你写你自己的类似函数并且与翻译打交道，当第一个参数是惰性翻译对象时，你会面临“做什么”的难题。因为你可能在视图之外使用这个函数（并且因此当前线程的本地设置将会不正确），所以你不想立即转换其为一个字符串。</p><p class="cn" id="cn113">象这种情况，请使用 <tt class="docutils literal"><span class="pre">django.utils.functional.allow_lazy()</span></tt>修饰符。 它修改这个函数以便 <em>假如</em>第一个参数是一个惰性翻译， 这个函数的赋值会被延后直到它需要被转化为一个字符串为止。</p><p class="cn" id="cn114">例如：</p><pre class="cn literal-block" id="cn116">from django.utils.functional import allow_lazydef fancy_utility_function(s, ...):# Do some conversion on string 's'# ...fancy_utility_function = allow_lazy(fancy_utility_function, unicode)</pre><p class="cn" id="cn117"><tt class="docutils literal"><span class="pre">allow_lazy()</span></tt> 装饰符 采用了另外的函数来装饰，以及一定量的，原始函数可以返回的特定类型的额外参数 (<tt class="docutils literal"><span class="pre">*args</span></tt> ) 。 通常，在这里包括 <tt class="docutils literal"><span class="pre">unicode</span></tt> 就足够了并且确定你的函数将仅返回Unicode字符串。</p><p class="cn" id="cn118">使用这个修饰符意味着你能写你的函数并且假设输入是合适的字符串，然后在末尾添加对惰性翻译对象的支持。</p></div></div></div><div class="section" id="id9"><span id="cn119"></span><h2 class="cn" id="cn119">2、如何创建语言文件</h2><p class="cn" id="cn120">当你标记了翻译字符串，你就需要写出（或获取已有的）对应的语言翻译信息。 这里就是它如何工作的。</p><p class="cn" id="cn121">地域限制</p><p class="cn" id="cn122">Django不支持把你的应用本地化到一个连它自己都还没被翻译的地域。 在这种情况下，它将忽略你的翻译文件。 如果你想尝试这个并且Django支持它，你会不可避免地见到这样一个混合体&#8211;&#8211;参杂着你的译文和来自Django自己的英文。 如果你的应用需要你支持一个Django中没有的地域，你将至少需要做一个Django core的最小翻译。</p><div class="section" id="id10"><span id="cn123"></span><h3 class="cn" id="cn123">消息文件</h3><p class="cn" id="cn124">第一步，就是为一种语言创建一个信息文件。 信息文件是包含了某一语言翻译字符串和对这些字符串的翻译的一个文本文件。 信息文件以 <tt class="docutils literal"><span class="pre">.po</span></tt> 为后缀名。</p><p class="cn" id="cn125">Django中带有一个工具， <tt class="docutils literal"><span class="pre">bin/make-messages.py</span></tt> ，它完成了这些文件的创建和维护工作。 运行以下命令来创建或更新一个信息文件：</p><pre class="cn literal-block" id="cn127">django-admin.py makemessages -l de</pre><p class="cn" id="cn128">其中 <tt class="docutils literal"><span class="pre">de</span></tt> 是所创建的信息文件的语言代码。 在这里，语言代码是以本地格式给出的。 例如，巴西地区的葡萄牙语为 <tt class="docutils literal"><span class="pre">pt_BR</span></tt> ，澳大利亚地区的德语为 <tt class="docutils literal"><span class="pre">de_AT</span></tt> 。</p><p class="cn" id="cn129">这段脚本应该在三处之一运行：</p><ul class="simple"><li class="cn" id="cn130"><p class="first cn" id="cn130">Django项目根目录。</p></li></ul><ul class="simple"><li class="cn" id="cn131"><p class="first cn" id="cn131">您Django应用的根目录。</p></li></ul><ul class="simple"><li class="cn" id="cn132"><p class="first cn" id="cn132"><tt class="docutils literal"><span class="pre">django</span></tt> 根目录（不是Subversion检出目录，而是通过 <tt class="docutils literal"><span class="pre">$PYTHONPATH</span></tt> 链接或位于该路径的某处）。这仅和你为Django自己创建一个翻译时有关。</p></li></ul><p class="cn" id="cn133">这段脚本遍历你的项目源树或你的应用程序源树并且提取出所有为翻译而被标记的字符串。 它在 <tt class="docutils literal"><span class="pre">locale/LANG/LC_MESSAGES</span></tt> 目录下创建（或更新）了一个信息文件。针对上面的<tt class="docutils literal"><span class="pre">de</span></tt>，应该是<tt class="docutils literal"><span class="pre">locale/de/LC_MESSAGES/django.po</span></tt>。</p><p class="cn" id="cn134">作为默认， <tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">makemessages</span></tt> 检测每一个有<tt class="docutils literal"><span class="pre">.html</span></tt> 扩展名的文件。&nbsp; 以备你要重载缺省值，使用<tt class="docutils literal"><span class="pre">--extension</span></tt> 或 <tt class="docutils literal"><span class="pre">-e</span></tt> 选项指定文件扩展名来检测。</p><pre class="cn literal-block" id="cn136">django-admin.py makemessages -l de -e txt</pre><p class="cn" id="cn137">用逗号和（或）使用<tt class="docutils literal"><span class="pre">-e</span></tt>或<tt class="docutils literal"><span class="pre">--extension</span></tt>来分隔多项扩展名：</p><pre class="cn literal-block" id="cn139">django-admin.py makemessages -l de -e html,txt -e xml</pre><p class="cn" id="cn140">当创建JavaScript翻译目录时，你需要使用特殊的Django域：<strong>not</strong> <tt class="docutils literal"><span class="pre">-e</span> <span class="pre">js</span></tt> 。</p><p class="cn" id="cn141">没有gettext?</p><p class="cn" id="cn142">如果没有安装 <tt class="docutils literal"><span class="pre">gettext</span></tt> 组件， <tt class="docutils literal"><span class="pre">make-messages.py</span></tt> 将会创建空白文件。 这种情况下，安装 <tt class="docutils literal"><span class="pre">gettext</span></tt> 组件或只是复制英语信息文件( <tt class="docutils literal"><span class="pre">conf/locale/en/LC_MESSAGES/django.po</span></tt> )来作为一个起点；只是一个空白的翻译信息文件而已。</p><p class="cn" id="cn143">工作在Windows上么？</p><p class="cn" id="cn144">如果你正在使用Windows，且需要安装GNU gettext共用程序以便<tt class="docutils literal"><span class="pre">django-admin</span> <span class="pre">makemessages</span></tt> 可以工作，请参看下面Windows小节中gettext部分以获得更多信息。</p><p class="cn" id="cn145"><tt class="docutils literal"><span class="pre">.po</span></tt> 文件格式很直观。 每个 <tt class="docutils literal"><span class="pre">.po</span></tt> 文件包含一小部分的元数据，比如翻译维护人员的联系信息，而文件的大部分内容是简单的翻译字符串和对应语言翻译结果的映射关系的列表。</p><p class="cn" id="cn146">举个例子，如果Django应用程序包括一个 <tt class="docutils literal"><span class="pre">&quot;Welcome</span> <span class="pre">to</span> <span class="pre">my</span> <span class="pre">site.&quot;</span></tt> 的待翻译字符串 ，像这样：</p><pre class="cn literal-block" id="cn148">_(&quot;Welcome to my site.&quot;)</pre><p class="cn" id="cn149">则<tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">makemessages</span></tt>将创建一个 <tt class="docutils literal"><span class="pre">.po</span></tt> 文件来包含以下片段的消息：</p><pre class="cn literal-block" id="cn151">#: path/to/python/module.py:23msgid &quot;Welcome to my site.&quot;msgstr &quot;&quot;</pre><p class="cn" id="cn152">快速解释：</p><ul class="simple"><li class="cn" id="cn153"><p class="first cn" id="cn153"><tt class="docutils literal"><span class="pre">msgid</span></tt> 是在源文件中出现的翻译字符串。 不要做改动。</p></li></ul><ul class="simple"><li class="cn" id="cn154"><p class="first cn" id="cn154"><tt class="docutils literal"><span class="pre">msgstr</span></tt> 是相应语言的翻译结果。 刚创建时它只是空字符串，此时就需要你来完成它。 注意不要丢掉语句前后的引号。</p></li></ul><ul class="simple"><li class="cn" id="cn155"><p class="first cn" id="cn155">作为方便之处，每一个消息都包括：以 <tt class="docutils literal"><span class="pre">#</span></tt> 为前缀的一个注释行并且定位上边的<tt class="docutils literal"><span class="pre">msgid</span></tt> 行，文件名和行号。</p></li></ul><p class="cn" id="cn156">对于比较长的信息也有其处理方法。 <tt class="docutils literal"><span class="pre">msgstr</span></tt> （或 <tt class="docutils literal"><span class="pre">msgid</span></tt> ）后紧跟着的字符串为一个空字符串。 然后真正的内容在其下面的几行。 这些字符串会被直接连在一起。 同时，不要忘了字符串末尾的空格，因为它们会不加空格地连到一起。</p><p class="cn" id="cn157">若要对新创建的翻译字符串校验所有的源代码和模板，并且更新所有语言的信息文件，可以运行以下命令：</p><pre class="cn literal-block" id="cn159">django-admin.py makemessages -a</pre></div><div class="section" id="id11"><span id="cn160"></span><h3 class="cn" id="cn160">编译信息文件</h3><p class="cn" id="cn161">创建信息文件之后，每次对其做了修改，都需要将它重新编译成一种更有效率的形式，供 <tt class="docutils literal"><span class="pre">gettext</span></tt> 使用。可以使用<tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">compilemessages</span></tt>完成。</p><p class="cn" id="cn162">这个工具作用于所有有效的 <tt class="docutils literal"><span class="pre">.po</span></tt> 文件，创建优化过的二进制 <tt class="docutils literal"><span class="pre">.mo</span></tt> 文件供 <tt class="docutils literal"><span class="pre">gettext</span></tt> 使用。在你可以运行<tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">makemessages</span></tt>的目录下，运行<tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">compilemessages</span></tt>：</p><pre class="cn literal-block" id="cn164">django-admin.py compilemessages</pre><p class="cn" id="cn165">就是这样了。 你的翻译成果已经可以使用了。</p></div></div><div class="section" id="django"><span id="cn166"></span><h2 class="cn" id="cn166">Django如何处理语言偏好</h2><p class="cn" id="cn167">一旦你准备好了翻译，如果希望在Django中使用，那么只需要激活这些翻译即可。</p><p class="cn" id="cn168">在这些功能背后，Django拥有一个灵活的模型来确定在安装和使用应用程序的过程中选择使用的语言。</p><p class="cn" id="cn169">要设定一个安装阶段的语种偏好，请设定<tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt>。如果其他翻译器没有找到一个译文，Django将使用这个语种作为缺省的翻译最终尝试。</p><p class="cn" id="cn170">如果你只是想要用本地语言来运行Django，并且该语言的语言文件存在，只需要简单地设置 <tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt> 即可。</p><p class="cn" id="cn171">如果要让每一个使用者各自指定语言偏好，就需要使用 <tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> 。 <tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> 使得Django基于请求的数据进行语言选择，从而为每一位用户定制内容。 它为每一个用户定制内容。</p><p class="cn" id="cn172">使用 <tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> 需要在 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 设置中增加 <tt class="docutils literal"><span class="pre">'django.middleware.locale.LocaleMiddleware'</span></tt> 。 中间件的顺序是有影响的，最好按照依照以下要求：</p><ul class="simple"><li class="cn" id="cn173"><p class="first cn" id="cn173">保证它是第一批安装的中间件类。</p></li></ul><ul class="simple"><li class="cn" id="cn174"><p class="first cn" id="cn174">因为 <tt class="docutils literal"><span class="pre">LocalMiddleware</span></tt> 要用到session数据，所以需要放在 <tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> 之后。</p></li></ul><ul class="simple"><li class="cn" id="cn175"><p class="first cn" id="cn175">如果你使用<tt class="docutils literal"><span class="pre">CacheMiddleware</span></tt>,把<tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt>放在它后面。</p></li></ul><p class="cn" id="cn176">例如， <tt class="docutils literal"><span class="pre">MIDDLE_CLASSES</span></tt> 可能会是如此：</p><pre class="cn literal-block" id="cn178">MIDDLEWARE_CLASSES = ('django.contrib.sessions.middleware.SessionMiddleware','django.middleware.locale.LocaleMiddleware','django.middleware.common.CommonMiddleware',)</pre><p class="cn" id="cn179">（更多关于中间件的内容，请参阅第17章）</p><p class="cn" id="cn180"><tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> 按照如下算法确定用户的语言:</p><ul class="simple"><li class="cn" id="cn181"><p class="first cn" id="cn181">首先，在当前用户的 session 的中查找<tt class="docutils literal"><span class="pre">django_language</span></tt>键；</p></li></ul><ul class="simple"><li class="cn" id="cn182"><p class="first cn" id="cn182">如未找到，它会找寻一个cookie</p></li></ul><ul class="simple"><li class="cn" id="cn183"><p class="first cn" id="cn183">还找不到的话，它会在 HTTP 请求头部里查找<tt class="docutils literal"><span class="pre">Accept-Language</span></tt>， 该头部是你的浏览器发送的，并且按优先顺序告诉服务器你的语言偏好。 Django会尝试头部中的每一个语种直到它发现一个可用的翻译。</p></li></ul><ul class="simple"><li class="cn" id="cn184"><p class="first cn" id="cn184">以上都失败了的话, 就使用全局的 <tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt> 设定值。</p></li></ul><p class="cn" id="cn185">备注：</p><blockquote><p class="cn" id="cn186">在上述每一处，语种偏好应作为字符串，以标准的语种格式出现。 例如，巴西葡萄牙语是<tt class="docutils literal"><span class="pre">pt-br</span></tt></p><p class="cn" id="cn187">如果一个基本语种存在而亚语种没有指定，Django将使用基本语种。 比如，如果用户指定了 <tt class="docutils literal"><span class="pre">de-at</span></tt> （澳式德语）但Django只有针对 <tt class="docutils literal"><span class="pre">de</span></tt> 的翻译，那么 <tt class="docutils literal"><span class="pre">de</span></tt> 会被选用。</p><p class="cn" id="cn188">只有在 <tt class="docutils literal"><span class="pre">LANGUAGES</span></tt> 设置中列出的语言才能被选用。 若希望将语言限制为所提供语言中的某些（因为应用程序并不提供所有语言的表示），则将 <tt class="docutils literal"><span class="pre">LANGUAGES</span></tt> 设置为所希望提供语言的列表，例如： 例如：</p></blockquote><pre class="cn literal-block" id="cn190">LANGUAGES = (('de', _('German')),('en', _('English')),)</pre><blockquote><p class="cn" id="cn191">上面这个例子限制了语言偏好只能是德语和英语（包括它们的子语言，如 <tt class="docutils literal"><span class="pre">de-ch</span></tt> 和 <tt class="docutils literal"><span class="pre">en-us</span></tt> ）。</p><p class="cn" id="cn192">如果自定义了 <tt class="docutils literal"><span class="pre">LANGUAGES</span></tt> ，将语言标记为翻译字符串是可以的，但是，请不要使用 <tt class="docutils literal"><span class="pre">django.utils.translation</span></tt> 中的 <tt class="docutils literal"><span class="pre">gettext()</span></tt> （决不要在settings文件中导入 <tt class="docutils literal"><span class="pre">django.utils.translation</span></tt> ，因为这个模块本身是依赖于settings，这样做会导致无限循环），而是使用一个“虚构的” <tt class="docutils literal"><span class="pre">gettext()</span></tt> 。</p><p class="cn" id="cn193">解决方案就是使用一个“虚假的” <tt class="docutils literal"><span class="pre">gettext()</span></tt> 。以 下是一个settings文件的例子：</p></blockquote><pre class="cn literal-block" id="cn195">ugettext = lambda s: sLANGUAGES = (('de', ugettext('German')),('en', ugettext('English')),)</pre><blockquote><p class="cn" id="cn196">这样做的话， <tt class="docutils literal"><span class="pre">make-messages.py</span></tt> 仍会寻找并标记出将要被翻译的这些字符串，但翻译不会在运行时进行，故而需要在任何使用 <em>LANGUAGES</em> 的代码中用“真实的”<tt class="docutils literal"><span class="pre">ugettext()</span></tt>。</p><p class="cn" id="cn197"><tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> 只能选择那些Django已经提供了基础翻译的语言。 如果想要在应用程序中对Django中还没有基础翻译的语言提供翻译，那么必须至少先提供该语言的基本的翻译。 例如，Django使用特定的信息ID来翻译日期和时间格式，故要让系统正常工作，至少要提供这些基本的翻译。</p><p class="cn" id="cn198">以英语的 <tt class="docutils literal"><span class="pre">.po</span></tt> 文件为基础，翻译其中的技术相关的信息，可能还包括一些使之生效的信息。</p><p class="cn" id="cn199">技术相关的信息ID很容易被认出来：它们都是大写的。 这些信息ID的翻译与其他信息不同:你需要提供其对应的本地化内容。 例如，对于 DATETIME_FORMAT （或 DATE_FORMAT 、 TIME_FORMAT ），应该提供希望在该语言中使用的格式化字符串。 格式被模板标签<tt class="docutils literal"><span class="pre">now</span></tt>用来识别格式字符串。</p></blockquote><p class="cn" id="cn200">一旦<tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt>决定用户的偏好，它会让这个偏好作为<tt class="docutils literal"><span class="pre">request.LANGUAGE_CODE</span></tt>对每一个<tt class="docutils literal"><span class="pre">HttpRequest</span></tt>有效。请随意在你的视图代码中读一读这个值。 以下是一个简单的例子：</p><pre class="cn literal-block" id="cn202">def hello_world(request):if request.LANGUAGE_CODE == 'de-at':return HttpResponse(&quot;You prefer to read Austrian German.&quot;)else:return HttpResponse(&quot;You prefer to read another language.&quot;)</pre><p class="cn" id="cn203">注意，对于静态翻译（无中间件）而言，此语言在<tt class="docutils literal"><span class="pre">settings.LANGUAGE_CODE</span></tt>中，而对于动态翻译（中间件），它在<tt class="docutils literal"><span class="pre">request.LANGUAGE_CODE</span></tt>中。</p></div><div class="section" id="id12"><span id="cn204"></span><h2 class="cn" id="cn204">在你自己的项目中使用翻译</h2><p class="cn" id="cn205">Django使用以下算法寻找翻译：</p><ul class="simple"><li class="cn" id="cn206"><p class="first cn" id="cn206">首先，Django在该视图所在的应用程序文件夹中寻找 <tt class="docutils literal"><span class="pre">locale</span></tt> 目录。 若找到所选语言的翻译，则加载该翻译。</p></li></ul><ul class="simple"><li class="cn" id="cn207"><p class="first cn" id="cn207">第二步，Django在项目目录中寻找 <tt class="docutils literal"><span class="pre">locale</span></tt> 目录。 若找到翻译，则加载该翻译。</p></li></ul><ul class="simple"><li class="cn" id="cn208"><p class="first cn" id="cn208">最后，Django使用 <tt class="docutils literal"><span class="pre">django/conf/locale</span></tt> 目录中的基本翻译。</p></li></ul><p class="cn" id="cn209">以这种方式，你可以创建包含独立翻译的应用程序，可以覆盖项目中的基本翻译。 或者，你可以创建一个包含几个应用程序的大项目，并将所有需要的翻译放在一个大的项目信息文件中。 决定权在你手中。</p><p class="cn" id="cn210">所有的信息文件库都是以同样方式组织的： 它们是：</p><ul class="simple"><li class="cn" id="cn211"><p class="first cn" id="cn211"><tt class="docutils literal"><span class="pre">$APPPATH/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn212"><p class="first cn" id="cn212"><tt class="docutils literal"><span class="pre">$PROJECTPATH/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn213"><p class="first cn" id="cn213">所有在settings文件中 <tt class="docutils literal"><span class="pre">LOCALE_PATHS</span></tt> 中列出的路径以其列出的顺序搜索 <tt class="docutils literal"><span class="pre">&lt;language&gt;/LC_MESSAGES/django.(po|mo)</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn214"><p class="first cn" id="cn214"><tt class="docutils literal"><span class="pre">$PYTHONPATH/django/conf/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)</span></tt></p></li></ul><p class="cn" id="cn215">要创建信息文件，也是使用 <tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">makemessages.py</span></tt> 工具，和Django信息文件一样。 需要做的就是进入正确的目录—— <tt class="docutils literal"><span class="pre">conf/locale</span></tt> （在源码树的情况下）或者 <tt class="docutils literal"><span class="pre">locale/</span></tt> （在应用程序信息或项目信息的情况下）所在的目录下。 同样地，使用 <tt class="docutils literal"><span class="pre">compile-messages.py</span></tt> 生成 <tt class="docutils literal"><span class="pre">gettext</span></tt> 需要使用的二进制 <tt class="docutils literal"><span class="pre">django.mo</span></tt> 文件。</p><p class="cn" id="cn216">您亦可运行<tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">compilemessages</span><span class="pre">--settings=path.to.settings</span></tt> 来使编译器处理所有存在于您 <tt class="docutils literal"><span class="pre">LOCALE_PATHS</span></tt> 设置中的目录。</p><p class="cn" id="cn217">应用程序信息文件稍微难以发现——因为它们需要 <tt class="docutils literal"><span class="pre">LocaleMiddle</span></tt> 。如果不使用中间件，Django只会处理Django的信息文件和项目的信息文件。</p><p class="cn" id="cn218">最后，需要考虑一下翻译文件的结构。 若应用程序要发放给其他用户，应用到其它项目中，可能需要使用应用程序相关的翻译。 但是，使用应用程序相关的翻译和项目翻译在使用 <tt class="docutils literal"><span class="pre">make-messages</span></tt> 时会产生古怪的问题。它会遍历当前路径下所有的文件夹，这样可能会把应用消息文件里存在的消息ID重复放入项目消息文件中。</p><p class="cn" id="cn219">最容易的解决方法就是将不属于项目的应用程序（因此附带着本身的翻译）存储在项目树之外。 这样做的话，项目级的 <tt class="docutils literal"><span class="pre">make-messages</span></tt> 将只会翻译与项目精确相关的，而不包括那些独立发布的应用程序中的字符串。</p></div><div class="section" id="set-language"><span id="cn220"></span><h2 class="cn" id="cn220"><tt class="docutils literal"><span class="pre">set_language</span></tt> 重定向视图</h2><p class="cn" id="cn221">方便起见，Django自带了一个 <tt class="docutils literal"><span class="pre">django.views.i18n.set_language</span></tt> 视图，作用是设置用户语言偏好并重定向返回到前一页面。</p><p class="cn" id="cn222">在URLconf中加入下面这行代码来激活这个视图：</p><pre class="cn literal-block" id="cn224">(r'^i18n/', include('django.conf.urls.i18n')),</pre><p class="cn" id="cn225">（注意这个例子使得这个视图在 <tt class="docutils literal"><span class="pre">/i18n/setlang/</span></tt> 中有效。）</p><p class="cn" id="cn226">这个视图是通过 <tt class="docutils literal"><span class="pre">GET</span></tt> 方法调用的，在请求中包含了 <tt class="docutils literal"><span class="pre">language</span></tt> 参数。 如果session已启用，这个视图会将语言选择保存在用户的session中。 否则，它会以缺省名<tt class="docutils literal"><span class="pre">django_language</span></tt>在cookie中保存这个语言选择。(这个名字可以通过<tt class="docutils literal"><span class="pre">LANGUAGE_COOKIE_NAME</span></tt>设置来改变)</p><p class="cn" id="cn227">保存了语言选择后，Django根据以下算法来重定向页面：</p><ul class="simple"><li class="cn" id="cn228"><p class="first cn" id="cn228">Django 在 <tt class="docutils literal"><span class="pre">POST</span></tt> 数据中寻找一个 <tt class="docutils literal"><span class="pre">下一个</span></tt> 参数。</p></li></ul><ul class="simple"><li class="cn" id="cn229"><p class="first cn" id="cn229">如果 <tt class="docutils literal"><span class="pre">next</span></tt> 参数不存在或为空，Django尝试重定向页面为HTML头部信息中 <tt class="docutils literal"><span class="pre">Referer</span></tt> 的值。</p></li></ul><ul class="simple"><li class="cn" id="cn230"><p class="first cn" id="cn230">如果 <tt class="docutils literal"><span class="pre">Referer</span></tt> 也是空的，即该用户的浏览器并不发送 <tt class="docutils literal"><span class="pre">Referer</span></tt> 头信息，则页面将重定向到 <tt class="docutils literal"><span class="pre">/</span></tt> （页面根目录）。</p></li></ul><p class="cn" id="cn231">这是一个HTML模板代码的例子：</p><pre class="cn literal-block" id="cn233">&lt;form action=&quot;/i18n/setlang/&quot; method=&quot;post&quot;&gt;&lt;input name=&quot;next&quot; type=&quot;hidden&quot; value=&quot;/next/page/&quot; /&gt;&lt;select name=&quot;language&quot;&gt;{% for lang in LANGUAGES %}&lt;option value=&quot;{{ lang.0 }}&quot;&gt;{{ lang.1 }}&lt;/option&gt;{% endfor %}&lt;/select&gt;&lt;input type=&quot;submit&quot; value=&quot;Go&quot; /&gt;&lt;/form&gt;</pre></div><div class="section" id="javascript"><span id="cn234"></span><h2 class="cn" id="cn234">翻译与JavaScript</h2><p class="cn" id="cn235">将翻译添加到JavaScript会引起一些问题：</p><ul class="simple"><li class="cn" id="cn236"><p class="first cn" id="cn236">JavaScript代码无法访问一个 <tt class="docutils literal"><span class="pre">gettext</span></tt> 的实现。</p></li></ul><ul class="simple"><li class="cn" id="cn237"><p class="first cn" id="cn237">JavaScript 代码并不访问 .po或 .mo 文件；它们需要由服务器分发。</p></li></ul><ul class="simple"><li class="cn" id="cn238"><p class="first cn" id="cn238">针对JavaScript的翻译目录应尽量小。</p></li></ul><p class="cn" id="cn239">Django已经提供了一个集成解决方案： 它会将翻译传递给JavaScript，因此就可以在JavaScript中调用 <tt class="docutils literal"><span class="pre">gettext</span></tt> 之类的代码。</p><div class="section" id="javascript-catalog"><span id="cn240"></span><h3 class="cn" id="cn240"><tt class="docutils literal"><span class="pre">javascript_catalog</span></tt>视图</h3><p class="cn" id="cn241">这些问题的主要解决方案就是 <tt class="docutils literal"><span class="pre">javascript_catalog</span></tt> 视图。该视图生成一个JavaScript代码库，包括模仿 gettext 接口的函数，和翻译字符串的数组。 这些翻译字符串来自于你在info_dict或URl中指定的应用，工程或Django内核。</p><p class="cn" id="cn242">像这样使用：</p><pre class="cn literal-block" id="cn244">js_info_dict = {'packages': ('your.app.package',),}urlpatterns = patterns('',(r'^jsi18n/$', 'django.views.i18n.javascript_catalog', js_info_dict),)</pre><p class="cn" id="cn245"><tt class="docutils literal"><span class="pre">packages</span></tt> 里的每个字符串应该是Python中的点分割的包的表达式形式（和在 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中的字符串相同的格式），而且应指向包含 <tt class="docutils literal"><span class="pre">locale</span></tt> 目录的包。 如果指定了多个包，所有的目录会合并成一个目录。 如果有用到来自不同应用程序的字符串的JavaScript，这种机制会很有帮助。</p><p class="cn" id="cn246">你可以动态使用视图，将包放在urlpatterns里：</p><pre class="cn literal-block" id="cn248">urlpatterns = patterns('',(r'^jsi18n/(?P&lt;packages&gt;\S+)/$', 'django.views.i18n.javascript_catalog'),)</pre><p class="cn" id="cn249">这样的话，就可以在URL中指定由加号（ <tt class="docutils literal"><span class="pre">+</span></tt> ）分隔包名的包了。 如果页面使用来自不同应用程序的代码，且经常改变，还不想将其放在一个大的目录文件中，对于这些情况，显然这是很有用的。 出于安全考虑，这些值只能是 <tt class="docutils literal"><span class="pre">django.conf</span></tt> 或 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置中的包。</p></div><div class="section" id="id13"><span id="cn250"></span><h3 class="cn" id="cn250">使用JavaScript翻译目录</h3><p class="cn" id="cn251">要使用这个目录，只要这样引入动态生成的脚本：</p><pre class="cn literal-block" id="cn253">&lt;script type=&quot;text/javascript&quot; src=&quot;/path/to/jsi18n/&quot;&gt;&lt;/script&gt;</pre><p class="cn" id="cn254">这就是管理页面如何从服务器获取翻译目录。 当目录加载后，JavaScript代码就能通过标准的 <tt class="docutils literal"><span class="pre">gettext</span></tt> 接口进行访问：</p><pre class="cn literal-block" id="cn256">document.write(gettext('this is to be translated'));</pre><p class="cn" id="cn257">也有一个<tt class="docutils literal"><span class="pre">ngettext</span></tt>接口：</p><pre class="cn literal-block" id="cn259">var object_cnt = 1 // or 0, or 2, or 3, ...s = ngettext('literal for the singular case','literal for the plural case', object_cnt);</pre><p class="cn" id="cn260">甚至有一个字符串插入函数：</p><pre class="cn literal-block" id="cn262">function interpolate(fmt, obj, named);</pre><p class="cn" id="cn263">插入句法是从Python借用的，所以<tt class="docutils literal"><span class="pre">interpolate</span></tt>函数对位置和命名插入均提供支持：</p><blockquote><p class="cn" id="cn264">位置插入 <tt class="docutils literal"><span class="pre">obj</span></tt>包括一个JavaScript数组对象，元素值在它们对应于<tt class="docutils literal"><span class="pre">fmt</span></tt>的占位符中以它们出现的相同次序顺序插值 。 例如：</p></blockquote><pre class="cn literal-block" id="cn266">fmts = ngettext('There is %s object. Remaining: %s','There are %s objects. Remaining: %s', 11);s = interpolate(fmts, [11, 20]);// s is 'There are 11 objects. Remaining: 20'</pre><blockquote><p class="cn" id="cn267">命名插入 通过传送为真（TRUE）的布尔参数<tt class="docutils literal"><span class="pre">name</span></tt>来选择这个模式。 <tt class="docutils literal"><span class="pre">obj</span></tt>包括一个 JavaScript 对象或相关数组。 例如：</p></blockquote><pre class="cn literal-block" id="cn269">d = {count: 10total: 50};fmts = ngettext('Total: %(total)s, there is %(count)s object','there are %(count)s of a total of %(total)s objects', d.count);s = interpolate(fmts, d, true);</pre><p class="cn" id="cn270">但是，你不应重复编写字符串插值： 这还是JavaScript，所以这段代码不得不重复做正则表达式置换。它不会和Python中的字符串插补一样快，因此只有真正需要的时候再使用它（例如，利用 <tt class="docutils literal"><span class="pre">ngettext</span></tt> 生成合适的复数形式）。</p></div><div class="section" id="id14"><span id="cn271"></span><h3 class="cn" id="cn271">创建JavaScript翻译目录</h3><p class="cn" id="cn272">你可以创建和更改翻译目录，就像其他</p><p class="cn" id="cn273">Django翻译目录一样，使用django-admin.py makemessages  工具。 唯一的差别是需要提供一个 <tt class="docutils literal"><span class="pre">-d</span> <span class="pre">djangojs</span></tt> 的参数，就像这样：</p><pre class="cn literal-block" id="cn275">django-admin.py makemessages -d djangojs -l de</pre><p class="cn" id="cn276">这样来创建或更新JavaScript的德语翻译目录。和普通的Django翻译目录一样，更新了翻译目录后，运行 <tt class="docutils literal"><span class="pre">compile-messages.py</span></tt> 即可。</p></div></div><div class="section" id="gettext"><span id="cn277"></span><h2 class="cn" id="cn277">熟悉 <tt class="docutils literal"><span class="pre">gettext</span></tt> 用户的注意事项</h2><p class="cn" id="cn278">如果你了解 <tt class="docutils literal"><span class="pre">gettext</span></tt> ，你可能会发现Django进行翻译时的一些特殊的东西：</p><ul class="simple"><li class="cn" id="cn279"><p class="first cn" id="cn279">字符串域为 <tt class="docutils literal"><span class="pre">django</span></tt> 或 <tt class="docutils literal"><span class="pre">djangojs</span></tt> 。字符串域是用来区别将数据存储在同一信息文件库（一般是 <tt class="docutils literal"><span class="pre">/usr/share/locale/</span></tt> ）的不同程序。django 域是为Python和模板翻译字符串服务的，被加载到全局翻译目录。 <tt class="docutils literal"><span class="pre">djangojs</span></tt> 域只是用来尽可能缩小JavaScript翻译的体积。</p></li></ul><ul class="simple"><li class="cn" id="cn280"><p class="first cn" id="cn280">Django不单独使用 <tt class="docutils literal"><span class="pre">xgettext</span></tt> ， 而是经过Python包装后的<tt class="docutils literal"><span class="pre">xgettext</span></tt>和msgfmt。这主要是为了方便。</p></li></ul></div><div class="section" id="windows-gettext"><span id="cn281"></span><h2 class="cn" id="cn281">Windows下的<tt class="docutils literal"><span class="pre">gettext</span></tt></h2><p class="cn" id="cn282">对于那些要提取消息或编译消息文件的人们来说，需要的只有这么多。翻译工作本身仅仅包含编辑这个类型的现存文件，但如果你要创建你自己的消息文件，或想要测试或编译一个更改过的消息文件，你将需要这个<tt class="docutils literal"><span class="pre">gettext</span></tt>公用程序。</p><ul><li class="cn" id="cn283"><blockquote class="first"><p class="cn" id="cn283">从<a class="reference external" href="http://sourceforge.net/projects/gettext">http://sourceforge.net/projects/gettext</a>下载以下zip文件</p></blockquote><ul class="simple"><li class="cn" id="cn284"><p class="first cn" id="cn284"><tt class="docutils literal"><span class="pre">gettext-runtime-X.bin.woe32.zip</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn285"><p class="first cn" id="cn285"><tt class="docutils literal"><span class="pre">gettext-tools-X.bin.woe32.zip</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn286"><p class="first cn" id="cn286"><tt class="docutils literal"><span class="pre">libiconv-X.bin.woe32.zip</span></tt></p></li></ul></li></ul><ul class="simple"><li class="cn" id="cn287"><p class="first cn" id="cn287">在同一文件夹下展开这3个文件。（也就是 <tt class="docutils literal"><span class="pre">C:\Program</span><span class="pre">Files\gettext-utils</span></tt> )</p></li></ul><ul><li class="cn" id="cn288"><p class="first cn" id="cn288">更新系统路径：</p><ul class="simple"><li class="cn" id="cn289"><p class="first cn" id="cn289"><tt class="docutils literal"><span class="pre">控制面板</span> <span class="pre">&gt;</span> <span class="pre">系统&gt;</span> <span class="pre">高级</span> <span class="pre">&gt;</span> <span class="pre">环境变量</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn290"><p class="first cn" id="cn290">在<tt class="docutils literal"><span class="pre">系统变量</span></tt>列表中，点击<tt class="docutils literal"><span class="pre">Path</span></tt>，点击<tt class="docutils literal"><span class="pre">Edit</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn291"><p class="first cn" id="cn291">把<tt class="docutils literal"><span class="pre">;C:\Program</span> <span class="pre">Files\gettext-utils\bin</span></tt>加到<tt class="docutils literal"><span class="pre">变量值</span></tt>字段的末尾。</p></li></ul></li></ul><p class="cn" id="cn292">只要<tt class="docutils literal"><span class="pre">xgettext</span> <span class="pre">--version</span></tt>命令正常工作，你亦可使用从别处获得的<tt class="docutils literal"><span class="pre">gettext</span></tt>的二进制代码。 有些版本的0.14.4二进制代码被发现不支持这个命令。 不要试图与Django公用程序一起使用一个<tt class="docutils literal"><span class="pre">gettext</span></tt>。在一个windows命令提示窗口输入命令 `` xgettext &#8212;version <a href="#id15"><span class="problematic" id="id16">``</span></a>将导致出现一个错误弹出窗口&#8211;“xgettext.exe产生错误并且将被windows关闭”。</p><div class="system-message" id="id15"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 1346); <em><a href="#id16">backlink</a></em></p><p class="cn" id="cn292">Inline literal start-string without end-string.</p></div></div><div class="section" id="id17"><span id="cn293"></span><h2 class="cn" id="cn293">下一章</h2><p class="cn" id="cn294"><a class="reference external" href="chapter20.html">未章</a> 将关注于安全，如何帮助你的用户和网站远离恶意软件的攻击。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter18.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter20.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>