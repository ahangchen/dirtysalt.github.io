<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十四章 集成的子框架 django.contrib</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter15.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter17.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="django-contrib"><h1 class="cn title" id="cn0">第十六章：集成的子框架 django.contrib</h1><p class="cn" id="cn1">Python有众多优点，其中之一就是“开机即用”原则： 安装Python的同时会安装好大量的标准软件包，这样 你可以立即使用而不用自己去下载。 Django也遵循这个原则，它同样包含了自己的标准库。这一章就来讲 这些集成的子框架。</p><div class="section" id="django"><span id="cn2"></span><h2 class="cn" id="cn2">Django标准库</h2><p class="cn" id="cn3">Django的标准库存放在 <tt class="docutils literal"><span class="pre">django.contrib</span></tt> 包中。每个子包都是一个独立的附加功能包。 这些子包一般是互相独立的，不过有些<tt class="docutils literal"><span class="pre">django.contrib</span></tt>子包需要依赖其他子包。</p><p class="cn" id="cn4">在 <tt class="docutils literal"><span class="pre">django.contrib</span></tt> 中对函数的类型并没有强制要求 。其中一些包中带有模型（因此需要你在数据库中安装对应的数据表），但其它一些由独立的中间件及模板标签组成。</p><p class="cn" id="cn5"><tt class="docutils literal"><span class="pre">django.contrib</span></tt> 开发包共有的特性是: 就算你将整个<tt class="docutils literal"><span class="pre">django.contrib</span></tt>开发包删除，你依然可以使用 Django 的基础功能而不会遇到任何问题。 当 Django 开发者向框架增加新功能的时，他们会严格根据这一原则来决定是否把新功能放入<tt class="docutils literal"><span class="pre">django.contrib</span></tt>中。</p><p class="cn" id="cn6"><tt class="docutils literal"><span class="pre">django.contrib</span></tt> 由以下开发包组成：</p><ul class="simple"><li class="cn" id="cn7"><p class="first cn" id="cn7"><tt class="docutils literal"><span class="pre">admin</span></tt> : 自动化的站点管理工具。 请查看第6章。</p></li></ul><ul class="simple"><li class="cn" id="cn8"><p class="first cn" id="cn8"><tt class="docutils literal"><span class="pre">admindocs</span></tt>:为Django admin站点提供自动文档。 本书没有介绍这方面的知识；详情请参阅Django官方文档。</p></li></ul><ul class="simple"><li class="cn" id="cn9"><p class="first cn" id="cn9"><tt class="docutils literal"><span class="pre">auth</span></tt> : Django的用户验证框架。 参见第十四章。</p></li></ul><ul class="simple"><li class="cn" id="cn10"><p class="first cn" id="cn10"><tt class="docutils literal"><span class="pre">comments</span></tt> : 一个评论应用，目前，这个应用正在紧张的开发中，因此在本书出版的时候还不能给出一个完整的说明，关于这个应用的更多信息请参见Django的官方网站. 本书没有介绍这方面的知识；详情请参阅Django官方文档。</p></li></ul><ul class="simple"><li class="cn" id="cn11"><p class="first cn" id="cn11"><tt class="docutils literal"><span class="pre">contenttypes</span></tt> : 这是一个用于引入文档类型的框架，每个安装的Django模块作为一种独立的文档类型。 这个框架主要在Django内部被其他应用使用，它主要面向Django的高级开发者。 可以通过阅读源码来了解关于这个框架的更多信息，源码的位置在 <tt class="docutils literal"><span class="pre">django/contrib/contenttypes/</span></tt>。</p></li></ul><ul class="simple"><li class="cn" id="cn12"><p class="first cn" id="cn12"><tt class="docutils literal"><span class="pre">csrf</span></tt> : 这个模块用来防御跨站请求伪造(CSRF)。参 见后面标题为&#8221;CSRF 防御&#8221;的小节。</p></li></ul><ul class="simple"><li class="cn" id="cn13"><p class="first cn" id="cn13"><tt class="docutils literal"><span class="pre">databrowse</span></tt>：帮助你浏览数据的Django应用。 本书没有介绍这方面的知识；详情请参阅Django官方文档。</p></li></ul><ul class="simple"><li class="cn" id="cn14"><p class="first cn" id="cn14"><tt class="docutils literal"><span class="pre">flatpages</span></tt> : 一个在数据库中管理单一HTML内容的模块。 参见后面标题为“Flatpages”的小节。</p></li></ul><ul class="simple"><li class="cn" id="cn15"><p class="first cn" id="cn15"><tt class="docutils literal"><span class="pre">formtools</span></tt>：一些列处理表单通用模式的高级库。 本书没有介绍这方面的知识；详情请参阅Django官方文档。</p></li></ul><ul class="simple"><li class="cn" id="cn16"><p class="first cn" id="cn16"><tt class="docutils literal"><span class="pre">gis</span></tt>：为Django提供GIS（Geographic Information Systems）支持的扩展。 举个例子，它允许你的Django模型保存地理学数据并执行地理学查询。 这个库比较复杂，本书不详细介绍。 请参看<a class="reference external" href="http://geodjango.org/">http://geodjango.org/</a>上的文档。</p></li></ul><ul class="simple"><li class="cn" id="cn17"><p class="first cn" id="cn17"><tt class="docutils literal"><span class="pre">humanize</span></tt> : 一系列 Django 模块过滤器，用于增加数据的人性化。参阅稍后的章节《人性化数据》。</p></li></ul><ul class="simple"><li class="cn" id="cn18"><p class="first cn" id="cn18"><tt class="docutils literal"><span class="pre">localflavor</span></tt>：针对不同国家和文化的混杂代码段。 例如，它包含了验证美国的邮编 以及爱尔兰的身份证号的方法。</p></li></ul><ul class="simple"><li class="cn" id="cn19"><p class="first cn" id="cn19"><tt class="docutils literal"><span class="pre">markup</span></tt> : 一系列的 Django 模板过滤器，用于实现一些常用标记语言。 参阅后续章节《标记过滤器》。</p></li></ul><ul class="simple"><li class="cn" id="cn20"><p class="first cn" id="cn20"><tt class="docutils literal"><span class="pre">redirects</span></tt> : 用来管理重定向的框架。 参看后面的“重定向”小节。</p></li></ul><ul class="simple"><li class="cn" id="cn21"><p class="first cn" id="cn21"><tt class="docutils literal"><span class="pre">sessions</span></tt> : Django 的会话框架。 参见14章。</p></li></ul><ul class="simple"><li class="cn" id="cn22"><p class="first cn" id="cn22"><tt class="docutils literal"><span class="pre">sitemaps</span></tt> : 用来生成网站地图的 XML 文件的框架。 参见13章。</p></li></ul><ul class="simple"><li class="cn" id="cn23"><p class="first cn" id="cn23"><tt class="docutils literal"><span class="pre">sites</span></tt> : 一个让你可以在同一个数据库与 Django 安装中管理多个网站的框架。 参见下一节：</p></li></ul><ul class="simple"><li class="cn" id="cn24"><p class="first cn" id="cn24"><tt class="docutils literal"><span class="pre">syndication</span></tt> : 一个用 RSS 和 Atom 来生成聚合订阅源的的框架。 参见13章。</p></li></ul><ul class="simple"><li class="cn" id="cn25"><p class="first cn" id="cn25"><tt class="docutils literal"><span class="pre">webdesign</span></tt>：对设计者非常有用的Django扩展。 到编写此文时，它只包含一个模板标签<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">lorem</span> <span class="pre">%}</span></tt>。详情参阅Django文档。</p></li></ul><p class="cn" id="cn26">本章接下来将详细描述前面没有介绍过的 <tt class="docutils literal"><span class="pre">django.contrib</span></tt> 开发包内容。</p></div><div class="section" id="id1"><span id="cn27"></span><h2 class="cn" id="cn27">多个站点</h2><p class="cn" id="cn28">Django 的多站点系统是一种通用框架，它让你可以在同一个数据库和同一个Django项目下操作多个网站。 这是一个抽象概念，理解起来可能有点困难，因此我们从几个让它能派上用场的实际情景入手。</p><div class="section" id="id2"><span id="cn29"></span><h3 class="cn" id="cn29">情景1：多站点间复用数据</h3><p class="cn" id="cn30">正如我们在第一章里所讲，Django 构建的网站 LJWorld.com 和 Lawrance.com 是用由同一个新闻组织控制的： 肯萨斯州劳伦斯市的 <em>劳伦斯日报世界</em> 报纸。 LJWorld.com 主要做新闻，而 Lawrence.com 关注本地娱乐。 然而有时，编辑可能需要把一篇文章发布到 <em>两个</em> 网站上。</p><p class="cn" id="cn31">解决此问题的死脑筋方法可能是使用每个站点分别使用不同的数据库，然后要求站点维护者把同一篇文章发布两次： 一次为 LJWorld.com，另一次为Lawrence.com。 但这对站点管理员来说是低效率的，而且为同一篇文章在数据库里保留多个副本也显得多余。</p><p class="cn" id="cn32">更好的解决方案？ 两个网站用的是同一个文章数据库，并将每一篇文章与一个或多个站点用多对多关系关联起来。 Django 站点框架提供数据库表来记载哪些文章可以被关联。 它是一个把数据与一个或多个站点关联起来的钩子。</p></div><div class="section" id="id3"><span id="cn33"></span><h3 class="cn" id="cn33">情景2：把网站的名字/域名保存在一个地方</h3><p class="cn" id="cn34">LJWorld.com 和 Lawrence.com 都有邮件提醒功能，使读者注册后可以在新闻发生后立即收到通知。 这是一种完美的的机制： 某读者提交了注册表单，然后马上就受到一封内容是“感谢您的注册”的邮件。</p><p class="cn" id="cn35">把这个注册过程的代码实现两遍显然是低效、多余的，因此两个站点在后台使用相同的代码。 但感谢注册的通知在两个网站中需要不同。 通过使用 <tt class="docutils literal"><span class="pre">Site</span></tt> 对象，我们通过使用当前站点的 <tt class="docutils literal"><span class="pre">name</span></tt> (例如 <tt class="docutils literal"><span class="pre">'LJWorld.com'</span></tt> )和 <tt class="docutils literal"><span class="pre">domain</span></tt> (例如 <tt class="docutils literal"><span class="pre">'www.ljworld.com'</span></tt> )可以把感谢通知抽提出来。</p><p class="cn" id="cn36">Django 的多站点框架为你提供了一个位置来存储 Django 项目中每个站点的 <tt class="docutils literal"><span class="pre">name</span></tt> 和 <tt class="docutils literal"><span class="pre">domain</span></tt> ，这意味着你可以用同样的方法来重用这些值。</p></div><div class="section" id="id4"><span id="cn37"></span><h3 class="cn" id="cn37">如何使用多站点框架</h3><p class="cn" id="cn38">多站点框架与其说是一个框架，不如说是一系列约定。 所有的一切都基于两个简单的概念：</p><ul class="simple"><li class="cn" id="cn39"><p class="first cn" id="cn39">位于 <tt class="docutils literal"><span class="pre">django.contrib.sites</span></tt> 的 <tt class="docutils literal"><span class="pre">Site</span></tt> 模型有 <tt class="docutils literal"><span class="pre">domain</span></tt> 和 <tt class="docutils literal"><span class="pre">name</span></tt> 两个字段。</p></li></ul><ul class="simple"><li class="cn" id="cn40"><p class="first cn" id="cn40"><tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置指定了与特定配置文件相关联的 <tt class="docutils literal"><span class="pre">Site</span></tt> 对象之数据库 ID。</p></li></ul><p class="cn" id="cn41">如何运用这两个概念由你决定，但 Django 是通过几个简单的约定自动使用的。</p><p class="cn" id="cn42">安装多站点应用要执行以下几个步骤：</p><ol class="arabic simple"><li class="cn" id="cn43"><p class="first cn" id="cn43">将 <tt class="docutils literal"><span class="pre">'django.contrib.sites'</span></tt> 加入到 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn44"><p class="first cn" id="cn44">运行 <cite>manage.py syncdb</cite> 命令将 <cite>django_site</cite> 表安装到数据库中。 这样也会建立默认的站点对象，域名为 example.com。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn45"><p class="first cn" id="cn45">把<tt class="docutils literal"><span class="pre">example.com</span></tt>改成你自己的域名，然后通过Django admin站点或Python API来添加其他<tt class="docutils literal"><span class="pre">Site</span></tt>对象。 为该 Django 项目支撑的每个站（或域）创建一个 <tt class="docutils literal"><span class="pre">Site</span></tt> 对象。</p></li></ol><ol class="arabic simple" start="4"><li class="cn" id="cn46"><p class="first cn" id="cn46">在每个设置文件中定义一个 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 变量。 该变量值应当是该设置文件所支撑的站点<tt class="docutils literal"><span class="pre">Site</span></tt> 对象的数据库 ID。</p></li></ol></div><div class="section" id="id5"><span id="cn47"></span><h3 class="cn" id="cn47">多站点框架的功能</h3><p class="cn" id="cn48">下面几节讲述的是用多站点框架能够完成的几项工作。</p><div class="section" id="id6"><span id="cn49"></span><h4 class="cn" id="cn49">多个站点的数据重用</h4><p class="cn" id="cn50">正如在情景一中所解释的，要在多个站点间重用数据,仅需在模型中为 <tt class="docutils literal"><span class="pre">Site</span></tt> 添加一个 <tt class="docutils literal"><span class="pre">多对多字段</span></tt> 即可，例如：</p><pre class="cn literal-block" id="cn52">from django.db import modelsfrom django.contrib.sites.models import Siteclass Article(models.Model):headline = models.CharField(max_length=200)# ...sites = models.ManyToManyField(Site)</pre><p class="cn" id="cn53">这是在数据库中为多个站点进行文章关联操作的基础步骤。在适当的位置使用该技术，你可以在多个站点中重复使用同一段 Django 视图代码。 继续 <tt class="docutils literal"><span class="pre">Article</span></tt> 模型范例，下面是一个可能的 <tt class="docutils literal"><span class="pre">article_detail</span></tt> 视图：</p><pre class="cn literal-block" id="cn55">from django.conf import settingsfrom django.shortcuts import get_object_or_404from mysite.articles.models import Articledef article_detail(request, article_id):a = get_object_or_404(Article, id=article_id, sites__id=settings.SITE_ID)# ...</pre><p class="cn" id="cn56">该视图方法是可重用的，因为它根据 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置的值动态检查 articles 站点。</p><p class="cn" id="cn57">例如， LJWorld.coms 设置文件中有有个 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置为 <tt class="docutils literal"><span class="pre">1</span></tt> ，而 Lawrence.coms 设置文件中有个 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置为 <tt class="docutils literal"><span class="pre">2</span></tt> 。如果该视图在 LJWorld.coms 处于激活状态时被调用，那么它将把查找范围局限于站点列表包括 LJWorld.com 在内的文章。</p></div><div class="section" id="id7"><span id="cn58"></span><h4 class="cn" id="cn58">将内容与单一站点相关联</h4><p class="cn" id="cn59">同样，你也可以使用 <tt class="docutils literal"><span class="pre">外键</span></tt> 在多对一关系中将一个模型关联到 <tt class="docutils literal"><span class="pre">Site</span></tt> 模型。</p><p class="cn" id="cn60">举例来说，如果某篇文章仅仅能够出现在一个站点上，你可以使用下面这样的模型：</p><pre class="cn literal-block" id="cn62">from django.db import modelsfrom django.contrib.sites.models import Siteclass Article(models.Model):headline = models.CharField(max_length=200)# ...site = models.ForeignKey(Site)</pre><p class="cn" id="cn63">这与前一节中介绍的一样有益。</p></div><div class="section" id="id8"><span id="cn64"></span><h4 class="cn" id="cn64">从视图钩挂当前站点</h4><p class="cn" id="cn65">在底层，通过在 Django 视图中使用多站点框架，你可以让视图根据调用站点不同而完成不同的工作，例如：</p><pre class="cn literal-block" id="cn67">from django.conf import settingsdef my_view(request):if settings.SITE_ID == 3:# Do something.else:# Do something else.</pre><p class="cn" id="cn68">当然，像那样对站点 ID 进行硬编码是比较难看的。 略为简洁的完成方式是查看当前的站点域：</p><pre class="cn literal-block" id="cn70">from django.conf import settingsfrom django.contrib.sites.models import Sitedef my_view(request):current_site = Site.objects.get(id=settings.SITE_ID)if current_site.domain == 'foo.com':# Do somethingelse:# Do something else.</pre><p class="cn" id="cn71">从 <tt class="docutils literal"><span class="pre">Site</span></tt> 对象中获取 <tt class="docutils literal"><span class="pre">settings.SITE_ID</span></tt> 值的做法比较常见，因此 <tt class="docutils literal"><span class="pre">Site</span></tt> 模型管理器 (<tt class="docutils literal"><span class="pre">Site.objects</span></tt> ) 具备一个 <tt class="docutils literal"><span class="pre">get_current()</span></tt> 方法。下面的例子与前一个是等效的：</p><pre class="cn literal-block" id="cn73">from django.contrib.sites.models import Sitedef my_view(request):current_site = Site.objects.get_current()if current_site.domain == 'foo.com':# Do somethingelse:# Do something else.</pre><p class="cn" id="cn74">注意</p><p class="cn" id="cn75">在这个最后的例子里，你不用导入 <tt class="docutils literal"><span class="pre">django.conf.settings</span></tt> 。</p></div><div class="section" id="id9"><span id="cn76"></span><h4 class="cn" id="cn76">获取当前域用于呈现</h4><p class="cn" id="cn77">正如情景二中所解释的那样，依据DRY原则(不做重复工作)，你只需在一个位置储存站名和域名，然后引用当前 <tt class="docutils literal"><span class="pre">Site</span></tt> 对象的 <tt class="docutils literal"><span class="pre">name</span></tt> 和 <tt class="docutils literal"><span class="pre">domain</span></tt> 。例如： 例如：</p><pre class="cn literal-block" id="cn79">from django.contrib.sites.models import Sitefrom django.core.mail import send_maildef register_for_newsletter(request):# Check form values, etc., and subscribe the user.# ...current_site = Site.objects.get_current()send_mail('Thanks for subscribing to %s alerts' % current_site.name,'Thanks for your subscription. We appreciate it.\n\n-The %s team.' % current_site.name,'editor&#64;%s' % current_site.domain,[user_email])# ...</pre><p class="cn" id="cn80">继续我们正在讨论的 LJWorld.com 和 Lawrence.com 例子，在Lawrence.com 该邮件的标题行是“感谢注册 Lawrence.com 提醒信件”。 在 LJWorld.com ，该邮件标题行是“感谢注册 LJWorld.com 提醒信件”。 这种站点关联行为方式对邮件信息主体也同样适用。</p><p class="cn" id="cn81">完成这项工作的一种更加灵活（但更重量级）的方法是使用 Django 的模板系统。 假定 Lawrence.com 和 LJWorld.com 各自拥有不同的模板目录（ <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> ），你可将工作轻松地转交给模板系统，如下所示：</p><pre class="cn literal-block" id="cn83">from django.core.mail import send_mailfrom django.template import loader, Contextdef register_for_newsletter(request):# Check form values, etc., and subscribe the user.# ...subject = loader.get_template('alerts/subject.txt').render(Context({}))message = loader.get_template('alerts/message.txt').render(Context({}))send_mail(subject, message, 'do-not-reply&#64;example.com', [user_email])# ...</pre><p class="cn" id="cn84">本例中，你不得不在 LJWorld.com 和 Lawrence.com 的模板目录中都创建一份 <tt class="docutils literal"><span class="pre">subject.txt</span></tt> 和 <tt class="docutils literal"><span class="pre">message.txt</span></tt> 模板。 正如之前所说，该方法带来了更大的灵活性，但也带来了更多复杂性。</p><p class="cn" id="cn85">尽可能多的利用 <tt class="docutils literal"><span class="pre">Site</span></tt> 对象是减少不必要的复杂、冗余工作的好办法。</p></div></div><div class="section" id="id10"><span id="cn86"></span><h3 class="cn" id="cn86">当前站点管理器</h3><p class="cn" id="cn87">如果 <tt class="docutils literal"><span class="pre">站点</span></tt> 在你的应用中扮演很重要的角色，请考虑在你的模型中使用方便的 <tt class="docutils literal"><span class="pre">CurrentSiteManager</span></tt> 。 这是一个模型管理器（见第十章），它会自动过滤使其只包含与当前站点相关联的对象。</p><p class="cn" id="cn88">通过显示地将 <tt class="docutils literal"><span class="pre">CurrentSiteManager</span></tt> 加入模型中以使用它。 例如：</p><pre class="cn literal-block" id="cn90">from django.db import modelsfrom django.contrib.sites.models import Sitefrom django.contrib.sites.managers import CurrentSiteManagerclass Photo(models.Model):photo = models.FileField(upload_to='/home/photos')photographer_name = models.CharField(max_length=100)pub_date = models.DateField()site = models.ForeignKey(Site)objects = models.Manager()on_site = CurrentSiteManager()</pre><p class="cn" id="cn91">通过该模型， <tt class="docutils literal"><span class="pre">Photo.objects.all()</span></tt> 将返回数据库中所有的 <tt class="docutils literal"><span class="pre">Photo</span></tt> 对象，而 <tt class="docutils literal"><span class="pre">Photo.on_site.all()</span></tt> 仅根据 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置返回与当前站点相关联的 <tt class="docutils literal"><span class="pre">Photo</span></tt> 对象。</p><p class="cn" id="cn92">换言之，以下两条语句是等效的：</p><pre class="cn literal-block" id="cn94">Photo.objects.filter(site=settings.SITE_ID)Photo.on_site.all()</pre><p class="cn" id="cn95"><tt class="docutils literal"><span class="pre">CurrentSiteManager</span></tt> 是如何知道 <tt class="docutils literal"><span class="pre">Photo</span></tt> 的哪个字段是 <tt class="docutils literal"><span class="pre">Site</span></tt> 呢？缺省情况下，它会查找一个叫做 <tt class="docutils literal"><span class="pre">site</span></tt> 的字段。如果你的模型包含了名字<tt class="docutils literal"><span class="pre">不是</span></tt><tt class="docutils literal"><span class="pre">site</span></tt>的<em>外键</em>或者<tt class="docutils literal"><span class="pre">多对多</span></tt>关联，你需要把它作为参数传给<tt class="docutils literal"><span class="pre">CurrentSiteManager</span></tt>以显示指明。下面的模型拥有一个<tt class="docutils literal"><span class="pre">publish_on</span></tt>字段：</p><pre class="cn literal-block" id="cn97">from django.db import modelsfrom django.contrib.sites.models import Sitefrom django.contrib.sites.managers import CurrentSiteManagerclass Photo(models.Model):photo = models.FileField(upload_to='/home/photos')photographer_name = models.CharField(max_length=100)pub_date = models.DateField()publish_on = models.ForeignKey(Site)objects = models.Manager()on_site = CurrentSiteManager('publish_on')</pre><p class="cn" id="cn98">如果试图使用 <tt class="docutils literal"><span class="pre">CurrentSiteManager</span></tt> 并传入一个不存在的字段名， Django 将引发一个 <tt class="docutils literal"><span class="pre">ValueError</span></tt> 异常。</p><p class="cn" id="cn99">注意</p><p class="cn" id="cn100">即便是已经使用了 <tt class="docutils literal"><span class="pre">CurrentSiteManager</span></tt> ，你也许还想在模型中拥有一个正常的（非站点相关）的 <tt class="docutils literal"><span class="pre">管理器</span></tt> 。正如在附录 B 中所解释的，如果你手动定义了一个管理器，那么 Django 不会为你创建全自动的 <tt class="docutils literal"><span class="pre">objects</span> <span class="pre">=</span> <span class="pre">models.Manager()</span></tt> 管理器。</p><p class="cn" id="cn101">同样，Django 的特定部分（即 Django 超级管理站点和通用视图）使用在模型中定义 的<em>第一个</em>管理器，因此如果希望管理站点能够访问所有对象（而不是仅仅站点特有对象），请于定义 <tt class="docutils literal"><span class="pre">CurrentSiteManager</span></tt> 之前在模型中放入 <tt class="docutils literal"><span class="pre">objects</span> <span class="pre">=</span> <span class="pre">models.Manager()</span></tt> 。</p></div><div class="section" id="id11"><span id="cn102"></span><h3 class="cn" id="cn102">Django如何使用多站点框架</h3><p class="cn" id="cn103">尽管并不是必须的，我们还是强烈建议使用多站点框架，因为 Django 在几个地方利用了它。 即使只用 Django 来支持单个网站，你也应该花一点时间用 <tt class="docutils literal"><span class="pre">domain</span></tt> 和 <tt class="docutils literal"><span class="pre">name</span></tt> 来创建站点对象，并将 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置指向它的 ID 。</p><p class="cn" id="cn104">以下讲述的是 Django 如何使用多站点框架：</p><ul class="simple"><li class="cn" id="cn105"><p class="first cn" id="cn105">在重定向框架中（见后面的重定向一节），每一个重定向对象都与一个特定站点关联。 当 Django 搜索重定向的时候，它会考虑当前的 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn106"><p class="first cn" id="cn106">在注册框架中，每个注释都与特定站点相关。 每个注释被显示时，其 <tt class="docutils literal"><span class="pre">site</span></tt> 被设置为当前的 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> ，而当通过适当的模板标签列出注释时，只有当前站点的注释将会显示。</p></li></ul><ul class="simple"><li class="cn" id="cn107"><p class="first cn" id="cn107">在 flatpages 框架中 (参见后面的 Flatpages 一节），每个 flatpage 都与特定的站点相关联。 创建 flatpage 时，你都将指定它的 <tt class="docutils literal"><span class="pre">site</span></tt> ，而 flatpage 中间件在获取 flatpage 以显示它的过程中，将查看当前的 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn108"><p class="first cn" id="cn108">在 syndication 框架中（参阅第 13 章）， <tt class="docutils literal"><span class="pre">title</span></tt> 和 <tt class="docutils literal"><span class="pre">description</span></tt> 的模板会自动访问变量 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">site</span> <span class="pre">}}</span></tt> ，它其实是代表当前站点的 <tt class="docutils literal"><span class="pre">Site</span></tt> 对象。 而且，如果你不指定一个合格的domain的话，提供目录URL的钩子将会使用当前“Site”对象的domain。</p></li></ul><ul class="simple"><li class="cn" id="cn109"><p class="first cn" id="cn109">在权限框架中（参见十四章），视图<tt class="docutils literal"><span class="pre">django.contrib.auth.views.login</span></tt>把当前<tt class="docutils literal"><span class="pre">Site</span></tt>名字和对象分别以<tt class="docutils literal"><span class="pre">{{</span> <span class="pre">site_name</span> <span class="pre">}}</span></tt>和<tt class="docutils literal"><span class="pre">{{</span> <span class="pre">site</span> <span class="pre">}}</span></tt>的形式传给了模板。</p></li></ul></div></div><div class="section" id="flatpages"><span id="cn110"></span><h2 class="cn" id="cn110">Flatpages(简单页面)</h2><p class="cn" id="cn111">尽管通常情况下总是搭建运行数据库驱动的 Web 应用，有时你还是需要添加一两张一次性的静态页面，例如“关于”页面，或者“隐私策略”页面等等。 可以用像 Apache 这样的标准Web服务器来处理这些静态页面，但却会给应用带来一些额外的复杂性，因为你必须操心怎么配置 Apache，还要设置权限让整个团队可以修改编辑这些文件，而且你还不能使用 Django 模板系统来统一这些页面的风格。</p><p class="cn" id="cn112">这个问题的解决方案是使用位于 <tt class="docutils literal"><span class="pre">django.contrib.flatpages</span></tt> 开发包中的 Django 简单页面（flatpages）应用程序。该应用让你能够通过 Django 管理站点来管理这些一次性的页面，还可以让你使用 Django 模板系统指定它们使用哪个模板。 它在后台使用Django模型，这意味着它把页面项别的数据一样保存在数据库中，也就是说你可以使用标准Django数据库API来存取页面。</p><p class="cn" id="cn113">简单页面以它们的 URL 和站点为键值。 当创建简单页面时，你指定它与哪个URL以及和哪个站点相关联 。 （有关站点的更多信息，请查阅”多站点“一节。）</p><div class="section" id="id12"><span id="cn114"></span><h3 class="cn" id="cn114">使用简单页面</h3><p class="cn" id="cn115">安装简单页面应用程序必须按照下面的步骤：</p><ol class="arabic simple"><li class="cn" id="cn116"><p class="first cn" id="cn116">添加 <tt class="docutils literal"><span class="pre">'django.contrib.flatpages'</span></tt> 到 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置。<tt class="docutils literal"><span class="pre">django.contrib.flatpages</span></tt>依赖<tt class="docutils literal"><span class="pre">django.contrib.sites</span></tt>，所以确保它们都在<tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt>里。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn117"><p class="first cn" id="cn117">将 <tt class="docutils literal"><span class="pre">'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware'</span></tt> 添加到 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 设置中。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn118"><p class="first cn" id="cn118">运行 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">syncdb</span></tt> 命令在数据库中创建必需的两个表。</p></li></ol><p class="cn" id="cn119">简单页面应用程序在数据库中创建两个表： <tt class="docutils literal"><span class="pre">django_flatpage</span></tt> 和 <tt class="docutils literal"><span class="pre">django_flatpage_sites</span></tt> 。 <tt class="docutils literal"><span class="pre">django_flatpage</span></tt> 只是将 URL 映射到标题和一段文本内容。 <tt class="docutils literal"><span class="pre">django_flatpage_sites</span></tt> 是一个多对多表，用于关联某个简单页面以及一个或多个站点。</p><p class="cn" id="cn120">该应用捆绑的 <tt class="docutils literal"><span class="pre">FlatPage</span></tt> 模型在 <tt class="docutils literal"><span class="pre">django/contrib/flatpages/models.py</span></tt> 进行定义，如下所示：</p><pre class="cn literal-block" id="cn122">from django.db import modelsfrom django.contrib.sites.models import Siteclass FlatPage(models.Model):url = models.CharField(max_length=100, db_index=True)title = models.CharField(max_length=200)content = models.TextField(blank=True)enable_comments = models.BooleanField()template_name = models.CharField(max_length=70, blank=True)registration_required = models.BooleanField()sites = models.ManyToManyField(Site)</pre><p class="cn" id="cn123">让我们逐项看看这些字段的含义：</p><ul class="simple"><li class="cn" id="cn124"><p class="first cn" id="cn124"><tt class="docutils literal"><span class="pre">url</span></tt> : 该简单页面所处的 URL，不包括域名，但是包含前导斜杠 (例如 <tt class="docutils literal"><span class="pre">/about/contact/</span></tt> )。</p></li></ul><ul class="simple"><li class="cn" id="cn125"><p class="first cn" id="cn125"><tt class="docutils literal"><span class="pre">title</span></tt> : 简单页面的标题。 框架不对它作任何特殊处理。由你通过模板来显示它。</p></li></ul><ul class="simple"><li class="cn" id="cn126"><p class="first cn" id="cn126"><tt class="docutils literal"><span class="pre">content</span></tt> : 简单页面的内容 (即 HTML 页面)。 框架不对它作任何特殊处理。 由你负责使用模板来显示。</p></li></ul><ul class="simple"><li class="cn" id="cn127"><p class="first cn" id="cn127"><tt class="docutils literal"><span class="pre">enable_comments</span></tt> : 是否允许该简单页面使用评论。 框架不对它作任何特殊处理。 你可在模板中检查该值并根据需要显示评论窗体。</p></li></ul><ul class="simple"><li class="cn" id="cn128"><p class="first cn" id="cn128"><tt class="docutils literal"><span class="pre">template_name</span></tt> : 用来解析该简单页面的模板名称。 这是一个可选项；如果未指定模板或该模板不存在，系统会退而使用默认模板 <tt class="docutils literal"><span class="pre">flatpages/default.html</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn129"><p class="first cn" id="cn129"><tt class="docutils literal"><span class="pre">registration_required</span></tt> : 是否注册用户才能查看此简单页面。该设置项集成了 Djangos 验证/用户框架，该框架于第十四章详述。</p></li></ul><ul class="simple"><li class="cn" id="cn130"><p class="first cn" id="cn130"><tt class="docutils literal"><span class="pre">sites</span></tt> : 该简单页面放置的站点。 该项设置集成了 Django 多站点框架，该框架在本章的“多站点”一节中有所阐述。</p></li></ul><p class="cn" id="cn131">你可以通过 Django 超级管理界面或者 Django 数据库 API 来创建简单页面。要了解更多内容，请查阅“添加、修改和删除简单页面”一节。</p><p class="cn" id="cn132">一旦简单页面创建完成， <tt class="docutils literal"><span class="pre">FlatpageFallbackMiddleware</span></tt> 将完成（剩下）所有的工作。 每当 Django 引发 404 错误，作为最后的办法，该中间件将根据所请求的 URL 检查简单页面数据库。 确切地说，它将使用所指定的 URL以及 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置对应的站点 ID 查找一个简单页面。</p><p class="cn" id="cn133">如果找到一个匹配项，它将载入该简单页面的模板（如果没有指定的话，将使用默认模板 <tt class="docutils literal"><span class="pre">flatpages/default.html</span></tt> ）。 同时，它把一个简单的上下文变量<tt class="docutils literal"><span class="pre">flatpage</span></tt>（一个简单页面对象）传递给模板。 模板解析过程中，它实际用的是<tt class="docutils literal"><span class="pre">RequestContext</span></tt>。</p><p class="cn" id="cn134">如果 <tt class="docutils literal"><span class="pre">FlatpageFallbackMiddleware</span></tt> 没有找到匹配项，该请求继续如常处理。</p><p class="cn" id="cn135">注意</p><p class="cn" id="cn136">该中间件仅在发生 404 （页面未找到）错误时被激活，而不会在 500 （服务器错误）或其他错误响应时被激活。 还要注意的是必须考虑 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 的顺序问题。通常，你可以把 <tt class="docutils literal"><span class="pre">FlatpageFallbackMiddleware</span></tt> 放在列表最后，因为它是最后的办法。</p></div><div class="section" id="id13"><span id="cn137"></span><h3 class="cn" id="cn137">添加、修改和删除简单页面</h3><p class="cn" id="cn138">可以用两种方式增加、变更或删除简单页面：</p><div class="section" id="id14"><span id="cn139"></span><h4 class="cn" id="cn139">通过超级管理界面</h4><p class="cn" id="cn140">如果已经激活了自动的 Django 超级管理界面，你将会在超级管理页面的首页看到有个 Flatpages 区域。 你可以像编辑系统中其它对象那样编辑简单页面。</p></div><div class="section" id="python-api"><span id="cn141"></span><h4 class="cn" id="cn141">通过 Python API</h4><p class="cn" id="cn142">前面已经提到，简单页面表现为 <tt class="docutils literal"><span class="pre">django/contrib/flatpages/models.py</span></tt> 中的标准 Django 模型。这样，你就可以使用Django数据库API来存取简单页面对象，例如：</p><pre class="cn literal-block" id="cn144">&gt;&gt;&gt; from django.contrib.flatpages.models import FlatPage&gt;&gt;&gt; from django.contrib.sites.models import Site&gt;&gt;&gt; fp = FlatPage.objects.create(...     url='/about/',...     title='About',...     content='&lt;p&gt;About this site...&lt;/p&gt;',...     enable_comments=False,...     template_name='',...     registration_required=False,... )&gt;&gt;&gt; fp.sites.add(Site.objects.get(id=1))&gt;&gt;&gt; FlatPage.objects.get(url='/about/')&lt;FlatPage: /about/ -- About&gt;</pre></div></div><div class="section" id="id15"><span id="cn145"></span><h3 class="cn" id="cn145">使用简单页面模板</h3><p class="cn" id="cn146">缺省情况下，系统使用模板 <tt class="docutils literal"><span class="pre">flatpages/default.html</span></tt> 来解析简单页面，但你也可以通过设定 <tt class="docutils literal"><span class="pre">FlatPage</span></tt> 对象的 <tt class="docutils literal"><span class="pre">template_name</span></tt> 字段来更改特定简单页面的模板。</p><p class="cn" id="cn147">你必须自己创建 <tt class="docutils literal"><span class="pre">flatpages/default.html</span></tt> 模板。 只需要在模板目录创建一个 <tt class="docutils literal"><span class="pre">flatpages</span></tt> 目录，并把 <tt class="docutils literal"><span class="pre">default.html</span></tt> 文件置于其中。</p><p class="cn" id="cn148">简单页面模板只接受有一个上下文变量—— <tt class="docutils literal"><span class="pre">flatpage</span></tt> ，也就是该简单页面对象。</p><p class="cn" id="cn149">以下是一个 <tt class="docutils literal"><span class="pre">flatpages/default.html</span></tt> 模板范例:</p><pre class="cn literal-block" id="cn151">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;{{ flatpage.title }}&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{{ flatpage.content|safe }}&lt;/body&gt;&lt;/html&gt;</pre><p class="cn" id="cn152">注意我们使用了<tt class="docutils literal"><span class="pre">safe</span></tt>模板过滤器来允许<tt class="docutils literal"><span class="pre">flatpage.content</span></tt>引入原始HTML而不必转义。</p></div></div><div class="section" id="id16"><span id="cn153"></span><h2 class="cn" id="cn153">重定向</h2><p class="cn" id="cn154">通过将重定向存储在数据库中并将其视为 Django 模型对象，Django 重定向框架让你能够轻松地管理它们。 比如说，你可以通过重定向框架告诉Django，把任何指向 <tt class="docutils literal"><span class="pre">/music/</span></tt> 的请求重定向到 <tt class="docutils literal"><span class="pre">/sections/arts/music/</span></tt> 。当你需要在站点中移动一些东西时，这项功能就派上用场了——网站开发者应该穷尽一切办法避免出现坏链接。</p><div class="section" id="id17"><span id="cn155"></span><h3 class="cn" id="cn155">使用重定向框架</h3><p class="cn" id="cn156">安装重定向应用程序必须遵循以下步骤：</p><ol class="arabic simple"><li class="cn" id="cn157"><p class="first cn" id="cn157">将 <tt class="docutils literal"><span class="pre">'django.contrib.redirects'</span></tt> 添加到 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置中。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn158"><p class="first cn" id="cn158">将 <tt class="docutils literal"><span class="pre">'django.contrib.redirects.middleware.RedirectFallbackMiddleware'</span></tt> 添加到 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 设置中。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn159"><p class="first cn" id="cn159">运行 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">syncdb</span></tt> 命令将所需的表添加到数据库中。</p></li></ol><p class="cn" id="cn160"><tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">syncdb</span></tt> 在数据库中创建了一个 <tt class="docutils literal"><span class="pre">django_redirect</span></tt> 表。 这是一个简单的查询表，只有<tt class="docutils literal"><span class="pre">site_id</span></tt>、old_path和new_path三个字段。</p><p class="cn" id="cn161">你可以通过 Django 超级管理界面或者 Django 数据库 API 来创建重定向。要了解更多信息，请参阅“增加、变更和删除重定向”一节。</p><p class="cn" id="cn162">一旦创建了重定向， <tt class="docutils literal"><span class="pre">RedirectFallbackMiddleware</span></tt> 类将完成所有的工作。每当 Django 应用引发一个 404 错误，作为终极手段，该中间件将为所请求的 URL 在重定向数据库中进行查找。 确切地说，它将使用给定的 <tt class="docutils literal"><span class="pre">old_path</span></tt> 以及 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置对应的站点 ID 查找重定向设置。 （查阅前面的“多站点”一节可了解关于 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 和多站点框架的更多细节） 然后，它将执行以下两个步骤：</p><ul class="simple"><li class="cn" id="cn163"><p class="first cn" id="cn163">如果找到了匹配项，并且 <tt class="docutils literal"><span class="pre">new_path</span></tt> 非空，它将重定向到 <tt class="docutils literal"><span class="pre">new_path</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn164"><p class="first cn" id="cn164">如果找到了匹配项，但 <tt class="docutils literal"><span class="pre">new_path</span></tt> 为空，它将发送一个 410 (Gone) HTTP 头信息以及一个空（无内容）响应。</p></li></ul><ul class="simple"><li class="cn" id="cn165"><p class="first cn" id="cn165">如果未找到匹配项，该请求将如常处理。</p></li></ul><p class="cn" id="cn166">该中间件仅为 404 错误激活，而不会为 500 错误或其他任何状态码的响应所激活。</p><p class="cn" id="cn167">注意必须考虑 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 的顺序。 通常，你可以将 <tt class="docutils literal"><span class="pre">RedirectFallbackMiddleware</span></tt> 放置在列表的最后，因为它是一种终极手段。</p><p class="cn" id="cn168">注意</p><p class="cn" id="cn169">如果同时使用重定向和简单页面回退中间件， 必须考虑先检查其中的哪一个（重定向或简单页面）。 我们建议将简单页面放在重定向之前（因此将简单页面中间件放置在重定向中间件之前），但你可能有不同想法。</p></div><div class="section" id="id18"><span id="cn170"></span><h3 class="cn" id="cn170">增加、变更和删除重定向</h3><p class="cn" id="cn171">你可以两种方式增加、变更和删除重定向：</p><div class="section" id="id19"><span id="cn172"></span><h4 class="cn" id="cn172">通过管理界面</h4><p class="cn" id="cn173">如果已经激活了全自动的 Django 超级管理界面，你应该能够在超级管理首页看到重定向区域。 可以像编辑系统中其它对象一样编辑重定向。</p></div><div class="section" id="id20"><span id="cn174"></span><h4 class="cn" id="cn174">同过Python API</h4><p class="cn" id="cn175">重定向表现为<tt class="docutils literal"><span class="pre">django/contrib/redirects/models.py</span></tt> 中的一个标准 Django 模型。因此，你可以通过Django数据库API来存取重定向对象，例如：</p><pre class="cn literal-block" id="cn177">&gt;&gt;&gt; from django.contrib.redirects.models import Redirect&gt;&gt;&gt; from django.contrib.sites.models import Site&gt;&gt;&gt; red = Redirect.objects.create(...     site=Site.objects.get(id=1),...     old_path='/music/',...     new_path='/sections/arts/music/',... )&gt;&gt;&gt; Redirect.objects.get(old_path='/music/')&lt;Redirect: /music/ ---&gt; /sections/arts/music/&gt;</pre></div></div></div><div class="section" id="csrf"><span id="cn178"></span><h2 class="cn" id="cn178">CSRF 防护</h2><p class="cn" id="cn179"><tt class="docutils literal"><span class="pre">django.contrib.csrf</span></tt> 开发包能够防止遭受跨站请求伪造攻击 (CSRF).</p><p class="cn" id="cn180">CSRF, 又叫会话跳转，是一种网站安全攻击技术。 当某个恶意网站在用户未察觉的情况下将其从一个已经通过身份验证的站点诱骗至一个新的 URL 时，这种攻击就发生了，因此它可以利用用户已经通过身份验证的状态。 乍一看，要理解这种攻击技术比较困难，因此我们在本节将使用两个例子来说明。</p><div class="section" id="id21"><span id="cn181"></span><h3 class="cn" id="cn181">一个简单的 CSRF 例子</h3><p class="cn" id="cn182">假定你已经登录到 <tt class="docutils literal"><span class="pre">example.com</span></tt> 的网页邮件账号。该网站有一个指向<tt class="docutils literal"><span class="pre">example.com/logout</span></tt>的注销按钮。就是说，注销其实就是访问<tt class="docutils literal"><span class="pre">example.com/logout</span></tt>。</p><p class="cn" id="cn183">通过在（恶意）网页上用隐藏一个指向 URL <tt class="docutils literal"><span class="pre">example.com/logout</span></tt> 的 <tt class="docutils literal"><span class="pre">&lt;iframe&gt;</span></tt> ,恶意网站可以强迫你访问该 URL 。因此，如果你登录 <tt class="docutils literal"><span class="pre">example.com</span></tt> 的网页邮件账号之后，访问了带有指向 <tt class="docutils literal"><span class="pre">example.com/logout</span></tt> 之 <tt class="docutils literal"><span class="pre">&lt;iframe&gt;</span></tt> 的恶意站点，访问该恶意页面的动作将使你登出 <tt class="docutils literal"><span class="pre">example.com</span></tt> 。 Thus, if you&#8217;re logged in to the<tt class="docutils literal"><span class="pre">example.com</span></tt> webmail account and visit the malicious page that has an <tt class="docutils literal"><span class="pre">&lt;iframe&gt;</span></tt> to<tt class="docutils literal"><span class="pre">example.com/logout</span></tt> , the act of visiting the malicious page will log you out from<tt class="docutils literal"><span class="pre">example.com</span></tt> .</p><p class="cn" id="cn184">很明显，登出一个邮件网站也不是什么严重的安全问题。但是同样的攻击可能针对任何相信用户的站点，比如在线银行和电子商务网站。这样的话可能在用户不知情的情况下就下订单付款了。</p></div><div class="section" id="id22"><span id="cn185"></span><h3 class="cn" id="cn185">稍微复杂一点的CSRF例子</h3><p class="cn" id="cn186">在上一个例子中， <tt class="docutils literal"><span class="pre">example.com</span></tt> 应该负部分责任，因为它允许通过 HTTP <tt class="docutils literal"><span class="pre">GET</span></tt> 方法进行状态变更（即登入和登出）。 如果对服务器的状态变更要求使用 HTTP <tt class="docutils literal"><span class="pre">POST</span></tt> 方法，情况就好得多了。但是，即便是强制要求使用 <tt class="docutils literal"><span class="pre">POST</span></tt> 方法进行状态变更操作也易受到 CSRF 攻击。</p><p class="cn" id="cn187">假设 <tt class="docutils literal"><span class="pre">example.com</span></tt> 对登出功能进行了升级，登出 <tt class="docutils literal"><span class="pre">&lt;form&gt;</span></tt> 按钮是通过一个指向 URL <tt class="docutils literal"><span class="pre">example.com/logout</span></tt> 的 <tt class="docutils literal"><span class="pre">POST</span></tt> 动作完成，同时在 <tt class="docutils literal"><span class="pre">&lt;form&gt;</span></tt> 中加入了以下隐藏的字段：</p><pre class="cn literal-block" id="cn189">&lt;input type=&quot;hidden&quot; name=&quot;confirm&quot; value=&quot;true&quot;&gt;</pre><p class="cn" id="cn190">这就确保了用简单的指向<tt class="docutils literal"><span class="pre">example.com/logout</span></tt>的<tt class="docutils literal"><span class="pre">POST</span></tt> 不会让用户登出；要让用户登出，用户必须通过 <tt class="docutils literal"><span class="pre">POST</span></tt> 向 <tt class="docutils literal"><span class="pre">example.com/logout</span></tt> 发送请求  并且发送一个值为&#8217;true&#8217;的POST变量。 <tt class="docutils literal"><span class="pre">confirm</span></tt>。</p><p class="cn" id="cn191">尽管增加了额外的安全机制，这种设计仍然会遭到 CSRF 的攻击——恶意页面仅需一点点改进而已。 攻击者可以针对你的站点设计整个表单，并将其藏身于一个不可见的 <tt class="docutils literal"><span class="pre">&lt;iframe&gt;</span></tt> 中，然后使用 Javascript 自动提交该表单。</p></div><div class="section" id="id23"><span id="cn192"></span><h3 class="cn" id="cn192">防止 CSRF</h3><p class="cn" id="cn193">那么，是否可以让站点免受这种攻击呢？ 第一步，首先确保所有 <tt class="docutils literal"><span class="pre">GET</span></tt> 方法没有副作用。 这样以来，如果某个恶意站点将你的页面包含为 <tt class="docutils literal"><span class="pre">&lt;iframe&gt;</span></tt> ，它将不会产生负面效果。</p><p class="cn" id="cn194">该技术没有考虑 <tt class="docutils literal"><span class="pre">POST</span></tt> 请求。 第二步就是给所有 <tt class="docutils literal"><span class="pre">POST</span></tt> 的form标签一个隐藏字段，它的值是保密的并根据用户进程的 ID 生成。 这样，从服务器端访问表单时，可以检查该保密的字段。不吻合时可以引发一个错误。</p><p class="cn" id="cn195">这正是 Django CSRF 防护层完成的工作，正如下面的小节所介绍的。</p><div class="section" id="id24"><span id="cn196"></span><h4 class="cn" id="cn196">使用CSRF中间件</h4><p class="cn" id="cn197"><tt class="docutils literal"><span class="pre">django.contrib.csrf</span></tt> 开发包只有一个模块： <tt class="docutils literal"><span class="pre">middleware.py</span></tt> 。该模块包含了一个 Django 中间件类—— <tt class="docutils literal"><span class="pre">CsrfMiddleware</span></tt> ，该类实现了 CSRF 防护功能。</p><p class="cn" id="cn198">在设置文件中将 <tt class="docutils literal"><span class="pre">'django.contrib.csrf.middleware.CsrfMiddleware'</span></tt> 添加到 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 设置中可激活 CSRF 防护。 该中间件必须在 <tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> <em>之后</em> 执行，因此在列表中 <tt class="docutils literal"><span class="pre">CsrfMiddleware</span></tt> 必须出现在 <tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt><em>之前</em> （因为响应中间件是自后向前执行的）。同时，它也必须在响应被压缩或解压之前对响应结果进行处理，因此 <tt class="docutils literal"><span class="pre">CsrfMiddleware</span></tt> 必须在 <tt class="docutils literal"><span class="pre">GZipMiddleware</span></tt> 之后执行。一旦将它添加到<tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt>设置中，你就完成了工作。 参见第十五章的“MIDDLEWARE_CLASSES顺序”小节以了解更多。</p><p class="cn" id="cn199">如果感兴趣的话，下面是 <tt class="docutils literal"><span class="pre">CsrfMiddleware</span></tt> 的工作模式。 它完成以下两项工作：</p><ol class="arabic simple"><li class="cn" id="cn200"><p class="first cn" id="cn200">它修改当前处理的请求，向所有的 <tt class="docutils literal"><span class="pre">POST</span></tt> 表单增添一个隐藏的表单字段，使用名称是 <tt class="docutils literal"><span class="pre">csrfmiddlewaretoken</span></tt> ，值为当前会话 ID 加上一个密钥的散列值。 如果未设置会话 ID ，该中间件将 <em>不会</em> 修改响应结果，因此对于未使用会话的请求来说性能损失是可以忽略的。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn201"><p class="first cn" id="cn201">对于所有含会话 cookie 集合的传入 <tt class="docutils literal"><span class="pre">POST</span></tt> 请求，它将检查是否存在 <tt class="docutils literal"><span class="pre">csrfmiddlewaretoken</span></tt> 及其是否正确。 如果不是的话，用户将会收到一个 403 <tt class="docutils literal"><span class="pre">HTTP</span></tt> 错误。 403 错误页面的内容是检测到了跨域请求伪装。 终止请求。</p></li></ol><p class="cn" id="cn202">该步骤确保只有源自你的站点的表单才能将数据 POST 回来。</p><p class="cn" id="cn203">该中间件特意只针对 HTTP <tt class="docutils literal"><span class="pre">POST</span></tt> 请求（以及对应的 POST 表单）。 如我们所解释的，永远不应该因为使用了 <tt class="docutils literal"><span class="pre">GET</span></tt> 请求而产生负面效应，你必须自己来确保这一点。</p><p class="cn" id="cn204">未使用会话 cookie 的 <tt class="docutils literal"><span class="pre">POST</span></tt> 请求无法受到保护，但它们也不 <em>需要</em> 受到保护，因为恶意网站可用任意方法来制造这种请求。</p><p class="cn" id="cn205">为了避免转换非 HTML 请求，中间件在编辑响应结果之前对它的 <tt class="docutils literal"><span class="pre">Content-Type</span></tt> 头标进行检查。 只有标记为 <tt class="docutils literal"><span class="pre">text/html</span></tt> 或 <tt class="docutils literal"><span class="pre">application/xml+xhtml</span></tt> 的页面才会被修改。</p></div><div class="section" id="id25"><span id="cn206"></span><h4 class="cn" id="cn206">CSRF中间件的局限性</h4><p class="cn" id="cn207"><tt class="docutils literal"><span class="pre">CsrfMiddleware</span></tt> 的运行需要 Django 的会话框架。 （参阅第 14 章了解更多关于会话的内容。）如果你使用了自定义会话或者身份验证框架手动管理会话 cookies，该中间件将帮不上你的忙。</p><p class="cn" id="cn208">如果你的应用程序以某种非常规的方法创建 HTML 页面（例如：在 Javascript 的<tt class="docutils literal"><span class="pre">document.write</span></tt>语句中发送 HTML 片段），你可能会绕开了向表单添加隐藏字段的过滤器。 在此情况下，表单提交永远无法成功。（这是因为在页面发送到客户端之前，<tt class="docutils literal"><span class="pre">CsrfMiddleware</span></tt>使用正则表达式来添加<tt class="docutils literal"><span class="pre">csrfmiddlewaretoken</span></tt>字段到你的HTML中，而正则表达式不能处理不规范的HTML。）如果你怀疑出现了这样的问题。使用你浏览器的查看源代码功能以确定<tt class="docutils literal"><span class="pre">csrfmiddlewaretoken</span></tt>是否插入到了表单中。</p><p class="cn" id="cn209">想了解更多关于 CSRF 的信息和例子的话，可以访问 <a class="reference external" href="http://en.wikipedia.org/wiki/CSRF">http://en.wikipedia.org/wiki/CSRF</a> 。</p></div></div></div><div class="section" id="id26"><span id="cn210"></span><h2 class="cn" id="cn210">人性化数据</h2><p class="cn" id="cn211">包<tt class="docutils literal"><span class="pre">django.contrib.humanize</span></tt>包含了一些是数据更人性化的模板过滤器。 要激活这些过滤器，请把<tt class="docutils literal"><span class="pre">'django.contrib.humanize'</span></tt>加入到你的<tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt>中。完成之后，向模版了加入<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">humanize</span> <span class="pre">%}</span></tt>就可以使用下面的过滤器了。</p><div class="section" id="apnumber"><span id="cn212"></span><h3 class="cn" id="cn212">apnumber</h3><p class="cn" id="cn213">对于 1 到 9 的数字，该过滤器返回了数字的拼写形式。 否则，它将返回数字。 这遵循的是美联社风格。</p><p class="cn" id="cn214">举例：</p><ul class="simple"><li class="cn" id="cn215"><p class="first cn" id="cn215">1 变成 one 。</p></li></ul><ul class="simple"><li class="cn" id="cn216"><p class="first cn" id="cn216">2 变成 two 。</p></li></ul><ul class="simple"><li class="cn" id="cn217"><p class="first cn" id="cn217">10 变成 10 。</p></li></ul><p class="cn" id="cn218">你可以传入一个整数或者表示整数的字符串。</p></div><div class="section" id="intcomma"><span id="cn219"></span><h3 class="cn" id="cn219">intcomma</h3><p class="cn" id="cn220">该过滤器将整数转换为每三个数字用一个逗号分隔的字符串。</p><p class="cn" id="cn221">例子：</p><ul class="simple"><li class="cn" id="cn222"><p class="first cn" id="cn222">4500 变成 4,500 。</p></li></ul><ul class="simple"><li class="cn" id="cn223"><p class="first cn" id="cn223">45000 变成 45,000 。</p></li></ul><ul class="simple"><li class="cn" id="cn224"><p class="first cn" id="cn224">450000 变成 450,000 。</p></li></ul><ul class="simple"><li class="cn" id="cn225"><p class="first cn" id="cn225">4500000 变成 4,500,000 。</p></li></ul><p class="cn" id="cn226">可以传入整数或者表示整数的字符串。</p></div><div class="section" id="intword"><span id="cn227"></span><h3 class="cn" id="cn227">intword</h3><p class="cn" id="cn228">该过滤器将一个很大的整数转换成友好的文本表示方式。 它对于超过一百万的数字最好用。</p><p class="cn" id="cn229">例子：</p><ul class="simple"><li class="cn" id="cn230"><p class="first cn" id="cn230">1000000 变成 1.0 million 。</p></li></ul><ul class="simple"><li class="cn" id="cn231"><p class="first cn" id="cn231">1200000 变成 1.2 million 。</p></li></ul><ul class="simple"><li class="cn" id="cn232"><p class="first cn" id="cn232">1200000000 变成 1.2 billion 。</p></li></ul><p class="cn" id="cn233">最大支持不超过一千的五次方（1,000,000,000,000,000）。</p><p class="cn" id="cn234">可以传入整数或者表示整数的字符串。</p></div><div class="section" id="ordinal"><span id="cn235"></span><h3 class="cn" id="cn235">ordinal</h3><p class="cn" id="cn236">该过滤器将整数转换为序数词的字符串形式。</p><p class="cn" id="cn237">例子：</p><ul class="simple"><li class="cn" id="cn238"><p class="first cn" id="cn238">1 变成 1st 。</p></li></ul><ul class="simple"><li class="cn" id="cn239"><p class="first cn" id="cn239">2 变成 2nd 。</p></li></ul><ul class="simple"><li class="cn" id="cn240"><p class="first cn" id="cn240">3 变成 3rd 。</p></li></ul><ul class="simple"><li class="cn" id="cn241"><p class="first cn" id="cn241">254变成254th。</p></li></ul><p class="cn" id="cn242">可以传入整数或者表示整数的字符串。</p></div></div><div class="section" id="id27"><span id="cn243"></span><h2 class="cn" id="cn243">标记过滤器</h2><p class="cn" id="cn244">包<tt class="docutils literal"><span class="pre">django.contrib.markup</span></tt>包含了一些列Django模板过滤器，每一个都实现了一中通用的标记语言。</p><ul class="simple"><li class="cn" id="cn245"><p class="first cn" id="cn245"><tt class="docutils literal"><span class="pre">textile</span></tt> : 实现了 Textile (<a class="reference external" href="http://en.wikipedia.org/wiki/Textile_%28markup_language%29">http://en.wikipedia.org/wiki/Textile_%28markup_language%29</a>)</p></li></ul><ul class="simple"><li class="cn" id="cn246"><p class="first cn" id="cn246"><tt class="docutils literal"><span class="pre">markdown</span></tt> : 实现了 Markdown (<a class="reference external" href="http://en.wikipedia.org/wiki/Markdown">http://en.wikipedia.org/wiki/Markdown</a>)</p></li></ul><ul class="simple"><li class="cn" id="cn247"><p class="first cn" id="cn247"><tt class="docutils literal"><span class="pre">restructuredtext</span></tt> : 实现了 ReStructured Text (<a class="reference external" href="http://en.wikipedia.org/wiki/ReStructuredText">http://en.wikipedia.org/wiki/ReStructuredText</a>)</p></li></ul><p class="cn" id="cn248">每种情形下，过滤器都期望字符串形式的格式化标记，并返回表示标记文本的字符串。 例如：<tt class="docutils literal"><span class="pre">textile</span></tt>过滤器吧Textile格式的文本转换为HTML。</p><pre class="cn literal-block" id="cn250">{% load markup %}{{ object.content|textile }}</pre><p class="cn" id="cn251">要激活这些过滤器，仅需将 <tt class="docutils literal"><span class="pre">'django.contrib.markup'</span></tt> 添加到 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置中。一旦完成了该项工作，在模板中通过 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">markup</span> <span class="pre">%}</span></tt> 就能使用这些过滤器。 要想掌握更多信息的话，可阅读 <tt class="docutils literal"><span class="pre">django/contrib/markup/templatetags/markup.py.</span></tt> 内的源代码。</p></div><div class="section" id="id28"><span id="cn252"></span><h2 class="cn" id="cn252">下一章</h2><p class="cn" id="cn253">这些继承框架（CSRF、身份验证系统等等）通过提供 <em>中间件</em> 来实现其奇妙的功能。中间件是在请求之前/后执行的可以修改请求和响应的代码，它扩展了框架。 在下一章，我们将介绍Django的中间件并解释怎样写出自己的中间件。</p><p class="cn" id="cn254">受<a class="reference external" href="/license/">GNU Free Document License</a>约束。 谨奉</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter15.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter17.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>