<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第九章：模版高级进阶</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter08.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter10.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第九章 模板高级进阶</h1><p class="cn" id="cn1">虽然大多数和Django模板语言的交互都是模板作者的工作，但你可能想定制和扩展模板引擎，让它做一些它不能做的事情，或者是以其他方式让你的工作更轻松。</p><p class="cn" id="cn2">本章深入探讨Django的模板系统。 如果你想扩展模板系统或者只是对它的工作原理感觉到好奇，本章涉及了你需要了解的东西。 它也包含一个自动转意特征，如果你继续使用django，随着时间的推移你一定会注意这个安全考虑。</p><p class="cn" id="cn3">如果你想把Django的模版系统作为另外一个应用程序的一部分（就是说，仅使用Django的模板系统而不使用Django框架的其他部分），那你一定要读一下“配置独立模式下的模版系统”这一节。</p><div class="section" id="id2"><span id="cn4"></span><h2 class="cn" id="cn4">模板语言回顾</h2><p class="cn" id="cn5">首先，让我们快速回顾一下第四章介绍的若干专业术语：</p><blockquote><p class="cn" id="cn6"><em>模板</em> 是一个纯文本文件，或是一个用Django模板语言标记过的普通的Python字符串。 模板可以包含模板标签和变量。</p><p class="cn" id="cn7"><em>模板标签</em> 是在一个模板里面起作用的的标记。 这个定义故意搞得模糊不清。 例如，一个模版标签能够产生作为控制结构的内容（一个 <tt class="docutils literal"><span class="pre">if</span></tt>语句或<tt class="docutils literal"><span class="pre">for</span></tt> 循环), 可以获取数据库内容，或者访问其他的模板标签。</p><p class="cn" id="cn8">区块标签被 <tt class="docutils literal"><span class="pre">{%</span></tt> 和 <tt class="docutils literal"><span class="pre">%}</span></tt> 包围：</p></blockquote><pre class="cn literal-block" id="cn10">{% if is_logged_in %}Thanks for logging in!{% else %}Please log in.{% endif %}</pre><blockquote><p class="cn" id="cn11"><em>变量</em> 是一个在模板里用来输出值的标记。</p><p class="cn" id="cn12">变量标签被 <tt class="docutils literal"><span class="pre">{{</span></tt> 和 <tt class="docutils literal"><span class="pre">}}</span></tt> 包围：</p></blockquote><pre class="cn literal-block" id="cn14">My first name is {{ first_name }}. My last name is {{ last_name }}.</pre><blockquote><p class="cn" id="cn15"><em>context</em> 是一个传递给模板的名称到值的映射（类似Python字典）。</p><p class="cn" id="cn16">模板 <em>渲染</em> 就是是通过从context获取值来替换模板中变量并执行所有的模板标签。</p></blockquote><p class="cn" id="cn17">关于这些基本概念更详细的内容，请参考第四章。</p><p class="cn" id="cn18">本章的其余部分讨论了扩展模板引擎的方法。首先，我们快速的看一下第四章遗留的内容。</p></div><div class="section" id="requestcontext-context"><span id="cn19"></span><h2 class="cn" id="cn19">RequestContext和Context处理器</h2><p class="cn" id="cn20">你需要一段context来解析模板。 一般情况下，这是一个 <tt class="docutils literal"><span class="pre">django.template.Context</span></tt> 的实例，不过在Django中还可以用一个特殊的子类， <tt class="docutils literal"><span class="pre">django.template.RequestContext</span></tt> ，这个用起来稍微有些不同。<tt class="docutils literal"><span class="pre">RequestContext</span></tt> 默认地在模板context中加入了一些变量，如 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 对象或当前登录用户的相关信息。</p><p class="cn" id="cn21">当你不想在一系例模板中都明确指定一些相同的变量时，你应该使用 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 。 例如，考虑这两个视图：</p><pre class="cn literal-block" id="cn23">from django.template import loader, Contextdef view_1(request):# ...t = loader.get_template('template1.html')c = Context({'app': 'My app','user': request.user,'ip_address': request.META['REMOTE_ADDR'],'message': 'I am view 1.'})return t.render(c)def view_2(request):# ...t = loader.get_template('template2.html')c = Context({'app': 'My app','user': request.user,'ip_address': request.META['REMOTE_ADDR'],'message': 'I am the second view.'})return t.render(c)</pre><p class="cn" id="cn24">（注意，在这些例子中，我们故意 <em>不</em> 使用 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 这个快捷方法，而选择手动载入模板，手动构造context对象然后渲染模板。 是为了能够清晰的说明所有步骤。）</p><p class="cn" id="cn25">每个视图都给模板传入了三个相同的变量：<tt class="docutils literal"><span class="pre">app</span></tt>、<tt class="docutils literal"><span class="pre">user</span></tt>和<tt class="docutils literal"><span class="pre">ip_address</span></tt>。 如果我们把这些冗余去掉会不会更好？</p><p class="cn" id="cn26">创建 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 和 <strong>context处理器</strong> 就是为了解决这个问题。 Context处理器允许你设置一些变量，它们会在每个context中自动被设置好，而不必每次调用 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 时都指定。 要点就是，当你渲染模板时，你要用 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 而不是 <tt class="docutils literal"><span class="pre">Context</span></tt> 。</p><p class="cn" id="cn27">最直接的做法是用context处理器来创建一些处理器并传递给 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 。上面的例子可以用context processors改写如下：</p><pre class="cn literal-block" id="cn29">from django.template import loader, RequestContextdef custom_proc(request):&quot;A context processor that provides 'app', 'user' and 'ip_address'.&quot;return {'app': 'My app','user': request.user,'ip_address': request.META['REMOTE_ADDR']}def view_1(request):# ...t = loader.get_template('template1.html')c = RequestContext(request, {'message': 'I am view 1.'},processors=[custom_proc])return t.render(c)def view_2(request):# ...t = loader.get_template('template2.html')c = RequestContext(request, {'message': 'I am the second view.'},processors=[custom_proc])return t.render(c)</pre><p class="cn" id="cn30">我们来通读一下代码：</p><ul class="simple"><li class="cn" id="cn31"><p class="first cn" id="cn31">首先，我们定义一个函数 <tt class="docutils literal"><span class="pre">custom_proc</span></tt> 。这是一个context处理器，它接收一个 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 对象，然后返回一个字典，这个字典中包含了可以在模板context中使用的变量。 它就做了这么多。</p></li></ul><ul class="simple"><li class="cn" id="cn32"><p class="first cn" id="cn32">我们在这两个视图函数中用 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 代替了 <tt class="docutils literal"><span class="pre">Context</span></tt> 。在context对象的构建上有两个不同点。一， <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 的第一个参数需要传递一个 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 对象，就是传递给视图函数的第一个参数（ <tt class="docutils literal"><span class="pre">request</span></tt> ）。二， <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 有一个可选的参数 <tt class="docutils literal"><span class="pre">processors</span></tt> ，这是一个包含context处理器函数的列表或者元组。 在这里，我们传递了我们之前定义的处理器函数 <tt class="docutils literal"><span class="pre">curstom_proc</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn33"><p class="first cn" id="cn33">每个视图的context结构里不再包含 <tt class="docutils literal"><span class="pre">app</span></tt> 、 <tt class="docutils literal"><span class="pre">user</span></tt> 、 <tt class="docutils literal"><span class="pre">ip_address</span></tt> 等变量，因为这些由 <tt class="docutils literal"><span class="pre">custom_proc</span></tt> 函数提供了。</p></li></ul><ul class="simple"><li class="cn" id="cn34"><p class="first cn" id="cn34">每个视图 <em>仍然</em> 具有很大的灵活性，可以引入我们需要的任何模板变量。 在这个例子中， <tt class="docutils literal"><span class="pre">message</span></tt> 模板变量在每个视图中都不一样。</p></li></ul><p class="cn" id="cn35">在第四章，我们介绍了 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 这个快捷方式，它可以简化调用 <tt class="docutils literal"><span class="pre">loader.get_template()</span></tt> ,然后创建一个 <tt class="docutils literal"><span class="pre">Context</span></tt> 对象，最后再调用模板对象的 <tt class="docutils literal"><span class="pre">render()</span></tt>过程。 为了讲解context处理器底层是如何工作的，在上面的例子中我们没有使用 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 。但是建议选择 <tt class="docutils literal"><span class="pre">render_to_response()</span></tt> 作为context的处理器。这就需要用到<tt class="docutils literal"><span class="pre">context_instance</span></tt>参数：</p><pre class="cn literal-block" id="cn37">from django.shortcuts import render_to_responsefrom django.template import RequestContextdef custom_proc(request):&quot;A context processor that provides 'app', 'user' and 'ip_address'.&quot;return {'app': 'My app','user': request.user,'ip_address': request.META['REMOTE_ADDR']}def view_1(request):# ...return render_to_response('template1.html',{'message': 'I am view 1.'},context_instance=RequestContext(request, processors=[custom_proc]))def view_2(request):# ...return render_to_response('template2.html',{'message': 'I am the second view.'},context_instance=RequestContext(request, processors=[custom_proc]))</pre><p class="cn" id="cn38">在这，我们将每个视图的模板渲染代码写成了一个单行。</p><p class="cn" id="cn39">虽然这是一种改进，但是，请考虑一下这段代码的简洁性，我们现在不得不承认的是在 <em>另外</em> 一方面有些过分了。 我们以代码冗余（在 <tt class="docutils literal"><span class="pre">processors</span></tt> 调用中）的代价消除了数据上的冗余（我们的模板变量）。 由于你不得不一直键入 <tt class="docutils literal"><span class="pre">processors</span></tt> ，所以使用context处理器并没有减少太多的输入量。</p><p class="cn" id="cn40">Django因此提供对 <em>全局</em> context处理器的支持。 <tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt> 指定了哪些<tt class="docutils literal"><span class="pre">context</span> <span class="pre">processors</span></tt><em>总是</em>默认被使用。这样就省去了每次使用 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 都指定 <tt class="docutils literal"><span class="pre">processors</span></tt> 的麻烦。</p><p class="cn" id="cn41">默认情况下， <tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt> 设置如下：</p><pre class="cn literal-block" id="cn43">TEMPLATE_CONTEXT_PROCESSORS = ('django.core.context_processors.auth','django.core.context_processors.debug','django.core.context_processors.i18n','django.core.context_processors.media',)</pre><p class="cn" id="cn44">这个设置项是一个可调用函数的元组，其中的每个函数使用了和上文中我们的 <tt class="docutils literal"><span class="pre">custom_proc</span></tt> 相同的接口，它们以request对象作为参数，返回一个会被合并传给context的字典： 接收一个request对象作为参数，返回一个包含了将被合并到context中的项的字典。</p><p class="cn" id="cn45">每个处理器将会按照顺序应用。 也就是说如果你在第一个处理器里面向context添加了一个变量，而第二个处理器添加了同样名字的变量，那么第二个将会覆盖第一个。</p><p class="cn" id="cn46">Django提供了几个简单的context处理器，有些在默认情况下被启用的。</p><div class="section" id="django-core-context-processors-auth"><span id="cn47"></span><h3 class="cn" id="cn47">django.core.context_processors.auth</h3><p class="cn" id="cn48">如果 <tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt> 包含了这个处理器，那么每个 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 将包含这些变量：</p><ul class="simple"><li class="cn" id="cn49"><p class="first cn" id="cn49"><tt class="docutils literal"><span class="pre">user</span></tt> ：一个 <tt class="docutils literal"><span class="pre">django.contrib.auth.models.User</span></tt> 实例，描述了当前登录用户（或者一个 <tt class="docutils literal"><span class="pre">AnonymousUser</span></tt> 实例，如果客户端没有登录）。</p></li></ul><ul class="simple"><li class="cn" id="cn50"><p class="first cn" id="cn50"><tt class="docutils literal"><span class="pre">messages</span></tt> ：一个当前登录用户的消息列表（字符串）。 在后台，对每一个请求，这个变量都调用 <tt class="docutils literal"><span class="pre">request.user.get_and_delete_messages()</span></tt> 方法。 这个方法收集用户的消息然后把它们从数据库中删除。</p></li></ul><ul class="simple"><li class="cn" id="cn51"><p class="first cn" id="cn51"><tt class="docutils literal"><span class="pre">perms</span></tt> ： <tt class="docutils literal"><span class="pre">django.core.context_processors.PermWrapper</span></tt> 的一个实例，包含了当前登录用户有哪些权限。</p></li></ul><p class="cn" id="cn52">关于users、permissions和messages的更多内容请参考第14章。</p></div><div class="section" id="django-core-context-processors-debug"><span id="cn53"></span><h3 class="cn" id="cn53">django.core.context_processors.debug</h3><p class="cn" id="cn54">这个处理器把调试信息发送到模板层。 如果<tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt>包含这个处理器，每一个<tt class="docutils literal"><span class="pre">RequestContext</span></tt>将包含这些变量：</p><ul class="simple"><li class="cn" id="cn55"><p class="first cn" id="cn55"><tt class="docutils literal"><span class="pre">debug</span></tt> ：你设置的 <tt class="docutils literal"><span class="pre">DEBUG</span></tt> 的值（ <tt class="docutils literal"><span class="pre">True</span></tt> 或 <tt class="docutils literal"><span class="pre">False</span></tt> ）。你可以在模板里面用这个变量测试是否处在debug模式下。</p></li></ul><ul><li class="cn" id="cn56"><p class="first cn" id="cn56"><tt class="docutils literal"><span class="pre">sql_queries</span></tt> ：包含类似于 <a href="#id3"><span class="problematic" id="id4">``</span></a>{&#8216;sql&#8217;: &#8230;, &#8216;time&#8217;: `` 的字典的一个列表， 记录了这个请求期间的每个SQL查询以及查询所耗费的时间。 这个列表是按照请求顺序进行排列的。</p><div class="system-message" id="id3"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 315); <em><a href="#id4">backlink</a></em></p><p class="cn" id="cn56">Inline literal start-string without end-string.</p></div></li></ul><p class="cn" id="cn57">由于调试信息比较敏感，所以这个context处理器只有当同时满足下面两个条件的时候才有效：</p><ul class="simple"><li class="cn" id="cn58"><p class="first cn" id="cn58"><tt class="docutils literal"><span class="pre">DEBUG</span></tt> 参数设置为 <tt class="docutils literal"><span class="pre">True</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn59"><p class="first cn" id="cn59">请求的ip应该包含在 <tt class="docutils literal"><span class="pre">INTERNAL_IPS</span></tt> 的设置里面。</p></li></ul><p class="cn" id="cn60">细心的读者可能会注意到<tt class="docutils literal"><span class="pre">debug</span></tt>模板变量的值永远不可能为<tt class="docutils literal"><span class="pre">False</span></tt>，因为如果<tt class="docutils literal"><span class="pre">DEBUG</span></tt>是<tt class="docutils literal"><span class="pre">False</span></tt>，那么<tt class="docutils literal"><span class="pre">debug</span></tt>模板变量一开始就不会被RequestContext所包含。</p></div><div class="section" id="django-core-context-processors-i18n"><span id="cn61"></span><h3 class="cn" id="cn61">django.core.context_processors.i18n</h3><p class="cn" id="cn62">如果这个处理器启用，每个 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 将包含下面的变量：</p><ul class="simple"><li class="cn" id="cn63"><p class="first cn" id="cn63"><tt class="docutils literal"><span class="pre">LANGUAGES</span></tt> ： <tt class="docutils literal"><span class="pre">LANGUAGES</span></tt> 选项的值。</p></li></ul><ul class="simple"><li class="cn" id="cn64"><p class="first cn" id="cn64"><tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt> ：如果 <tt class="docutils literal"><span class="pre">request.LANGUAGE_CODE</span></tt> 存在，就等于它；否则，等同于 <tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt> 设置。</p></li></ul><p class="cn" id="cn65">附录E提供了有关这两个设置的更多的信息。</p></div><div class="section" id="django-core-context-processors-request"><span id="cn66"></span><h3 class="cn" id="cn66">django.core.context_processors.request</h3><p class="cn" id="cn67">如果启用这个处理器，每个 <tt class="docutils literal"><span class="pre">RequestContext</span></tt> 将包含变量 <tt class="docutils literal"><span class="pre">request</span></tt> ， 也就是当前的 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 对象。 注意这个处理器默认是不启用的，你需要激活它。</p><p class="cn" id="cn68">如果你发现你的模板需要访问当前的<tt class="docutils literal"><span class="pre">HttpRequest</span></tt>你就需要使用它:</p><pre class="cn literal-block" id="cn70">{{ request.REMOTE_ADDR }}</pre></div><div class="section" id="context"><span id="cn71"></span><h3 class="cn" id="cn71">写Context处理器的一些建议</h3><p class="cn" id="cn72">编写处理器的一些建议：</p><ul class="simple"><li class="cn" id="cn73"><p class="first cn" id="cn73">使每个context处理器完成尽可能小的功能。 使用多个处理器是很容易的，所以你可以根据逻辑块来分解功能以便将来复用。</p></li></ul><ul class="simple"><li class="cn" id="cn74"><p class="first cn" id="cn74">要注意 <tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt> 里的context processor 将会在基于这个settings.py的<em>每个</em> 模板中有效，所以变量的命名不要和模板的变量冲突。 变量名是大小写敏感的，所以processor的变量全用大写是个不错的主意。</p></li></ul><ul class="simple"><li class="cn" id="cn75"><p class="first cn" id="cn75">不论它们存放在哪个物理路径下，只要在你的Python搜索路径中，你就可以在 <tt class="docutils literal"><span class="pre">TEMPLATE_CONTEXT_PROCESSORS</span></tt> 设置里指向它们。 建议你把它们放在应用或者工程目录下名为 <tt class="docutils literal"><span class="pre">context_processors.py</span></tt> 的文件里。</p></li></ul></div></div><div class="section" id="html"><span id="cn76"></span><h2 class="cn" id="cn76">html自动转意</h2><p class="cn" id="cn77">从模板生成html的时候，总是有一个风险——变量包了含会影响结果html的字符。 例如，考虑这个模板片段：</p><pre class="cn literal-block" id="cn79">Hello, {{ name }}.</pre><p class="cn" id="cn80">一开始，这看起来是显示用户名的一个无害的途径，但是考虑如果用户输入如下的名字将会发生什么：</p><pre class="cn literal-block" id="cn82">&lt;script&gt;alert('hello')&lt;/script&gt;</pre><p class="cn" id="cn83">用这个用户名，模板将被渲染成：</p><pre class="cn literal-block" id="cn85">Hello, &lt;script&gt;alert('hello')&lt;/script&gt;</pre><p class="cn" id="cn86">这意味着浏览器将弹出JavaScript警告框！</p><p class="cn" id="cn87">类似的，如果用户名包含<tt class="docutils literal"><span class="pre">小于</span></tt>符号，就像这样：</p><p class="cn" id="cn88">用户名</p><p class="cn" id="cn89">那样的话模板结果被翻译成这样：</p><pre class="cn literal-block" id="cn91">Hello, &lt;b&gt;username</pre><p class="cn" id="cn92">页面的剩余部分变成了粗体！</p><p class="cn" id="cn93">显然，用户提交的数据不应该被盲目信任，直接插入到你的页面中。因为一个潜在的恶意的用户能够利用这类漏洞做坏事。 这类漏洞称为被跨域脚本 (XSS) 攻击。 关于安全的更多内容，请看20章</p><p class="cn" id="cn94">为了避免这个问题，你有两个选择：</p><ul class="simple"><li class="cn" id="cn95"><p class="first cn" id="cn95">一是你可以确保每一个不被信任的变量都被<tt class="docutils literal"><span class="pre">escape</span></tt>过滤器处理一遍，把潜在有害的html字符转换为无害的。 这是最初几年Django的默认方案，但是这样做的问题是它把责任推给<em>你</em>（开发者、模版作者）自己，来确保把所有东西转意。 很容易就忘记转意数据。</p></li></ul><ul class="simple"><li class="cn" id="cn96"><p class="first cn" id="cn96">二是，你可以利用Django的自动html转意。 这一章的剩余部分描述自动转意是如何工作的。</p></li></ul><p class="cn" id="cn97">在django里默认情况下，每一个模板自动转意每一个变量标签的输出。 尤其是这五个字符。</p><ul><li class="cn" id="cn98"><p class="first cn" id="cn98"><a href="#id5"><span class="problematic" id="id6">``</span></a><tt class="docutils literal"><span class="pre">\</span> <span class="pre">``</span></tt></p><div class="system-message" id="id5"><p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 491); <em><a href="#id6">backlink</a></em></p><p class="cn" id="cn98">Inline literal start-string without end-string.</p></div></li></ul><ul class="simple"><li class="cn" id="cn99"><p class="first cn" id="cn99">&gt; 被转换为&gt;</p></li></ul><ul class="simple"><li class="cn" id="cn100"><p class="first cn" id="cn100"><tt class="docutils literal"><span class="pre">'</span></tt>（单引号）被转换为<tt class="docutils literal"><span class="pre">'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn101"><p class="first cn" id="cn101"><tt class="docutils literal"><span class="pre">&quot;</span></tt>(双引号)被转换为<tt class="docutils literal"><span class="pre">&quot;</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn102"><p class="first cn" id="cn102"><tt class="docutils literal"><span class="pre">&amp;</span></tt> is converted to <tt class="docutils literal"><span class="pre">&amp;</span></tt></p></li></ul><p class="cn" id="cn103">另外，我强调一下这个行为默认是开启的。 如果你正在使用django的模板系统，那么你是被保护的。</p><div class="section" id="id7"><span id="cn104"></span><h3 class="cn" id="cn104">如何关闭它</h3><p class="cn" id="cn105">如果你不想数据被自动转意，在每一站点级别、每一模板级别或者每一变量级别你都有几种方法来关闭它。</p><p class="cn" id="cn106">为什么要关闭它？ 因为有时候模板变量包含了一些原始html数据，在这种情况下我们不想它们的内容被转意。 例如，你可能在数据库里存储了一段被信任的html代码，并且你想直接把它嵌入到你的模板里。 或者，你可能正在使用Django的模板系统生成非html文本，比如一封e-mail。</p><div class="section" id="id8"><span id="cn107"></span><h4 class="cn" id="cn107">对于单独的变量</h4><p class="cn" id="cn108">用safe过滤器为单独的变量关闭自动转意：</p><pre class="cn literal-block" id="cn110">This will be escaped: {{ data }}This will not be escaped: {{ data|safe }}</pre><p class="cn" id="cn111">你可以把<em>safe</em>当做<em>safe from further escaping</em>的简写，或者<em>当做可以被直接译成HTML的内容</em>。在这个例子里，如果<tt class="docutils literal"><span class="pre">数据</span></tt>包含<tt class="docutils literal"><span class="pre">''</span></tt>，那么输出会变成：</p><pre class="cn literal-block" id="cn113">This will be escaped: &amp;lt;b&amp;gt;This will not be escaped: &lt;b&gt;</pre></div><div class="section" id="id9"><span id="cn114"></span><h4 class="cn" id="cn114">对于模板块</h4><p class="cn" id="cn115">为了控制模板的自动转意,用标签autoescape来包装整个模板(或者模板中常用的部分),就像这样：</p><pre class="cn literal-block" id="cn117">{% autoescape off %}Hello {{ name }}{% endautoescape %}</pre><p class="cn" id="cn118">autoescape 标签有两个参数on和off 有时,你可能想阻止一部分自动转意,对另一部分自动转意。 这是一个模板的例子：</p><pre class="cn literal-block" id="cn120">Auto-escaping is on by default. Hello {{ name }}{% autoescape off %}This will not be auto-escaped: {{ data }}.Nor this: {{ other_data }}{% autoescape on %}Auto-escaping applies again: {{ name }}{% endautoescape %}{% endautoescape %}</pre><p class="cn" id="cn121">auto-escaping 标签的作用域不仅可以影响到当前模板还可以通过include标签作用到其他标签,就像block标签一样。 例如：</p><pre class="cn literal-block" id="cn123"># base.html{% autoescape off %}&lt;h1&gt;{% block title %}{% endblock %}&lt;/h1&gt;{% block content %}{% endblock %}{% endautoescape %}# child.html{% extends &quot;base.html&quot; %}{% block title %}This &amp; that{% endblock %}{% block content %}{{ greeting }}{% endblock %}</pre><p class="cn" id="cn124">由于在base模板中自动转意被关闭,所以在child模板中自动转意也会关闭.因此,在下面一段HTML被提交时,变量greeting的值就为字符串Hello!</p><pre class="cn literal-block" id="cn126">&lt;h1&gt;This &amp; that&lt;/h1&gt;&lt;b&gt;Hello!&lt;/b&gt;</pre></div></div><div class="section" id="id10"><span id="cn127"></span><h3 class="cn" id="cn127">备注</h3><p class="cn" id="cn128">通常,模板作者没必要为自动转意担心.基于Pyhton的开发者(编写VIEWS视图和自定义过滤器)只需要考虑哪些数据不需要被转意,适时的标记数据,就可以让它们在模板中工作。</p><p class="cn" id="cn129">如果你正在编写一个模板而不知道是否要关闭自动转意,那就为所有需要转意的变量添加一个escape过滤器。 当自动转意开启时，使用escape过滤器似乎会两次转意数据，但其实没有任何危险。因为escape过滤器不作用于被转意过的变量。</p></div><div class="section" id="id11"><span id="cn130"></span><h3 class="cn" id="cn130">过滤器参数里的字符串常量的自动转义</h3><p class="cn" id="cn131">就像我们前面提到的,过滤器也可以是字符串.</p><pre class="cn literal-block" id="cn133">{{ data|default:&quot;This is a string literal.&quot; }}</pre><p class="cn" id="cn134">所有字符常量没有经过转义就被插入模板,就如同它们都经过了safe过滤。 这是由于字符常量完全由模板作者决定,因此编写模板的时候他们会确保文本的正确性。</p><p class="cn" id="cn135">这意味着你必须这样写</p><pre class="cn literal-block" id="cn137">{{ data|default:&quot;3 &amp;lt; 2&quot; }}</pre><p class="cn" id="cn138">而不是这样</p><pre class="cn literal-block" id="cn140">{{ data|default:&quot;3 &lt; 2&quot; }}  &lt;-- Bad! Don't do this.</pre><p class="cn" id="cn141">这点对来自变量本身的数据不起作用。 如果必要,变量内容会自动转义,因为它们不在模板作者的控制下。</p></div></div><div class="section" id="id12"><span id="cn142"></span><h2 class="cn" id="cn142">模板加载的内幕</h2><p class="cn" id="cn143">一般说来，你会把模板以文件的方式存储在文件系统中，但是你也可以使用自定义的 <em>template loaders</em> 从其他来源加载模板。</p><p class="cn" id="cn144">Django有两种方法加载模板</p><ul class="simple"><li class="cn" id="cn145"><p class="first cn" id="cn145"><tt class="docutils literal"><span class="pre">django.template.loader.get_template(template_name)</span></tt> ： <tt class="docutils literal"><span class="pre">get_template</span></tt> 根据给定的模板名称返回一个已编译的模板（一个 <tt class="docutils literal"><span class="pre">Template</span></tt> 对象）。 如果模板不存在，就触发 <tt class="docutils literal"><span class="pre">TemplateDoesNotExist</span></tt> 的异常。</p></li></ul><ul class="simple"><li class="cn" id="cn146"><p class="first cn" id="cn146"><tt class="docutils literal"><span class="pre">django.template.loader.select_template(template_name_list)</span></tt> ： <tt class="docutils literal"><span class="pre">select_template</span></tt> 很像 <tt class="docutils literal"><span class="pre">get_template</span></tt> ，不过它是以模板名称的列表作为参数的。 它会返回列表中存在的第一个模板。如果模板都不存在，将会触发<tt class="docutils literal"><span class="pre">TemplateDoesNotExist</span></tt>异常。</p></li></ul><p class="cn" id="cn147">正如在第四章中所提到的，默认情况下这些函数使用 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 的设置来载入模板。 但是，在内部这些函数可以指定一个模板加载器来完成这些繁重的任务。</p><p class="cn" id="cn148">一些加载器默认被禁用，但是你可以通过编辑 <tt class="docutils literal"><span class="pre">TEMPLATE_LOADERS</span></tt> 设置来激活它们。 <tt class="docutils literal"><span class="pre">TEMPLATE_LOADERS</span></tt> 应当是一个字符串的元组，其中每个字符串都表示一个模板加载器。 这些模板加载器随Django一起发布。</p><blockquote><p class="cn" id="cn149"><tt class="docutils literal"><span class="pre">django.template.loaders.filesystem.load_template_source</span></tt> : 这个加载器根据 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 的设置从文件系统加载模板。它默认是可用的。</p><p class="cn" id="cn150"><tt class="docutils literal"><span class="pre">django.template.loaders.app_directories.load_template_source</span></tt> : 这个加 载器从文件系统上的Django应用中加载模板。 对 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中的每个应用，这个加载器会查找<tt class="docutils literal"><span class="pre">templates</span></tt> 子目录。 如果这个目录存在，Django就在那里寻找模板。</p><p class="cn" id="cn151">这意味着你可以把模板和你的应用一起保存，从而使得Django应用更容易和默认模板一起发布。例如，如果 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 包含 <tt class="docutils literal"><span class="pre">('myproject.polls','myproject.music')</span></tt> ，那么 <tt class="docutils literal"><span class="pre">get_template('foo.html')</span></tt> 会按这个顺序查找模板：</p><ul class="simple"><li class="cn" id="cn152"><p class="first cn" id="cn152"><tt class="docutils literal"><span class="pre">/path/to/myproject/polls/templates/foo.html</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn153"><p class="first cn" id="cn153"><tt class="docutils literal"><span class="pre">/path/to/myproject/music/templates/foo.html</span></tt></p></li></ul><p class="cn" id="cn154">请注意加载器在首次被导入的时候会执行一个优化： 它会缓存一个列表，这个列表包含了 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中带有 <tt class="docutils literal"><span class="pre">templates</span></tt> 子目录的包。</p><p class="cn" id="cn155">这个加载器默认启用。</p><p class="cn" id="cn156"><tt class="docutils literal"><span class="pre">django.template.loaders.eggs.load_template_source</span></tt> : 这个加载器类似 <tt class="docutils literal"><span class="pre">app_directories</span></tt> ，只不过它从Python eggs而不是文件系统中加载模板。 这个加载器默认被禁用；如果你使用eggs来发布你的应用，那么你就需要启用它。Python eggs可以将Python代码压缩到一个文件中。</p></blockquote><p class="cn" id="cn157">Django按照 <tt class="docutils literal"><span class="pre">TEMPLATE_LOADERS</span></tt> 设置中的顺序使用模板加载器。 它逐个使用每个加载器直至找到一个匹配的模板。</p></div><div class="section" id="id13"><span id="cn158"></span><h2 class="cn" id="cn158">扩展模板系统</h2><p class="cn" id="cn159">既然你已经对模板系统的内幕多了一些了解，让我们来看看如何使用自定义的代码来扩展这个系统吧。</p><p class="cn" id="cn160">绝大部分的模板定制是以自定义标签/过滤器的方式来完成的。 尽管Django模板语言自带了许多内建标签和过滤器，但是你可能还是需要组建你自己的标签和过滤器库来满足你的需要。 幸运的是，定义你自己的功能非常容易。</p><div class="section" id="id14"><span id="cn161"></span><h3 class="cn" id="cn161">创建一个模板库</h3><p class="cn" id="cn162">不管是写自定义标签还是过滤器，第一件要做的事是创建<strong>模板库</strong>（Django能够导入的基本结构）。</p><p class="cn" id="cn163">创建一个模板库分两步走：</p><blockquote><p class="cn" id="cn164">第一，决定模板库应该放在哪个Django应用下。如果你通过 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">startapp</span></tt> 创建了一个应用，你可以把它放在那里，或者你可以为模板库单独创建一个应用。 我们更推荐使用后者，因为你的filter可能在后来的工程中有用。</p><p class="cn" id="cn165">无论你采用何种方式，请确保把你的应用添加到 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中。 我们稍后会解释这一点。</p><p class="cn" id="cn166">第二，在适当的Django应用包里创建一个 <tt class="docutils literal"><span class="pre">templatetags</span></tt> 目录。 这个目录应当和 <tt class="docutils literal"><span class="pre">models.py</span></tt> 、 <tt class="docutils literal"><span class="pre">views.py</span></tt> 等处于同一层次。 例如：</p></blockquote><pre class="cn literal-block" id="cn168">books/__init__.pymodels.pytemplatetags/views.py</pre><blockquote><p class="cn" id="cn169">在 <tt class="docutils literal"><span class="pre">templatetags</span></tt> 中创建两个空文件： 一个 <tt class="docutils literal"><span class="pre">__init__.py</span></tt> （告诉Python这是 一个包含了Python代码的包）和一个用来存放你自定义的标签/过滤器定义的文件。 第二个文件的名字稍后将用来加载标签。 例如，如果你的自定义标签/过滤器在一个叫作 <tt class="docutils literal"><span class="pre">poll_extras.py</span></tt> 的文件中，你需要在模板中写入如下内容：</p></blockquote><pre class="cn literal-block" id="cn171">{% load poll_extras %}</pre><blockquote><p class="cn" id="cn172"><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">%}</span></tt> 标签检查 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中的设置，仅允许加载已安装的Django应用程序中的模板库。 这是一个安全特性；它可以让你在一台电脑上部署很多的模板库的代码，而又不用把它们暴露给每一个Django安装。</p></blockquote><p class="cn" id="cn173">如果你写了一个不和任何特定模型/视图关联的模板库，那么得到一个仅包含 <tt class="docutils literal"><span class="pre">templatetags</span></tt> 包的Django应用程序包是完全正常的。 对于在 <tt class="docutils literal"><span class="pre">templatetags</span></tt> 包中放置多少个模块没有做任何的限制。 需要了解的是：<tt class="docutils literal"><span class="pre">{%load%}</span></tt>语句是通过指定的Python模块名而不是应用名来加载标签/过滤器的。</p><p class="cn" id="cn174">一旦创建了Python模块，你只需根据是要编写过滤器还是标签来相应的编写一些Python代码。</p><p class="cn" id="cn175">作为合法的标签库，模块需要包含一个名为<tt class="docutils literal"><span class="pre">register</span></tt>的模块级变量。这个变量是<tt class="docutils literal"><span class="pre">template.Library</span></tt>的实例，是所有注册标签和过滤器的数据结构。 所以，请在你的模块的顶部插入如下语句：</p><pre class="cn literal-block" id="cn177">from django import templateregister = template.Library()</pre><p class="cn" id="cn178">注意</p><p class="cn" id="cn179">请阅读Django默认的过滤器和标签的源码，那里有大量的例子。 他们分别为： <tt class="docutils literal"><span class="pre">django/template/defaultfilters.py</span></tt> 和 django/template/defaulttags.py 。django.contrib中的某些应用程序也包含模板库。</p><p class="cn" id="cn180">创建 <tt class="docutils literal"><span class="pre">register</span></tt> 变量后，你就可以使用它来创建模板的过滤器和标签了。</p></div><div class="section" id="id15"><span id="cn181"></span><h3 class="cn" id="cn181">自定义模板过滤器</h3><p class="cn" id="cn182">自定义过滤器就是有一个或两个参数的Python函数:</p><ul class="simple"><li class="cn" id="cn183"><p class="first cn" id="cn183">(输入)变量的值</p></li></ul><ul class="simple"><li class="cn" id="cn184"><p class="first cn" id="cn184">参数的值， 可以是默认值或者完全留空</p></li></ul><p class="cn" id="cn185">例如，在过滤器 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">var|foo:&quot;bar&quot;</span> <span class="pre">}}</span></tt> 中 ，过滤器 <tt class="docutils literal"><span class="pre">foo</span></tt> 会被传入变量 <tt class="docutils literal"><span class="pre">var</span></tt> 和默认参数 <tt class="docutils literal"><span class="pre">bar</span></tt>。</p><p class="cn" id="cn186">过滤器函数应该总有返回值。 而且不能触发异常，它们都应该静静地失败。 如果出现错误，应该返回一个原始输入或者空字符串，这会更有意义。</p><p class="cn" id="cn187">这里是一些定义过滤器的例子：</p><pre class="cn literal-block" id="cn189">def cut(value, arg):&quot;Removes all values of arg from the given string&quot;return value.replace(arg, '')</pre><p class="cn" id="cn190">下面是一个可以用来去掉变量值空格的过滤器例子：</p><pre class="cn literal-block" id="cn192">{{ somevariable|cut:&quot; &quot; }}</pre><p class="cn" id="cn193">大多数过滤器并不需要参数。 下面的例子把参数从你的函数中拿掉了：</p><pre class="cn literal-block" id="cn195">def lower(value): # Only one argument.&quot;Converts a string into all lowercase&quot;return value.lower()</pre><p class="cn" id="cn196">当你定义完过滤器后，你需要用 <tt class="docutils literal"><span class="pre">Library</span></tt> 实例来注册它，这样就能通过Django的模板语言来使用了：</p><pre class="cn literal-block" id="cn198">register.filter('cut', cut)register.filter('lower', lower)</pre><p class="cn" id="cn199"><tt class="docutils literal"><span class="pre">Library.filter()</span></tt> 方法需要两个参数：</p><ul class="simple"><li class="cn" id="cn200"><p class="first cn" id="cn200">过滤器的名称（一个字串）</p></li></ul><ul class="simple"><li class="cn" id="cn201"><p class="first cn" id="cn201">过滤器函数本身</p></li></ul><p class="cn" id="cn202">如果你使用的是Python 2.4或者更新的版本，你可以使用装饰器<tt class="docutils literal"><span class="pre">register.filter()</span></tt>：</p><pre class="cn literal-block" id="cn204">&#64;register.filter(name='cut')def cut(value, arg):return value.replace(arg, '')&#64;register.filterdef lower(value):return value.lower()</pre><p class="cn" id="cn205">如果你想第二个例子那样不使用 <tt class="docutils literal"><span class="pre">name</span></tt> 参数，那么Django会把函数名当作过滤器的名字。</p><p class="cn" id="cn206">下面是一个完整的模板库的例子，它包含一个 <tt class="docutils literal"><span class="pre">cut</span></tt> 过滤器：</p><pre class="cn literal-block" id="cn208">from django import templateregister = template.Library()&#64;register.filter(name='cut')def cut(value, arg):return value.replace(arg, '')</pre></div><div class="section" id="id16"><span id="cn209"></span><h3 class="cn" id="cn209">自定义模板标签</h3><p class="cn" id="cn210">标签要比过滤器复杂些，因为标签几乎能做任何事情。</p><p class="cn" id="cn211">第四章描述了模板系统的两步处理过程：编译和呈现。 为了自定义一个模板标签，你需要告诉Django当遇到你的标签时怎样进行这个过程。</p><p class="cn" id="cn212">当Django编译一个模板时，它将原始模板分成一个个 <em>节点</em> 。每个节点都是 <tt class="docutils literal"><span class="pre">django.template.Node</span></tt> 的一个实例，并且具备 <tt class="docutils literal"><span class="pre">render()</span></tt> 方法。 于是，一个已编译的模板就是 <tt class="docutils literal"><span class="pre">节点</span></tt> 对象的一个列表。 例如，看看这个模板：</p><pre class="cn literal-block" id="cn214">Hello, {{ person.name }}.{% ifequal name.birthday today %}Happy birthday!{% else %}Be sure to come back on your birthdayfor a splendid surprise message.{% endifequal %}</pre><p class="cn" id="cn215">被编译的模板表现为节点列表的形式：</p><ul class="simple"><li class="cn" id="cn216"><p class="first cn" id="cn216">文本节点： <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">&quot;</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn217"><p class="first cn" id="cn217">变量节点： <tt class="docutils literal"><span class="pre">person.name</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn218"><p class="first cn" id="cn218">文本节点: <tt class="docutils literal"><span class="pre">&quot;.\n\n&quot;</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn219"><p class="first cn" id="cn219">IfEqual节点: <tt class="docutils literal"><span class="pre">name.birthday</span></tt>和<tt class="docutils literal"><span class="pre">today</span></tt></p></li></ul><p class="cn" id="cn220">当你调用一个已编译模板的 <tt class="docutils literal"><span class="pre">render()</span></tt> 方法时，模板就会用给定的context来调用每个在它的节点列表上的所有节点的 <tt class="docutils literal"><span class="pre">render()</span></tt> 方法。 这些渲染的结果合并起来，形成了模板的输出。 因此，要自定义模板标签，你需要指明原始模板标签如何转换成<tt class="docutils literal"><span class="pre">节点</span></tt>（编译函数）和节点的<tt class="docutils literal"><span class="pre">render()</span></tt>方法完成的功能 。</p><p class="cn" id="cn221">在下面的章节中，我们将详细解说写一个自定义标签时的所有步骤。</p></div><div class="section" id="id17"><span id="cn222"></span><h3 class="cn" id="cn222">编写编译函数</h3><p class="cn" id="cn223">当遇到一个模板标签（template tag）时，模板解析器就会把标签包含的内容，以及模板解析器自己作为参数调用一个python函数。 这个函数负责返回一个和当前模板标签内容相对应的节点（Node）的实例。</p><p class="cn" id="cn224">例如，写一个显示当前日期的模板标签：{% current_time %}。该标签会根据参数指定的 strftime 格式（参见：<tt class="docutils literal"><span class="pre">http://www.djangoproject.com/r/python/strftime/</span></tt>）显示当前时间。首先确定标签的语法是个好主意。 在这个例子里，标签应该这样使用：</p><pre class="cn literal-block" id="cn226">&lt;p&gt;The time is {% current_time &quot;%Y-%m-%d %I:%M %p&quot; %}.&lt;/p&gt;</pre><p class="cn" id="cn227">注意</p><p class="cn" id="cn228">没错, 这个模板标签是多余的，Django默认的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">now</span> <span class="pre">%}</span></tt> 用更简单的语法完成了同样的工作。 这个模板标签在这里只是作为一个例子。</p><p class="cn" id="cn229">这个函数的分析器会获取参数并创建一个 <tt class="docutils literal"><span class="pre">Node</span></tt> 对象:</p><pre class="cn literal-block" id="cn231">from django import templateregister = template.Library()def do_current_time(parser, token):try:# split_contents() knows not to split quoted strings.tag_name, format_string = token.split_contents()except ValueError:msg = '%r tag requires a single argument' % token.split_contents()[0]raise template.TemplateSyntaxError(msg)return CurrentTimeNode(format_string[1:-1])</pre><p class="cn" id="cn232">这里需要说明的地方很多：</p><ul class="simple"><li class="cn" id="cn233"><p class="first cn" id="cn233">每个标签编译函数有两个参数，<tt class="docutils literal"><span class="pre">parser</span></tt>和<tt class="docutils literal"><span class="pre">token</span></tt>。<tt class="docutils literal"><span class="pre">parser</span></tt>是模板解析器对象。 我们在这个例子中并不使用它。 <tt class="docutils literal"><span class="pre">token</span></tt>是正在被解析的语句。</p></li></ul><ul class="simple"><li class="cn" id="cn234"><p class="first cn" id="cn234"><tt class="docutils literal"><span class="pre">token.contents</span></tt> 是包含有标签原始内容的字符串。 在我们的例子中，它是 <tt class="docutils literal"><span class="pre">'current_time</span> <span class="pre">&quot;%Y-%m-%d</span> <span class="pre">%I:%M</span> <span class="pre">%p&quot;'</span></tt> 。</p></li></ul><ul class="simple"><li class="cn" id="cn235"><p class="first cn" id="cn235"><tt class="docutils literal"><span class="pre">token.split_contents()</span></tt> 方法按空格拆分参数同时保证引号中的字符串不拆分。 应该避免使用 <tt class="docutils literal"><span class="pre">token.contents.split()</span></tt> （仅使用Python的标准字符串拆分）。 它不够健壮，因为它只是简单的按照所有空格进行拆分，包括那些引号引起来的字符串中的空格。</p></li></ul><ul class="simple"><li class="cn" id="cn236"><p class="first cn" id="cn236">这个函数可以抛出 <tt class="docutils literal"><span class="pre">django.template.TemplateSyntaxError</span></tt> ，这个异常提供所有语法错误的有用信息。</p></li></ul><ul class="simple"><li class="cn" id="cn237"><p class="first cn" id="cn237">不要把标签名称硬编码在你的错误信息中，因为这样会把标签名称和你的函数耦合在一起。 <tt class="docutils literal"><span class="pre">token.split_contents()[0]</span></tt><em>总是</em>记录标签的名字，就算标签没有任何参数。</p></li></ul><ul class="simple"><li class="cn" id="cn238"><p class="first cn" id="cn238">这个函数返回一个 <tt class="docutils literal"><span class="pre">CurrentTimeNode</span></tt> （稍后我们将创建它），它包含了节点需要知道的关于这个标签的全部信息。 在这个例子中，它只是传递了参数 <tt class="docutils literal"><span class="pre">&quot;%Y-%m-%d</span> <span class="pre">%I:%M</span> <span class="pre">%p&quot;</span></tt> 。模板标签开头和结尾的引号使用 <tt class="docutils literal"><span class="pre">format_string[1:-1]</span></tt> 除去。</p></li></ul><ul class="simple"><li class="cn" id="cn239"><p class="first cn" id="cn239">模板标签编译函数 <em>必须</em> 返回一个 <tt class="docutils literal"><span class="pre">Node</span></tt> 子类，返回其它值都是错的。</p></li></ul></div><div class="section" id="id18"><span id="cn240"></span><h3 class="cn" id="cn240">编写模板节点</h3><p class="cn" id="cn241">编写自定义标签的第二步就是定义一个拥有 <tt class="docutils literal"><span class="pre">render()</span></tt> 方法的 <tt class="docutils literal"><span class="pre">Node</span></tt> 子类。 继续前面的例子，我们需要定义 <tt class="docutils literal"><span class="pre">CurrentTimeNode</span></tt> ：</p><pre class="cn literal-block" id="cn243">import datetimeclass CurrentTimeNode(template.Node):def __init__(self, format_string):self.format_string = str(format_string)def render(self, context):now = datetime.datetime.now()return now.strftime(self.format_string)</pre><p class="cn" id="cn244">这两个函数（ <tt class="docutils literal"><span class="pre">__init__()</span></tt> 和 <tt class="docutils literal"><span class="pre">render()</span></tt> ）与模板处理中的两步（编译与渲染）直接对应。 这样，初始化函数仅仅需要存储后面要用到的格式字符串，而 <tt class="docutils literal"><span class="pre">render()</span></tt> 函数才做真正的工作。</p><p class="cn" id="cn245">与模板过滤器一样，这些渲染函数应该静静地捕获错误，而不是抛出错误。 模板标签只允许在编译的时候抛出错误。</p></div><div class="section" id="id19"><span id="cn246"></span><h3 class="cn" id="cn246">注册标签</h3><p class="cn" id="cn247">最后，你需要用你模块的<tt class="docutils literal"><span class="pre">Library</span></tt> 实例注册这个标签。注册自定义标签与注册自定义过滤器非常类似（如前文所述）。 只需实例化一个 <tt class="docutils literal"><span class="pre">template.Library</span></tt> 实例然后调用它的 <tt class="docutils literal"><span class="pre">tag()</span></tt> 方法。 例如：</p><pre class="cn literal-block" id="cn249">register.tag('current_time', do_current_time)</pre><p class="cn" id="cn250"><tt class="docutils literal"><span class="pre">tag()</span></tt> 方法需要两个参数:</p><ul class="simple"><li class="cn" id="cn251"><p class="first cn" id="cn251">模板标签的名字（字符串）。</p></li></ul><ul class="simple"><li class="cn" id="cn252"><p class="first cn" id="cn252">编译函数。</p></li></ul><p class="cn" id="cn253">和注册过滤器类似，也可以在Python2.4及其以上版本中使用 <tt class="docutils literal"><span class="pre">register.tag</span></tt>装饰器：</p><pre class="cn literal-block" id="cn255">&#64;register.tag(name=&quot;current_time&quot;)def do_current_time(parser, token):# ...&#64;register.tagdef shout(parser, token):# ...</pre><p class="cn" id="cn256">如果你像在第二个例子中那样忽略 <tt class="docutils literal"><span class="pre">name</span></tt> 参数的话，Django会使用函数名称作为标签名称。</p></div><div class="section" id="id20"><span id="cn257"></span><h3 class="cn" id="cn257">在上下文中设置变量</h3><p class="cn" id="cn258">前一节的例子只是简单的返回一个值。 很多时候设置一个模板变量而非返回值也很有用。 那样，模板作者就只能使用你的模板标签所设置的变量。</p><p class="cn" id="cn259">要在上下文中设置变量，在 <tt class="docutils literal"><span class="pre">render()</span></tt> 函数的context对象上使用字典赋值。 这里是一个修改过的 <tt class="docutils literal"><span class="pre">CurrentTimeNode</span></tt> ，其中设定了一个模板变量 <tt class="docutils literal"><span class="pre">current_time</span></tt> ，并没有返回它：</p><pre class="cn literal-block" id="cn261">class CurrentTimeNode2(template.Node):def __init__(self, format_string):self.format_string = str(format_string)def render(self, context):now = datetime.datetime.now()context['current_time'] = now.strftime(self.format_string)return ''</pre><p class="cn" id="cn262">(我们把创建函数<tt class="docutils literal"><span class="pre">do_current_time2</span></tt>和注册给<tt class="docutils literal"><span class="pre">current_time2</span></tt>模板标签的工作留作读者练习。)</p><p class="cn" id="cn263">注意 <tt class="docutils literal"><span class="pre">render()</span></tt> 返回了一个空字符串。 <tt class="docutils literal"><span class="pre">render()</span></tt> 应当总是返回一个字符串，所以如果模板标签只是要设置变量， <tt class="docutils literal"><span class="pre">render()</span></tt> 就应该返回一个空字符串。</p><p class="cn" id="cn264">你应该这样使用这个新版本的标签：</p><pre class="cn literal-block" id="cn266">{% current_time2 &quot;%Y-%M-%d %I:%M %p&quot; %}&lt;p&gt;The time is {{ current_time }}.&lt;/p&gt;</pre><p class="cn" id="cn267">但是 <tt class="docutils literal"><span class="pre">CurrentTimeNode2</span></tt> 有一个问题: 变量名 <tt class="docutils literal"><span class="pre">current_time</span></tt> 是硬编码的。 这意味着你必须确定你的模板在其它任何地方都不使用 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">current_time</span> <span class="pre">}}</span></tt> ，因为 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">current_time2</span> <span class="pre">%}</span></tt> 会盲目的覆盖该变量的值。</p><p class="cn" id="cn268">一种更简洁的方案是由模板标签来指定需要设定的变量的名称，就像这样：</p><pre class="cn literal-block" id="cn270">{% get_current_time &quot;%Y-%M-%d %I:%M %p&quot; as my_current_time %}&lt;p&gt;The current time is {{ my_current_time }}.&lt;/p&gt;</pre><p class="cn" id="cn271">为此，你需要重构编译函数和 <tt class="docutils literal"><span class="pre">Node</span></tt> 类，如下所示：</p><pre class="cn literal-block" id="cn273">import reclass CurrentTimeNode3(template.Node):def __init__(self, format_string, var_name):self.format_string = str(format_string)self.var_name = var_namedef render(self, context):now = datetime.datetime.now()context[self.var_name] = now.strftime(self.format_string)return ''def do_current_time(parser, token):# This version uses a regular expression to parse tag contents.try:# Splitting by None == splitting by spaces.tag_name, arg = token.contents.split(None, 1)except ValueError:msg = '%r tag requires arguments' % token.contents[0]raise template.TemplateSyntaxError(msg)m = re.search(r'(.*?) as (\w+)', arg)if m:fmt, var_name = m.groups()else:msg = '%r tag had invalid arguments' % tag_nameraise template.TemplateSyntaxError(msg)if not (fmt[0] == fmt[-1] and fmt[0] in ('&quot;', &quot;'&quot;)):msg = &quot;%r tag's argument should be in quotes&quot; % tag_nameraise template.TemplateSyntaxError(msg)return CurrentTimeNode3(fmt[1:-1], var_name)</pre><p class="cn" id="cn274">现在 <tt class="docutils literal"><span class="pre">do_current_time()</span></tt> 把格式字符串和变量名传递给 <tt class="docutils literal"><span class="pre">CurrentTimeNode3</span></tt> 。</p></div><div class="section" id="id21"><span id="cn275"></span><h3 class="cn" id="cn275">分析直至另一个模板标签</h3><p class="cn" id="cn276">模板标签可以像包含其它标签的块一样工作（想想 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 、 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">%}</span></tt> 等）。 要创建一个这样的模板标签，在你的编译函数中使用 <tt class="docutils literal"><span class="pre">parser.parse()</span></tt> 。</p><p class="cn" id="cn277">标准的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">comment</span> <span class="pre">%}</span></tt> 标签是这样实现的：</p><pre class="cn literal-block" id="cn279">def do_comment(parser, token):nodelist = parser.parse(('endcomment',))parser.delete_first_token()return CommentNode()class CommentNode(template.Node):def render(self, context):return ''</pre><p class="cn" id="cn280"><tt class="docutils literal"><span class="pre">parser.parse()</span></tt> 接收一个包含了需要分析的模板标签名的元组作为参数。 它返回一个<tt class="docutils literal"><span class="pre">django.template.NodeList</span></tt>实例，它是一个包含了所有<em>Node</em>对象的列表，这些对象是解析器在解析到任一元组中指定的标签之前遇到的内容.</p><p class="cn" id="cn281">因此在前面的例子中， <tt class="docutils literal"><span class="pre">nodelist</span></tt> 是在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">comment</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endcomment</span> <span class="pre">%}</span></tt> 之间所有节点的列表，不包括 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">comment</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endcomment</span> <span class="pre">%}</span></tt> 自身。</p><p class="cn" id="cn282">在 <tt class="docutils literal"><span class="pre">parser.parse()</span></tt> 被调用之后，分析器还没有清除 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endcomment</span> <span class="pre">%}</span></tt> 标签，因此代码需要显式地调用 <tt class="docutils literal"><span class="pre">parser.delete_first_token()</span></tt> 来防止该标签被处理两次。</p><p class="cn" id="cn283">之后 <tt class="docutils literal"><span class="pre">CommentNode.render()</span></tt> 只是简单地返回一个空字符串。 在 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">comment</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endcomment</span> <span class="pre">%}</span></tt> 之间的所有内容都被忽略。</p></div><div class="section" id="id22"><span id="cn284"></span><h3 class="cn" id="cn284">分析直至另外一个模板标签并保存内容</h3><p class="cn" id="cn285">在前一个例子中， <tt class="docutils literal"><span class="pre">do_comment()</span></tt> 抛弃了<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">comment</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endcomment</span> <span class="pre">%}</span></tt> 之间的所有内容。当然也可以修改和利用下标签之间的这些内容。</p><p class="cn" id="cn286">例如，这个自定义模板标签<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">upper</span> <span class="pre">%}</span></tt>，它会把它自己和<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">endupper</span> <span class="pre">%}</span></tt>之间的内容变成大写：</p><pre class="cn literal-block" id="cn288">{% upper %}This will appear in uppercase, {{ user_name }}.{% endupper %}</pre><p class="cn" id="cn289">就像前面的例子一样，我们将使用 <tt class="docutils literal"><span class="pre">parser.parse()</span></tt> 。这次，我们将产生的 <tt class="docutils literal"><span class="pre">nodelist</span></tt> 传递给 <tt class="docutils literal"><span class="pre">Node</span></tt> ：</p><pre class="cn literal-block" id="cn291">def do_upper(parser, token):nodelist = parser.parse(('endupper',))parser.delete_first_token()return UpperNode(nodelist)class UpperNode(template.Node):def __init__(self, nodelist):self.nodelist = nodelistdef render(self, context):output = self.nodelist.render(context)return output.upper()</pre><p class="cn" id="cn292">这里唯一的一个新概念是 <tt class="docutils literal"><span class="pre">UpperNode.render()</span></tt> 中的 <tt class="docutils literal"><span class="pre">self.nodelist.render(context)</span></tt> 。它对节点列表中的每个 <tt class="docutils literal"><span class="pre">Node</span></tt> 简单的调用 <tt class="docutils literal"><span class="pre">render()</span></tt> 。</p><p class="cn" id="cn293">更多的复杂渲染示例请查看 <tt class="docutils literal"><span class="pre">django/template/defaulttags.py</span></tt> 中的 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">if</span> <span class="pre">%}</span></tt> 、 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">for</span> <span class="pre">%}</span></tt> 、 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifequal</span> <span class="pre">%}</span></tt> 和 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">ifchanged</span> <span class="pre">%}</span></tt> 的代码。</p></div><div class="section" id="id23"><span id="cn294"></span><h3 class="cn" id="cn294">简单标签的快捷方式</h3><p class="cn" id="cn295">许多模板标签接收单一的字符串参数或者一个模板变量引用，然后独立地根据输入变量和一些其它外部信息进行处理并返回一个字符串。 例如，我们先前写的<tt class="docutils literal"><span class="pre">current_time</span></tt>标签就是这样一个例子。 我们给定了一个格式化字符串，然后它返回一个字符串形式的时间。</p><p class="cn" id="cn296">为了简化这类标签，Django提供了一个帮助函数<tt class="docutils literal"><span class="pre">simple_tag</span></tt>。这个函数是<tt class="docutils literal"><span class="pre">django.template.Library</span></tt>的一个方法，它接受一个只有一个参数的函数作参数，把它包装在render函数和之前提及过的其他的必要单位中，然后通过模板系统注册标签。</p><p class="cn" id="cn297">我们之前的的 <tt class="docutils literal"><span class="pre">current_time</span></tt> 函数于是可以写成这样：</p><pre class="cn literal-block" id="cn299">def current_time(format_string):try:return datetime.datetime.now().strftime(str(format_string))except UnicodeEncodeError:return ''register.simple_tag(current_time)</pre><p class="cn" id="cn300">在Python 2.4中，也可以使用装饰器语法：</p><pre class="cn literal-block" id="cn302">&#64;register.simple_tagdef current_time(token):# ...</pre><p class="cn" id="cn303">有关 <tt class="docutils literal"><span class="pre">simple_tag</span></tt> 辅助函数，需要注意下面一些事情：</p><ul class="simple"><li class="cn" id="cn304"><p class="first cn" id="cn304">传递给我们的函数的只有（单个）参数。</p></li></ul><ul class="simple"><li class="cn" id="cn305"><p class="first cn" id="cn305">在我们的函数被调用的时候，检查必需参数个数的工作已经完成了，所以我们不需要再做这个工作。</p></li></ul><ul class="simple"><li class="cn" id="cn306"><p class="first cn" id="cn306">参数两边的引号（如果有的话）已经被截掉了，所以我们会接收到一个普通Unicode字符串。</p></li></ul></div><div class="section" id="id24"><span id="cn307"></span><h3 class="cn" id="cn307">包含标签</h3><p class="cn" id="cn308">另外一类常用的模板标签是通过渲染 <em>其他</em> 模板显示数据的。 比如说，Django的后台管理界面，它使用了自定义的模板标签来显示新增/编辑表单页面下部的按钮。那些按钮看起来总是一样的，但是链接却随着所编辑的对象的不同而改变。 这就是一个使用小模板很好的例子，这些小模板就是当前对象的详细信息。</p><p class="cn" id="cn309">这些排序标签被称为 <em>包含标签</em> 。如何写包含标签最好通过举例来说明。 让我们来写一个能够产生指定<tt class="docutils literal"><span class="pre">作者</span></tt>对象的书籍清单的标签。 我们将这样利用标签：</p><pre class="cn literal-block" id="cn311">{% books_for_author author %}</pre><p class="cn" id="cn312">结果将会像下面这样：</p><pre class="cn literal-block" id="cn314">&lt;ul&gt;&lt;li&gt;The Cat In The Hat&lt;/li&gt;&lt;li&gt;Hop On Pop&lt;/li&gt;&lt;li&gt;Green Eggs And Ham&lt;/li&gt;&lt;/ul&gt;</pre><p class="cn" id="cn315">首先，我们定义一个函数，通过给定的参数生成一个字典形式的结果。 需要注意的是，我们只需要返回字典类型的结果就行了，不需要返回更复杂的东西。 这将被用来作为模板片段的内容：</p><pre class="cn literal-block" id="cn317">def books_for_author(author):books = Book.objects.filter(authors__id=author.id)return {'books': books}</pre><p class="cn" id="cn318">接下来，我们创建用于渲染标签输出的模板。 在我们的例子中，模板很简单：</p><pre class="cn literal-block" id="cn320">&lt;ul&gt;{% for book in books %}&lt;li&gt;{{ book.title }}&lt;/li&gt;{% endfor %}&lt;/ul&gt;</pre><p class="cn" id="cn321">最后，我们通过对一个 <tt class="docutils literal"><span class="pre">Library</span></tt> 对象使用 <tt class="docutils literal"><span class="pre">inclusion_tag()</span></tt> 方法来创建并注册这个包含标签。</p><p class="cn" id="cn322">在我们的例子中，如果先前的模板在 <tt class="docutils literal"><span class="pre">polls/result_snippet.html</span></tt> 文件中，那么我们这样注册标签：</p><pre class="cn literal-block" id="cn324">register.inclusion_tag('book_snippet.html')(books_for_author)</pre><p class="cn" id="cn325">Python 2.4装饰器语法也能正常工作，所以我们可以这样写：</p><pre class="cn literal-block" id="cn327">&#64;register.inclusion_tag('book_snippet.html')def books_for_author(author):# ...</pre><p class="cn" id="cn328">有时候，你的包含标签需要访问父模板的context。 为了解决这个问题，Django为包含标签提供了一个 <tt class="docutils literal"><span class="pre">takes_context</span></tt> 选项。 如果你在创建模板标签时，指明了这个选项，这个标签就不需要参数，并且下面的Python函数会带一个参数： 就是当这个标签被调用时的模板context。</p><p class="cn" id="cn329">例如，你正在写一个包含标签，该标签包含有指向主页的 <tt class="docutils literal"><span class="pre">home_link</span></tt> 和 <tt class="docutils literal"><span class="pre">home_title</span></tt> 变量。 Python函数会像这样：</p><pre class="cn literal-block" id="cn331">&#64;register.inclusion_tag('link.html', takes_context=True)def jump_link(context):return {'link': context['home_link'],'title': context['home_title'],}</pre><p class="cn" id="cn332">（注意函数的第一个参数 <em>必须</em> 是 <tt class="docutils literal"><span class="pre">context</span></tt> 。）</p><p class="cn" id="cn333">模板 <tt class="docutils literal"><span class="pre">link.html</span></tt> 可能包含下面的东西：</p><pre class="cn literal-block" id="cn335">Jump directly to &lt;a href=&quot;{{ link }}&quot;&gt;{{ title }}&lt;/a&gt;.</pre><p class="cn" id="cn336">然后您想使用自定义标签时，就可以加载它的库，然后不带参数地调用它，就像这样：</p><pre class="cn literal-block" id="cn338">{% jump_link %}</pre></div></div><div class="section" id="id25"><span id="cn339"></span><h2 class="cn" id="cn339">编写自定义模板加载器</h2><p class="cn" id="cn340">Djangos 内置的模板加载器（在先前的模板加载内幕章节有叙述）通常会满足你的所有的模板加载需求，但是如果你有特殊的加载需求的话，编写自己的模板加载器也会相当简单。 比如：你可以从数据库中，或者利用Python的绑定直接从Subversion库中，更或者从一个ZIP文档中加载模板。</p><p class="cn" id="cn341">模板加载器，也就是 <tt class="docutils literal"><span class="pre">TEMPLATE_LOADERS</span></tt> 中的每一项，都要能被下面这个接口调用：</p><pre class="cn literal-block" id="cn343">load_template_source(template_name, template_dirs=None)</pre><p class="cn" id="cn344">参数 <tt class="docutils literal"><span class="pre">template_name</span></tt> 是所加载模板的名称 (和传递给 <tt class="docutils literal"><span class="pre">loader.get_template()</span></tt> 或者 <tt class="docutils literal"><span class="pre">loader.select_template()</span></tt> 一样), 而 <tt class="docutils literal"><span class="pre">template_dirs</span></tt> 是一个可选的代替<tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt>的搜索目录列表。</p><p class="cn" id="cn345">如果加载器能够成功加载一个模板, 它应当返回一个元组：<tt class="docutils literal"><span class="pre">(template_source,</span> <span class="pre">template_path)</span></tt> 。在这里的 <tt class="docutils literal"><span class="pre">template_source</span></tt> 就是将被模板引擎编译的的模板字符串，而 <tt class="docutils literal"><span class="pre">template_path</span></tt> 是被加载的模板的路径。 由于那个路径可能会出于调试目的显示给用户，因此它应当很快的指明模板从哪里加载。</p><p class="cn" id="cn346">如果加载器加载模板失败，那么就会触发 <tt class="docutils literal"><span class="pre">django.template.TemplateDoesNotExist</span></tt> 异常。</p><p class="cn" id="cn347">每个加载函数都应该有一个名为 <tt class="docutils literal"><span class="pre">is_usable</span></tt> 的函数属性。 这个属性是一个布尔值，用于告知模板引擎这个加载器是否在当前安装的Python中可用。 例如，如果 <tt class="docutils literal"><span class="pre">pkg_resources</span></tt> 模块没有安装的话，eggs加载器（它能够从python eggs中加载模板）就应该把 <tt class="docutils literal"><span class="pre">is_usable</span></tt> 设为 <tt class="docutils literal"><span class="pre">False</span></tt> ，因为必须通过 <tt class="docutils literal"><span class="pre">pkg_resources</span></tt> 才能从eggs中读取数据。</p><p class="cn" id="cn348">一个例子可以清晰地阐明一切。 这儿是一个模板加载函数，它可以从ZIP文件中加载模板。 它使用了自定义的设置 <tt class="docutils literal"><span class="pre">TEMPLATE_ZIP_FILES</span></tt> 来取代了 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> 用作查找路径，并且它假设在此路径上的每一个文件都是包含模板的ZIP文件：</p><pre class="cn literal-block" id="cn350">from django.conf import settingsfrom django.template import TemplateDoesNotExistimport zipfiledef load_template_source(template_name, template_dirs=None):&quot;Template loader that loads templates from a ZIP file.&quot;template_zipfiles = getattr(settings, &quot;TEMPLATE_ZIP_FILES&quot;, [])# Try each ZIP file in TEMPLATE_ZIP_FILES.for fname in template_zipfiles:try:z = zipfile.ZipFile(fname)source = z.read(template_name)except (IOError, KeyError):continuez.close()# We found a template, so return the source.template_path = &quot;%s:%s&quot; % (fname, template_name)return (source, template_path)# If we reach here, the template couldn't be loadedraise TemplateDoesNotExist(template_name)# This loader is always usable (since zipfile is included with Python)load_template_source.is_usable = True</pre><p class="cn" id="cn351">我们要想使用它，还差最后一步，就是把它加入到 <tt class="docutils literal"><span class="pre">TEMPLATE_LOADERS</span></tt> 。 如果我们将这个代码放入一个叫mysite.zip_loader的包中，那么我们要把mysite.zip_loader.load_template_source加到TEMPLATE_LOADERS中。</p></div><div class="section" id="id26"><span id="cn352"></span><h2 class="cn" id="cn352">配置独立模式下的模板系统</h2><p class="cn" id="cn353">注意：</p><p class="cn" id="cn354">这部分只针对于对在其他应用中使用模版系统作为输出组件感兴趣的人。 如果你是在Django应用中使用模版系统，请略过此部分。</p><p class="cn" id="cn355">通常，Django会从它的默认配置文件和由 <tt class="docutils literal"><span class="pre">DJANGO_SETTINGS_MODULE</span></tt> 环境变量所指定的模块中加载它需要的所有配置信息。 （这点在第四章的&#8221;特殊的Python命令提示行&#8221;一节解释过。）但是当你想在非Django应用中使用模版系统的时候，采用环境变量并不方便，因为你可能更想同其余的应用一起配置你的模板系统，而不是处理配置文件并通过环境变量指向他们。</p><p class="cn" id="cn356">为了解决这个问题，你需要使用附录D中所描述的手动配置选项。概括的说，你需要导入正确的模板中的片段，然后在你访问任一个模板函数之前，首先用你想指定的配置访问Django.conf.settings.configure()。</p><p class="cn" id="cn357">你可能会考虑至少要设置 <tt class="docutils literal"><span class="pre">TEMPLATE_DIRS</span></tt> （如果你打算使用模板加载器）， <tt class="docutils literal"><span class="pre">DEFAULT_CHARSET</span></tt> （尽管默认的 <tt class="docutils literal"><span class="pre">utf-8</span></tt> 编码相当好用），以及 <tt class="docutils literal"><span class="pre">TEMPLATE_DEBUG</span></tt> 。所有可用的选项在附录D中都有详细描述，所有以 <tt class="docutils literal"><span class="pre">TEMPLATE_</span></tt> 开头的选项都可能使你感兴趣。</p></div><div class="section" id="id27"><span id="cn358"></span><h2 class="cn" id="cn358">接下来做什么？</h2><p class="cn" id="cn359">延续本章的高级话题，<a class="reference external" href="chapter10.html">下一章</a> 会继续讨论Django模版的高级用法。</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter08.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter10.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>