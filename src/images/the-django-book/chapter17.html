<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十七章： 中间件</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter16.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter18.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="id1"><h1 class="cn title" id="cn0">第十七章： 中间件</h1><p class="cn" id="cn1">在有些场合，需要对Django处理的每个request都执行某段代码。 这类代码可能是在view处理之前修改传入的request，或者记录日志信息以便于调试，等等。</p><p class="cn" id="cn2">这类功能可以用Django的中间件框架来实现，该框架由切入到Django的request/response处理过程中的钩子集合组成。 这个轻量级低层次的plug-in系统，能用于全面的修改Django的输入和输出。</p><p class="cn" id="cn3">每个中间件组件都用于某个特定的功能。 如果你是顺着这本书读下来的话，你应该已经多次见到“中间件”了</p><ul class="simple"><li class="cn" id="cn4"><p class="first cn" id="cn4">第12章中所有的session和user工具都籍由一小簇中间件实现(例如，由中间件设定view中可见的 <tt class="docutils literal"><span class="pre">request.session</span></tt> 和 <tt class="docutils literal"><span class="pre">request.user</span></tt> )。</p></li></ul><ul class="simple"><li class="cn" id="cn5"><p class="first cn" id="cn5">第13章讨论的站点范围cache实际上也是由一个中间件实现，一旦该中间件发现与view相应的response已在缓存中，就不再调用对应的view函数。</p></li></ul><ul class="simple"><li class="cn" id="cn6"><p class="first cn" id="cn6">第14章所介绍的 <tt class="docutils literal"><span class="pre">flatpages</span></tt> , <tt class="docutils literal"><span class="pre">redirects</span></tt> , 和 <tt class="docutils literal"><span class="pre">csrf</span></tt> 等应用也都是通过中间件组件来完成其魔法般的功能。</p></li></ul><p class="cn" id="cn7">这一章将深入到中间件及其工作机制中，并阐述如何自行编写中间件。</p><div class="section" id="id2"><span id="cn8"></span><h2 class="cn" id="cn8">什么是中间件</h2><p class="cn" id="cn9">我们从一个简单的例子开始。</p><p class="cn" id="cn10">高流量的站点通常需要将Django部署在负载平衡proxy(参见第20章)之后。 这种方式将带来一些复杂性，其一就是每个request中的远程IP地址(<tt class="docutils literal"><span class="pre">request.META[&quot;REMOTE_IP&quot;]</span></tt>)将指向该负载平衡proxy，而不是发起这个request的实际IP。 负载平衡proxy处理这个问题的方法在特殊的 <tt class="docutils literal"><span class="pre">X-Forwarded-For</span></tt> 中设置实际发起请求的IP。</p><p class="cn" id="cn11">因此，需要一个小小的中间件来确保运行在proxy之后的站点也能够在 <tt class="docutils literal"><span class="pre">request.META[&quot;REMOTE_ADDR&quot;]</span></tt> 中得到正确的IP地址：</p><pre class="cn literal-block" id="cn13">class SetRemoteAddrFromForwardedFor(object):def process_request(self, request):try:real_ip = request.META['HTTP_X_FORWARDED_FOR']except KeyError:passelse:# HTTP_X_FORWARDED_FOR can be a comma-separated list of IPs.# Take just the first one.real_ip = real_ip.split(&quot;,&quot;)[0]request.META['REMOTE_ADDR'] = real_ip</pre><p class="cn" id="cn14">(Note: Although the HTTP header is called <tt class="docutils literal"><span class="pre">X-Forwarded-For</span></tt> , Django makes itavailable as <tt class="docutils literal"><span class="pre">request.META['HTTP_X_FORWARDED_FOR']</span></tt> . With the exception of<tt class="docutils literal"><span class="pre">content-length</span></tt> and <tt class="docutils literal"><span class="pre">content-type</span></tt> , any HTTP headers in the request areconverted to <tt class="docutils literal"><span class="pre">request.META</span></tt> keys by converting all characters to uppercase,replacing any hyphens with underscores and adding an <tt class="docutils literal"><span class="pre">HTTP_</span></tt> prefix to thename.)</p><p class="cn" id="cn15">一旦安装了该中间件(参见下一节)，每个request中的 <tt class="docutils literal"><span class="pre">X-Forwarded-For</span></tt> 值都会被自动插入到 <tt class="docutils literal"><span class="pre">request.META['REMOTE_ADDR']</span></tt> 中。这样，Django应用就不需要关心自己是否位于负载平衡proxy之后；简单读取 <tt class="docutils literal"><span class="pre">request.META['REMOTE_ADDR']</span></tt> 的方式在是否有proxy的情形下都将正常工作。</p><p class="cn" id="cn16">实际上，为针对这个非常常见的情形，Django已将该中间件内置。 它位于 <tt class="docutils literal"><span class="pre">django.middleware.http</span></tt> 中, 下一节将给出这个中间件相关的更多细节。</p></div><div class="section" id="id3"><span id="cn17"></span><h2 class="cn" id="cn17">安装中间件</h2><p class="cn" id="cn18">如果按顺序阅读本书，应当已经看到涉及到中间件安装的多个示例,因为前面章节的许多例子都需要某些特定的中间件。 出于完整性考虑，下面介绍如何安装中间件。</p><p class="cn" id="cn19">要启用一个中间件，只需将其添加到配置模块的 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 元组中。 在 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 中，中间件组件用字符串表示： 指向中间件类名的完整Python路径。 例如，下面是 <tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">startproject</span></tt> 创建的缺省 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> :</p><pre class="cn literal-block" id="cn21">MIDDLEWARE_CLASSES = ('django.middleware.common.CommonMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.contrib.auth.middleware.AuthenticationMiddleware',)</pre><p class="cn" id="cn22">Django项目的安装并不强制要求任何中间件，如果你愿意， <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 可以为空。</p><p class="cn" id="cn23">这里中间件出现的顺序非常重要。 在request和view的处理阶段，Django按照 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 中出现的顺序来应用中间件，而在response和异常处理阶段，Django则按逆序来调用它们。 也就是说，Django将 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 视为view函数外层的顺序包装子： 在request阶段按顺序从上到下穿过，而在response则反过来。</p></div><div class="section" id="id4"><span id="cn24"></span><h2 class="cn" id="cn24">中间件方法</h2><p class="cn" id="cn25">现在，我们已经知道什么是中间件和怎么安装它，下面将介绍中间件类中可以定义的所有方法。</p><div class="section" id="initializer-init-self-init-self"><span id="cn26"></span><h3 class="cn" id="cn26">Initializer: __init__(self) __init__(self)「初始化］</h3><p class="cn" id="cn27">在中间件类中， <tt class="docutils literal"><span class="pre">__init__()</span></tt> 方法用于执行系统范围的设置。</p><p class="cn" id="cn28">出于性能的考虑，每个已启用的中间件在每个服务器进程中只初始化 <em>一</em> 次。 也就是说  <tt class="docutils literal"><span class="pre">__init__()</span></tt> 仅在服务进程启动的时候调用，而在针对单个request处理时并不执行。</p><p class="cn" id="cn29">对一个middleware而言，定义 <tt class="docutils literal"><span class="pre">__init__()</span></tt> 方法的通常原因是检查自身的必要性。 如果 <tt class="docutils literal"><span class="pre">__init__()</span></tt> 抛出异常 <tt class="docutils literal"><span class="pre">django.core.exceptions.MiddlewareNotUsed</span></tt> ,则Django将从middleware栈中移出该middleware。 可以用这个机制来检查middleware依赖的软件是否存在、服务是否运行于调试模式、以及任何其它环境因素。</p><p class="cn" id="cn30">在中间件中定义 <tt class="docutils literal"><span class="pre">__init__()</span></tt> 方法时，除了标准的 <tt class="docutils literal"><span class="pre">self</span></tt> 参数之外，不应定义任何其它参数。</p></div><div class="section" id="request-process-request-self-request-process-request-self-request"><span id="cn31"></span><h3 class="cn" id="cn31">Request预处理函数: process_request(self, request) process_request(self, request)</h3><p class="cn" id="cn32">这个方法的调用时机在Django接收到request之后，但仍未解析URL以确定应当运行的view之前。 Django向它传入相应的 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 对象，以便在方法中修改。</p><p class="cn" id="cn33"><tt class="docutils literal"><span class="pre">process_request()</span></tt> 应当返回 <tt class="docutils literal"><span class="pre">None</span></tt> 或 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 对象.</p><ul class="simple"><li class="cn" id="cn34"><p class="first cn" id="cn34">如果返回 <tt class="docutils literal"><span class="pre">None</span></tt> , Django将继续处理这个request,执行后续的中间件， 然后调用相应的view.</p></li></ul><ul class="simple"><li class="cn" id="cn35"><p class="first cn" id="cn35">如果返回 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 对象, Django 将不再执行 <em>任何</em> 其它的中间件(而无视其种类)以及相应的view。 Django将立即返回该 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> .</p></li></ul></div><div class="section" id="view-process-view-self-request-view-args-kwargs-process-view-self-request-view-args-kwargs"><span id="cn36"></span><h3 class="cn" id="cn36">View预处理函数: process_view(self, request, view, args, kwargs) process_view(self, request, view, args, kwargs)</h3><p class="cn" id="cn37">这个方法的调用时机在Django执行完request预处理函数并确定待执行的view之后，但在view函数实际执行之前。</p><p class="cn" id="cn38">表15-1列出了传入到这个View预处理函数的参数。</p><table class="cn docutils" id="cn39"><caption>表 15-1.  传入process_view()的参数</caption><colgroup><col width="14%" /><col width="86%" /></colgroup><thead valign="bottom"><tr><th class="head">参数</th><th class="head">说明</th></tr></thead><tbody valign="top"><tr><td><tt class="docutils literal"><span class="pre">request</span></tt></td><td>The <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> object.</td></tr><tr><td><tt class="docutils literal"><span class="pre">view</span></tt></td><td>The Python function that Django will call to handle this request.This is the actual function object itself, not the name of thefunction as a string.</td></tr><tr><td><tt class="docutils literal"><span class="pre">args</span></tt></td><td><dl class="first last docutils"><dt>将传入view的位置参数列表，但不包括</dt><dd><tt class="docutils literal"><span class="pre">request</span></tt> 参数(它通常是传 入view的第一个参数)</dd></dl></td></tr><tr><td><tt class="docutils literal"><span class="pre">kwargs</span></tt></td><td>将传入view的关键字参数字典.</td></tr></tbody></table><p class="cn" id="cn40">Just like <tt class="docutils literal"><span class="pre">process_request()</span></tt> , <tt class="docutils literal"><span class="pre">process_view()</span></tt> should return either<tt class="docutils literal"><span class="pre">None</span></tt> or an <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> object.</p><ul class="simple"><li class="cn" id="cn41"><p class="first cn" id="cn41">If it returns <tt class="docutils literal"><span class="pre">None</span></tt> , Django will continue processing this request,executing any other middleware and then the appropriate view.</p></li></ul><ul class="simple"><li class="cn" id="cn42"><p class="first cn" id="cn42">If it returns an <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> object, Django won&#8217;t bother calling <em>any</em>other middleware (of any type) or the appropriate view. Django willimmediately return that <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> .</p></li></ul></div><div class="section" id="response-process-response-self-request-response-process-response-self-request-response"><span id="cn43"></span><h3 class="cn" id="cn43">Response后处理函数: process_response(self, request, response) process_response(self, request, response)</h3><p class="cn" id="cn44">这个方法的调用时机在Django执行view函数并生成response之后。 Here, the processor can modify the content of a response. Oneobvious use case is content compression, such as gzipping of the request&#8217;sHTML.</p><p class="cn" id="cn45">这个方法的参数相当直观: <tt class="docutils literal"><span class="pre">request</span></tt> 是request对象，而 <tt class="docutils literal"><span class="pre">response</span></tt> 则是从view中返回的response对象。 <tt class="docutils literal"><span class="pre">request</span></tt> is the requestobject, and <tt class="docutils literal"><span class="pre">response</span></tt> is the response object returned from the view.</p><p class="cn" id="cn46">不同可能返回 <tt class="docutils literal"><span class="pre">None</span></tt> 的request和view预处理函数, <tt class="docutils literal"><span class="pre">process_response()</span></tt> <em>必须</em> 返回 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 对象. 这个response对象可以是传入函数的那一个原始对象(通常已被修改)，也可以是全新生成的。 That responsecould be the original one passed into the function (possibly modified) or abrand-new one.</p></div><div class="section" id="exception-process-exception-self-request-exception-process-exception-self-request-exception"><span id="cn47"></span><h3 class="cn" id="cn47">Exception后处理函数: process_exception(self, request, exception) process_exception(self, request, exception)</h3><p class="cn" id="cn48">这个方法只有在request处理过程中出了问题并且view函数抛出了一个未捕获的异常时才会被调用。 这个钩子可以用来发送错误通知，将现场相关信息输出到日志文件, 或者甚至尝试从错误中自动恢复。</p><p class="cn" id="cn49">这个函数的参数除了一贯的 <tt class="docutils literal"><span class="pre">request</span></tt> 对象之外，还包括view函数抛出的实际的异常对象 <tt class="docutils literal"><span class="pre">exception</span></tt> 。</p><p class="cn" id="cn50"><tt class="docutils literal"><span class="pre">process_exception()</span></tt> 应当返回 None 或 HttpResponse 对象.</p><ul class="simple"><li class="cn" id="cn51"><p class="first cn" id="cn51">如果返回 <tt class="docutils literal"><span class="pre">None</span></tt> , Django将用框架内置的异常处理机制继续处理相应request。</p></li></ul><ul class="simple"><li class="cn" id="cn52"><p class="first cn" id="cn52">如果返回 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 对象, Django 将使用该response对象，而短路框架内置的异常处理机制。</p></li></ul><p class="cn" id="cn53">备注</p><p class="cn" id="cn54">Django自带了相当数量的中间件类(将在随后章节介绍)，它们都是相当好的范例。 阅读这些代码将使你对中间件的强大有一个很好的认识。</p><p class="cn" id="cn55">在Djangos wiki上也可以找到大量的社区贡献的中间件范例: <a class="reference external" href="http://code.djangoproject.com/wiki/ContributedMiddleware">http://code.djangoproject.com/wiki/ContributedMiddleware</a><a class="reference external" href="http://code.djangoproject.com/wiki/ContributedMiddleware">http://code.djangoproject.com/wiki/ContributedMiddleware</a></p></div></div><div class="section" id="id5"><span id="cn56"></span><h2 class="cn" id="cn56">内置的中间件</h2><p class="cn" id="cn57">Django自带若干内置中间件以处理常见问题，将从下一节开始讨论。</p><div class="section" id="id6"><span id="cn58"></span><h3 class="cn" id="cn58">认证支持中间件</h3><p class="cn" id="cn59">中间件类: <tt class="docutils literal"><span class="pre">django.contrib.auth.middleware.AuthenticationMiddleware</span></tt> . <tt class="docutils literal"><span class="pre">django.contrib.auth.middleware.AuthenticationMiddleware</span></tt> .</p><p class="cn" id="cn60">这个中间件激活认证支持功能. 它在每个传入的 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 对象中添加代表当前登录用户的 <tt class="docutils literal"><span class="pre">request.user</span></tt> 属性。 It adds the <tt class="docutils literal"><span class="pre">request.user</span></tt>attribute, representing the currently logged-in user, to every incoming<tt class="docutils literal"><span class="pre">HttpRequest</span></tt> object.</p><p class="cn" id="cn61">完整的细节请参见第12章。</p></div><div class="section" id="id7"><span id="cn62"></span><h3 class="cn" id="cn62">通用中间件</h3><p class="cn" id="cn63">Middleware class: <tt class="docutils literal"><span class="pre">django.middleware.common.CommonMiddleware</span></tt> .</p><p class="cn" id="cn64">这个中间件为完美主义者提供了一些便利:</p><blockquote><p class="cn" id="cn65"><em>禁止 ``DISALLOWED_USER_AGENTS`` 列表中所设置的user agent访问</em> ：一旦提供，这一列表应当由已编译的正则表达式对象组成，这些对象用于匹配传入的request请求头中的user-agent域。 下面这个例子来自某个配置文件片段：</p></blockquote><pre class="cn literal-block" id="cn67">import reDISALLOWED_USER_AGENTS = (re.compile(r'^OmniExplorer_Bot'),re.compile(r'^Googlebot'))</pre><blockquote><p class="cn" id="cn68">请注意 <tt class="docutils literal"><span class="pre">import</span> <span class="pre">re</span></tt> ,因为 <tt class="docutils literal"><span class="pre">DISALLOWED_USER_AGENTS</span></tt> 要求其值为已编译的正则表达式(也就是 <tt class="docutils literal"><span class="pre">re.compile()</span></tt> 的返回值)。</p><p class="cn" id="cn69"><em>依据 ``APPEND_SLASH`` 和 ``PREPEND_WWW`` 的设置执行URL重写</em> ：如果 <tt class="docutils literal"><span class="pre">APPEND_SLASH</span></tt> 为 <tt class="docutils literal"><span class="pre">True</span></tt> , 那些尾部没有斜杠的URL将被重定向到添加了斜杠的相应URL，除非path的最末组成部分包含点号。 因此， <tt class="docutils literal"><span class="pre">foo.com/bar</span></tt> 会被重定向到 <tt class="docutils literal"><span class="pre">foo.com/bar/</span></tt> , 但是 <tt class="docutils literal"><span class="pre">foo.com/bar/file.txt</span></tt> 将以不变形式通过。</p><p class="cn" id="cn70">如果 <tt class="docutils literal"><span class="pre">PREPEND_WWW</span></tt> 为 True , 那些缺少先导www.的URLs将会被重定向到含有先导www.的相应URL上。 will beredirected to the same URL with a leading www..</p><p class="cn" id="cn71">这两个选项都是为了规范化URL。 其后的哲学是每个URL都应且只应当存在于一处。 技术上来说，URL <tt class="docutils literal"><span class="pre">example.com/bar</span></tt> 与 <tt class="docutils literal"><span class="pre">example.com/bar/</span></tt> 及 <tt class="docutils literal"><span class="pre">www.example.com/bar/</span></tt> 都互不相同。</p><p class="cn" id="cn72"><em>依据 ``USE_ETAGS`` 的设置处理Etag</em> : <em>ETags</em> 是HTTP级别上按条件缓存页面的优化机制。 如果 <tt class="docutils literal"><span class="pre">USE_ETAGS</span></tt> 为 <tt class="docutils literal"><span class="pre">True</span></tt> ，Django针对每个请求以MD5算法处理页面内容，从而得到Etag, 在此基础上，Django将在适当情形下处理并返回 <tt class="docutils literal"><span class="pre">Not</span> <span class="pre">Modified</span></tt> 回应(译注：</p><p class="cn" id="cn73">请注意，还有一个条件化的 <tt class="docutils literal"><span class="pre">GET</span></tt> 中间件, 处理Etags并干得更多，下面马上就会提及。</p></blockquote></div><div class="section" id="id8"><span id="cn74"></span><h3 class="cn" id="cn74">压缩中间件</h3><p class="cn" id="cn75">中间件类 <tt class="docutils literal"><span class="pre">django.middleware.gzip.GZipMiddleware</span></tt> .</p><p class="cn" id="cn76">这个中间件自动为能处理gzip压缩(包括所有的现代浏览器)的浏览器自动压缩返回]内容。 这将极大地减少Web服务器所耗用的带宽。 代价是压缩页面需要一些额外的处理时间。</p><p class="cn" id="cn77">相对于带宽，人们一般更青睐于速度，但是如果你的情形正好相反，尽可启用这个中间件。</p></div><div class="section" id="get"><span id="cn78"></span><h3 class="cn" id="cn78">条件化的GET中间件</h3><p class="cn" id="cn79">Middleware class: <tt class="docutils literal"><span class="pre">django.middleware.http.ConditionalGetMiddleware</span></tt> .</p><p class="cn" id="cn80">这个中间件对条件化 <tt class="docutils literal"><span class="pre">GET</span></tt> 操作提供支持。 如果response头中包括 <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> 或 <tt class="docutils literal"><span class="pre">ETag</span></tt> 域，并且request头中包含 <tt class="docutils literal"><span class="pre">If-None-Match</span></tt> 或 <tt class="docutils literal"><span class="pre">If-Modified-Since</span></tt> 域，且两者一致，则该response将被response 304(Not modified)取代。 对 <tt class="docutils literal"><span class="pre">ETag</span></tt> 的支持依赖于 <tt class="docutils literal"><span class="pre">USE_ETAGS</span></tt> 配置及事先在response头中设置 <tt class="docutils literal"><span class="pre">ETag</span></tt> 域。稍前所讨论的通用中间件可用于设置response中的 <tt class="docutils literal"><span class="pre">ETag</span></tt> 域。 Asdiscussed above, the <tt class="docutils literal"><span class="pre">ETag</span></tt> header is set by the Common middleware.</p><p class="cn" id="cn81">此外，它也将删除处理 <tt class="docutils literal"><span class="pre">HEAD</span></tt> request时所生成的response中的任何内容，并在所有request的response头中设置 <tt class="docutils literal"><span class="pre">Date</span></tt> 和 <tt class="docutils literal"><span class="pre">Content-Length</span></tt> 域。</p></div><div class="section" id="x-forwarded-for"><span id="cn82"></span><h3 class="cn" id="cn82">反向代理支持 (X-Forwarded-For中间件)</h3><p class="cn" id="cn83">Middleware class: <tt class="docutils literal"><span class="pre">django.middleware.http.SetRemoteAddrFromForwardedFor</span></tt> .</p><p class="cn" id="cn84">这是我们在 什么是中间件 这一节中所举的例子。 在 <tt class="docutils literal"><span class="pre">request.META['HTTP_X_FORWARDED_FOR']</span></tt> 存在的前提下，它根据其值来设置 <tt class="docutils literal"><span class="pre">request.META['REMOTE_ADDR']</span></tt> 。在站点位于某个反向代理之后的、每个request的 <tt class="docutils literal"><span class="pre">REMOTE_ADDR</span></tt> 都被指向 <tt class="docutils literal"><span class="pre">127.0.0.1</span></tt> 的情形下，这一功能将非常有用。 Itsets <tt class="docutils literal"><span class="pre">request.META['REMOTE_ADDR']</span></tt> based on<tt class="docutils literal"><span class="pre">request.META['HTTP_X_FORWARDED_FOR']</span></tt> , if the latter is set. This is usefulif you&#8217;re sitting behind a reverse proxy that causes each request&#8217;s<tt class="docutils literal"><span class="pre">REMOTE_ADDR</span></tt> to be set to <tt class="docutils literal"><span class="pre">127.0.0.1</span></tt> .</p><p class="cn" id="cn85">红色警告！</p><p class="cn" id="cn86">这个middleware并 <em>不</em> 验证 <tt class="docutils literal"><span class="pre">HTTP_X_FORWARDED_FOR</span></tt> 的合法性。</p><p class="cn" id="cn87">如果站点并不位于自动设置 <tt class="docutils literal"><span class="pre">HTTP_X_FORWARDED_FOR</span></tt> 的反向代理之后，请不要使用这个中间件。 否则，因为任何人都能够伪造 <tt class="docutils literal"><span class="pre">HTTP_X_FORWARDED_FOR</span></tt> 值，而 <tt class="docutils literal"><span class="pre">REMOTE_ADDR</span></tt> 又是依据 <tt class="docutils literal"><span class="pre">HTTP_X_FORWARDED_FOR</span></tt> 来设置，这就意味着任何人都能够伪造IP地址。</p><p class="cn" id="cn88">只有当能够绝对信任 <tt class="docutils literal"><span class="pre">HTTP_X_FORWARDED_FOR</span></tt> 值得时候才能够使用这个中间件。</p></div><div class="section" id="id9"><span id="cn89"></span><h3 class="cn" id="cn89">会话支持中间件</h3><p class="cn" id="cn90">Middleware class: <tt class="docutils literal"><span class="pre">django.contrib.sessions.middleware.SessionMiddleware</span></tt> .</p><p class="cn" id="cn91">这个中间件激活会话支持功能. 细节请参见第12章。 See Chapter 14 for details.</p></div><div class="section" id="id10"><span id="cn92"></span><h3 class="cn" id="cn92">站点缓存中间件</h3><p class="cn" id="cn93">Middleware classes: <tt class="docutils literal"><span class="pre">django.middleware.cache.UpdateCacheMiddleware</span></tt> and<tt class="docutils literal"><span class="pre">django.middleware.cache.FetchFromCacheMiddleware</span></tt> .</p><p class="cn" id="cn94">这些中间件互相配合以缓存每个基于Django的页面。 已在第13章中详细讨论。</p></div><div class="section" id="id11"><span id="cn95"></span><h3 class="cn" id="cn95">事务处理中间件</h3><p class="cn" id="cn96">Middleware class: <tt class="docutils literal"><span class="pre">django.middleware.transaction.TransactionMiddleware</span></tt> .</p><p class="cn" id="cn97">这个中间件将数据库的 <tt class="docutils literal"><span class="pre">COMMIT</span></tt> 或 <tt class="docutils literal"><span class="pre">ROLLBACK</span></tt> 绑定到request/response处理阶段。 如果view函数成功执行，则发出 <tt class="docutils literal"><span class="pre">COMMIT</span></tt> 指令。 如果view函数抛出异常，则发出 <tt class="docutils literal"><span class="pre">ROLLBACK</span></tt> 指令。</p><p class="cn" id="cn98">这个中间件在栈中的顺序非常重要。 其外层的中间件模块运行在Django缺省的 保存-提交 行为模式下。而其内层中间件(在栈中的其后位置出现)将置于与view函数一致的事务机制的控制下。</p><p class="cn" id="cn99">关于数据库事务处理的更多信息，请参见附录C。</p></div></div><div class="section" id="id12"><span id="cn100"></span><h2 class="cn" id="cn100">下一章</h2><p class="cn" id="cn101">Web开发者和数据库模式设计人员并不总是享有白手起家打造项目的奢侈机会。 In the <a class="reference external" href="chapter18.html">next chapter</a>, we&#8217;ll cover how to integratewith legacy systems, such as database schemas you&#8217;ve inherited from the 1980s.</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter16.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter18.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>