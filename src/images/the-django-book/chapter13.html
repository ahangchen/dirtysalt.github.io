<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-type" content="text/html; charset=utf-8" /><title>第十三章： 输出非HTML内容</title><link rel="stylesheet" href="sitemedia/v2/css/reset-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/grids-min.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/djangobook.css" type="text/css"><link rel="stylesheet" href="sitemedia/v2/css/new.css" type="text/css"><link href="sitemedia/v2/css/container.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/tabs.css" type="text/css" media="screen" rel="stylesheet"><link href="sitemedia/v2/css/resizable.css" type="text/css" media="screen" rel="stylesheet"></head><body><div id="doc" class="yui-t7"><div id="hd"><h1><a href="/2.0/">The Django Book</a></h1><div id="global-nav"><a class="about" href="http://new.djangobook.com/about/">About</a>|<a class="comment-help" href="http://new.djangobook.com/about/comments/">Comment help</a>|<a class="contact" href="http://new.djangobook.com/contact/">Contact us</a>|<a class="errata" href="http://new.djangobook.com/errata/">Errata</a>|<a class="buy" href="http://www.amazon.com/gp/product/1590597257?ie=UTF8&amp;tag=jacobianorg-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1590597257">Buy the print version on Amazon.com</a></div><div class="nav"><a href="chapter12.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter14.html">下一章 </a> |</div></div><div id="bd"><div id="yui-main"><div class="yui-b"><div id="chapter-body"><div class="document" id="html"><h1 class="cn title" id="cn0">第十三章： 输出非HTML内容</h1><p class="cn" id="cn1">通常当我们谈到开发网站时，主要谈论的是HTML。当然，Web远不只有HTML，我们在Web上用多种格式来发布数据： RSS、PDF、图片等。</p><p class="cn" id="cn2">到目前为止，我们的注意力都是放在常见 HTML 代码生成上，但是在这一章中，我们将会对使用 Django 生成其它格式的内容进行简要介绍。</p><p class="cn" id="cn3">Django拥有一些便利的内建工具帮助你生成常见的非HTML内容：</p><ul class="simple"><li class="cn" id="cn4"><p class="first cn" id="cn4">RSS/Atom 聚合文件</p></li></ul><ul class="simple"><li class="cn" id="cn5"><p class="first cn" id="cn5">站点地图 （一个XML格式文件，最初由Google开发，用于给搜索引擎提示线索）</p></li></ul><p class="cn" id="cn6">我们稍后会逐一研究这些工具，不过首先让我们来了解些基础原理。</p><div class="section" id="mime"><span id="cn7"></span><h2 class="cn" id="cn7">基础： 视图和MIME类型</h2><p class="cn" id="cn8">回顾一下第三章，视图函数只是一个以Web请求为参数并返回Web响应的Python函数。 这个响应可以是一个Web页面的HTML内容，或者一个跳转，或者一个404 错误，或者一个XML文档，或者一幅图片，或者映射到任何东西上。</p><p class="cn" id="cn9">更正式的说，一个Django视图函数 <em>必须</em></p><ul class="simple"><li class="cn" id="cn10"><p class="first cn" id="cn10">接受一个 <tt class="docutils literal"><span class="pre">HttpRequest</span></tt> 实例作为它的第一个参数</p></li></ul><ul class="simple"><li class="cn" id="cn11"><p class="first cn" id="cn11">返回一个 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 实例</p></li></ul><p class="cn" id="cn12">从一个视图返回一个非 HTML 内容的关键是在构造一个 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 类时，需要指定 <tt class="docutils literal"><span class="pre">mimetype</span></tt> 参数。 通过改变 MIME 类型，我们可以通知浏览器将要返回的数据是另一种类型。</p><p class="cn" id="cn13">下面我们以返回一张PNG图片的视图为例。 为了使事情能尽可能的简单，我们只是读入一张存储在磁盘上的图片：</p><pre class="cn literal-block" id="cn15">from django.http import HttpResponsedef my_image(request):image_data = open(&quot;/path/to/my/image.png&quot;, &quot;rb&quot;).read()return HttpResponse(image_data, mimetype=&quot;image/png&quot;)</pre><p class="cn" id="cn16">就是这么简单。 如果改变 <tt class="docutils literal"><span class="pre">open()</span></tt> 中的图片路径为一张真实图片的路径，那么就可以使用这个十分简单的视图来提供一张图片，并且浏览器可以正确显示它。</p><p class="cn" id="cn17">另外我们必须了解的是<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>对象实现了Python标准的文件应用程序接口(API)。 这就是说你可以在Python（或第三方库）任何用到文件的地方使用&#8221;HttpResponse&#8221;实例。</p><p class="cn" id="cn18">下面将用 Django 生成 CSV 文件为例，说明它的工作原理。</p></div><div class="section" id="csv"><span id="cn19"></span><h2 class="cn" id="cn19">生成 CSV 文件</h2><p class="cn" id="cn20">CSV 是一种简单的数据格式，通常为电子表格软件所使用。 它主要是由一系列的表格行组成，每行中单元格之间使用逗号(CSV 是 <em>逗号分隔数值(comma-separated values)</em> 的缩写)隔开。例如，下面是CSV格式的“不守规矩”的飞机乘客表。</p><pre class="cn literal-block" id="cn22">Year,Unruly Airline Passengers1995,1461996,1841997,2351998,2001999,2262000,2512001,2992002,2732003,2812004,3042005,2032006,1342007,147</pre><p class="cn" id="cn23">备注</p><p class="cn" id="cn24">前面的列表包含真实数据。 这些数据来自美国 联邦航空管理局。</p><p class="cn" id="cn25">CSV格式尽管看起来简单，却是全球通用的。 但是不同的软件会生成和使用不同的 CSV 的变种，在使用上会有一些不便。 幸运的是， Python 使用的是标准 CSV 库， <tt class="docutils literal"><span class="pre">csv</span></tt> ，所以它更通用。</p><p class="cn" id="cn26">因为 <tt class="docutils literal"><span class="pre">csv</span></tt> 模块操作的是类似文件的对象，所以可以使用 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 替换：</p><pre class="cn literal-block" id="cn28">import csvfrom django.http import HttpResponse# Number of unruly passengers each year 1995 - 2005. In a real application# this would likely come from a database or some other back-end data store.UNRULY_PASSENGERS = [146,184,235,200,226,251,299,273,281,304,203]def unruly_passengers_csv(request):# Create the HttpResponse object with the appropriate CSV header.response = HttpResponse(mimetype='text/csv')response['Content-Disposition'] = 'attachment; filename=unruly.csv'# Create the CSV writer using the HttpResponse as the &quot;file.&quot;writer = csv.writer(response)writer.writerow(['Year', 'Unruly Airline Passengers'])for (year, num) in zip(range(1995, 2006), UNRULY_PASSENGERS):writer.writerow([year, num])return response</pre><p class="cn" id="cn29">代码和注释可以说是很清楚，但还有一些事情需要特别注意：</p><blockquote><p class="cn" id="cn30">响应返回的是 <tt class="docutils literal"><span class="pre">text/csv</span></tt> MIME类型（而非默认的 <tt class="docutils literal"><span class="pre">text/html</span></tt> ）。这会告诉浏览器，返回的文档是CSV文件。</p><p class="cn" id="cn31">响应会有一个附加的 <tt class="docutils literal"><span class="pre">Content-Disposition</span></tt> 头部，它包含有CSV文件的文件名。 这个头部（或者说，附加部分）会指示浏览器弹出对话框询问文件存放的位置（而不仅仅是显示）。 这个文件名是任意的。 它会显示在浏览器的另存为对话框中。</p><p class="cn" id="cn32">要在<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>指定头部信息，只需把<tt class="docutils literal"><span class="pre">HttpResponse</span></tt>当做字典使用就可以了。</p><p class="cn" id="cn33">与创建CSV的应用程序界面（API）挂接是很容易的： 只需将 <tt class="docutils literal"><span class="pre">response</span></tt> 作为第一个变量传递给 <tt class="docutils literal"><span class="pre">csv.writer</span></tt> 。 <tt class="docutils literal"><span class="pre">csv.writer</span></tt> 函数需要一个文件类的对象， <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 正好能达成这个目的。</p><p class="cn" id="cn34">调用 <tt class="docutils literal"><span class="pre">writer.writerow</span></tt> ，并且传递给它一个类似 list 或者 tuple 的可迭代对象，就可以在 CSV 文件中写入一行。</p><p class="cn" id="cn35">CSV 模块考虑到了引用的问题，所以您不用担心逸出字符串中引号和逗号。 只要把信息传递给 <tt class="docutils literal"><span class="pre">writerow()</span></tt> ，它会处理好所有的事情。</p></blockquote><p class="cn" id="cn36">在任何需要返回非 HTML 内容的时候，都需要经过以下几步：创建一个 <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> 响应对象（需要指定特殊的 MIME 类型），它它传给需要处理文件的函数，然后返回这个响应对象。</p><p class="cn" id="cn37">下面是一些其它的例子。</p></div><div class="section" id="pdf"><span id="cn38"></span><h2 class="cn" id="cn38">生成 PDF 文件</h2><p class="cn" id="cn39">便携文档格式 (PDF) 是由 Adobe 开发的格式，主要用于呈现可打印的文档，其中包含有 pixel-perfect 格式，嵌入字体以及2D矢量图像。 You can think of a PDF document as the digitalequivalent of a printed document; indeed, PDFs are often used in distributingdocuments for the purpose of printing them.</p><p class="cn" id="cn40">可以方便的使用 Python 和 Django 生成 PDF 文档需要归功于一个出色的开源库， ReportLab (<a class="reference external" href="http://www.reportlab.org/rl_toolkit.html">http://www.reportlab.org/rl_toolkit.html</a>) 。动态生成 PDF 文件的好处是在不同的情况下，如不同的用户或者不同的内容，可以按需生成不同的 PDF 文件。 Theadvantage of generating PDF files dynamically is that you can create customized PDFsfor different purposes say, for different users or different pieces of content.</p><p class="cn" id="cn41">下面的例子是使用 Django 和 ReportLab 在 KUSports.com 上生成个性化的可打印的 NCAA 赛程表 (tournament brackets) 。</p><div class="section" id="reportlab"><span id="cn42"></span><h3 class="cn" id="cn42">安装 ReportLab</h3><p class="cn" id="cn43">在生成 PDF 文件之前，需要安装 ReportLab 库。这通常是个很简单的过程： Itsusually simple: just download and install the library from<a class="reference external" href="http://www.reportlab.org/downloads.html">http://www.reportlab.org/downloads.html</a>.</p><p class="cn" id="cn44">Note</p><p class="cn" id="cn45">如果使用的是一些新的 Linux 发行版，则在安装前可以先检查包管理软件。 多数软件包仓库中都加入了 ReportLab 。</p><p class="cn" id="cn46">比如，如果使用（杰出的） Ubuntu 发行版，只需要简单的 <tt class="docutils literal"><span class="pre">apt-get</span> <span class="pre">install</span> <span class="pre">python-reportlab</span></tt> 一行命令即可完成安装。</p><p class="cn" id="cn47">使用手册（原始的只有 PDF 格式）可以从 <a class="reference external" href="http://www.reportlab.org/rsrc/userguide.pdf">http://www.reportlab.org/rsrc/userguide.pdf</a> 下载，其中包含有一些其它的安装指南。</p><p class="cn" id="cn48">在 Python 交互环境中导入这个软件包以检查安装是否成功。</p><pre class="cn literal-block" id="cn50">&gt;&gt;&gt; import reportlab</pre><p class="cn" id="cn51">如果刚才那条命令没有出现任何错误，则表明安装成功。</p></div><div class="section" id="id1"><span id="cn52"></span><h3 class="cn" id="cn52">编写视图</h3><p class="cn" id="cn53">和 CSV 类似，由 Django 动态生成 PDF 文件很简单，因为 ReportLab API 同样可以使用类似文件对象。</p><p class="cn" id="cn54">下面是一个 Hello World 的示例：</p><pre class="cn literal-block" id="cn56">from reportlab.pdfgen import canvasfrom django.http import HttpResponsedef hello_pdf(request):# Create the HttpResponse object with the appropriate PDF headers.response = HttpResponse(mimetype='application/pdf')response['Content-Disposition'] = 'attachment; filename=hello.pdf'# Create the PDF object, using the response object as its &quot;file.&quot;p = canvas.Canvas(response)# Draw things on the PDF. Here's where the PDF generation happens.# See the ReportLab documentation for the full list of functionality.p.drawString(100, 100, &quot;Hello world.&quot;)# Close the PDF object cleanly, and we're done.p.showPage()p.save()return response</pre><p class="cn" id="cn57">需要注意以下几点：</p><ul class="simple"><li class="cn" id="cn58"><p class="first cn" id="cn58">这里我们使用的 MIME 类型是 <tt class="docutils literal"><span class="pre">application/pdf</span></tt> 。这会告诉浏览器这个文档是一个 PDF 文档，而不是 HTML 文档。 如果忽略了这个参数，浏览器可能会把这个文件看成 HTML 文档，这会使浏览器的窗口中出现很奇怪的文字。 If you leave off thisinformation, browsers will probably interpret the response as HTML, which willresult in scary gobbledygook in the browser window.</p></li></ul><ul class="simple"><li class="cn" id="cn59"><p class="first cn" id="cn59">使用 ReportLab 的 API 很简单： 只需要将 <tt class="docutils literal"><span class="pre">response</span></tt> 对象作为 <tt class="docutils literal"><span class="pre">canvas.Canvas</span></tt> 的第一个参数传入。</p></li></ul><ul class="simple"><li class="cn" id="cn60"><p class="first cn" id="cn60">所有后续的 PDF 生成方法需要由 PDF 对象调用（在本例中是 <tt class="docutils literal"><span class="pre">p</span></tt> ），而不是 <tt class="docutils literal"><span class="pre">response</span></tt> 对象。</p></li></ul><ul class="simple"><li class="cn" id="cn61"><p class="first cn" id="cn61">最后需要对 PDF 文件调用 <tt class="docutils literal"><span class="pre">showPage()</span></tt> 和 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法（否则你会得到一个损坏的 PDF 文件）。</p></li></ul></div><div class="section" id="id2"><span id="cn62"></span><h3 class="cn" id="cn62">复杂的 PDF 文件</h3><p class="cn" id="cn63">如果您在创建一个复杂的 PDF 文档（或者任何较大的数据块），请使用 <tt class="docutils literal"><span class="pre">cStringIO</span></tt> 库存放临时生成的 PDF 文件。 <tt class="docutils literal"><span class="pre">cStringIO</span></tt> 提供了一个用 C 编写的类似文件对象的接口，从而可以使系统的效率最高。</p><p class="cn" id="cn64">下面是使用 <tt class="docutils literal"><span class="pre">cStringIO</span></tt> 重写的 Hello World 例子：</p><pre class="cn literal-block" id="cn66">from cStringIO import StringIOfrom reportlab.pdfgen import canvasfrom django.http import HttpResponsedef hello_pdf(request):# Create the HttpResponse object with the appropriate PDF headers.response = HttpResponse(mimetype='application/pdf')response['Content-Disposition'] = 'attachment; filename=hello.pdf'temp = StringIO()# Create the PDF object, using the StringIO object as its &quot;file.&quot;p = canvas.Canvas(temp)# Draw things on the PDF. Here's where the PDF generation happens.# See the ReportLab documentation for the full list of functionality.p.drawString(100, 100, &quot;Hello world.&quot;)# Close the PDF object cleanly.p.showPage()p.save()# Get the value of the StringIO buffer and write it to the response.response.write(temp.getvalue())return response</pre></div></div><div class="section" id="id3"><span id="cn67"></span><h2 class="cn" id="cn67">其它的可能性</h2><p class="cn" id="cn68">使用 Python 可以生成许多其它类型的内容，下面介绍的是一些其它的想法和一些可以用以实现它们的库。 Here area few more ideas and some pointers to libraries you could use to implement them:</p><blockquote><p class="cn" id="cn69"><em>ZIP 文件</em> ：Python 标准库中包含有 <tt class="docutils literal"><span class="pre">zipfile</span></tt> 模块，它可以读和写压缩的 ZIP 文件。 它可以用于按需生成一些文件的压缩包，或者在需要时压缩大的文档。 如果是 TAR 文件则可以使用标准库 <tt class="docutils literal"><span class="pre">tarfile</span></tt> 模块。</p><p class="cn" id="cn70"><em>动态图片</em> ： Python 图片处理库 (PIL; <a class="reference external" href="http://www.pythonware.com/products/pil/">http://www.pythonware.com/products/pil/</a>) 是极好的生成图片(PNG, JPEG, GIF 以及其它许多格式)的工具。 它可以用于自动为图片生成缩略图，将多张图片压缩到单独的框架中，或者是做基于 Web 的图片处理。</p><p class="cn" id="cn71"><em>图表</em> ： Python 有许多出色并且强大的图表库用以绘制图表，按需地图，表格等。 我们不可能将它们全部列出，所以下面列出的是个中的翘楚。</p><ul class="simple"><li class="cn" id="cn72"><p class="first cn" id="cn72"><tt class="docutils literal"><span class="pre">matplotlib</span></tt> (<a class="reference external" href="http://matplotlib.sourceforge.net/">http://matplotlib.sourceforge.net/</a>) 可以用于生成通常是由 matlab 或者 Mathematica 生成的高质量图表。</p></li></ul><ul class="simple"><li class="cn" id="cn73"><p class="first cn" id="cn73"><tt class="docutils literal"><span class="pre">pygraphviz</span></tt> (<a class="reference external" href="https://networkx.lanl.gov/wiki/pygraphviz">https://networkx.lanl.gov/wiki/pygraphviz</a>) 是一个 Graphviz 图形布局的工具 (<a class="reference external" href="http://graphviz.org/">http://graphviz.org/</a>) 的 Python 接口，可以用于生成结构化的图表和网络。</p></li></ul></blockquote><p class="cn" id="cn74">总之，所有可以写文件的库都可以与 Django 同时使用。 The possibilities are immense.</p><p class="cn" id="cn75">我们已经了解了生成“非HTML”内容的基本知识，让我们进一步总结一下。 Django拥有很多用以生成各类“非HTML”内容的内置工具。</p></div><div class="section" id="id4"><span id="cn76"></span><h2 class="cn" id="cn76">内容聚合器应用框架</h2><p class="cn" id="cn77">Django带来了一个高级的聚合生成框架，它使得创建RSS和Atom feeds变得非常容易。</p><p class="cn" id="cn78">什么是RSS？ 什么是Atom？</p><p class="cn" id="cn79">RSS和Atom都是基于XML的格式，你可以用它来提供有关你站点内容的自动更新的feed。 了解更多关于RSS的可以访问 <a class="reference external" href="http://www.whatisrss.com/">http://www.whatisrss.com/</a>, 更多Atom的信息可以访问 <a class="reference external" href="http://www.atomenabled.org/">http://www.atomenabled.org/</a>.</p><p class="cn" id="cn80">想创建一个联合供稿的源(syndication feed)，所需要做的只是写一个简短的python类。你可以创建任意多的源(feed)。</p><p class="cn" id="cn81">高级feed生成框架是一个默认绑定到/feeds/的视图，Django使用URL的其它部分(在/feeds/之后的任何东西)来决定输出 哪个feed Django uses the remainder of the URL (everything after <tt class="docutils literal"><span class="pre">/feeds/</span></tt> ) todetermine which feed to return.</p><p class="cn" id="cn82">要创建一个 sitemap，你只需要写一个 <tt class="docutils literal"><span class="pre">Sitemap</span></tt> 类然后配置你的URLconf指向它。</p><div class="section" id="id5"><span id="cn83"></span><h3 class="cn" id="cn83">初始化</h3><p class="cn" id="cn84">为了在您的Django站点中激活syndication feeds, 添加如下的 URLconf:</p><pre class="cn literal-block" id="cn86">(r'^feeds/(?P&lt;url&gt;.*)/$', 'django.contrib.syndication.views.feed',{'feed_dict': feeds}),</pre><p class="cn" id="cn87">这一行告诉Django使用RSS框架处理所有的以 <tt class="docutils literal"><span class="pre">&quot;feeds/&quot;</span></tt> 开头的URL. ( 你可以修改 <tt class="docutils literal"><span class="pre">&quot;feeds/&quot;</span></tt> 前缀以满足您自己的要求. )</p><p class="cn" id="cn88">URLConf里有一行参数： <tt class="docutils literal"><span class="pre">{'feed_dict':</span> <span class="pre">feeds}</span></tt>，这个参数可以把对应URL需要发布的feed内容传递给 syndication framework</p><p class="cn" id="cn89">特别的，feed_dict应该是一个映射feed的slug(简短URL标签)到它的Feed类的字典 你可以在URL配置本身里定义feed_dict，这里是一个完整的例子 You can define the <tt class="docutils literal"><span class="pre">feed_dict</span></tt> in the URLconfitself. Here&#8217;s a full example URLconf:</p><pre class="cn literal-block" id="cn91">from django.conf.urls.defaults import *from mysite.feeds import LatestEntries, LatestEntriesByCategoryfeeds = {'latest': LatestEntries,'categories': LatestEntriesByCategory,}urlpatterns = patterns('',# ...(r'^feeds/(?P&lt;url&gt;.*)/$', 'django.contrib.syndication.views.feed',{'feed_dict': feeds}),# ...)</pre><p class="cn" id="cn92">前面的例子注册了两个feed:</p><ul class="simple"><li class="cn" id="cn93"><p class="first cn" id="cn93"><tt class="docutils literal"><span class="pre">LatestEntries``表示的内容将对应到``feeds/latest/</span></tt> .</p></li></ul><ul class="simple"><li class="cn" id="cn94"><p class="first cn" id="cn94"><tt class="docutils literal"><span class="pre">LatestEntriesByCategory``的内容将对应到</span> <span class="pre">``feeds/categories/</span></tt> .</p></li></ul><p class="cn" id="cn95">以上的设定完成之后，接下来需要自己定义 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类</p><p class="cn" id="cn96">一个 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类是一个简单的python类，用来表示一个syndication feed. 一个feed可能是简单的 (例如一个站点新闻feed，或者最基本的，显示一个blog的最新条目)，也可能更加复杂(例如一个显示blog某一类别下所有条目的feed。 这里类别 category 是个变量).</p><p class="cn" id="cn97">Feed类必须继承django.contrib.syndication.feeds.Feed，它们可以在你的代码树的任何位置</p></div><div class="section" id="feed"><span id="cn98"></span><h3 class="cn" id="cn98">一个简单的Feed</h3><p class="cn" id="cn99">This simple example describes a feed of the latest five blog entries for a givenblog:</p><pre class="cn literal-block" id="cn101">from django.contrib.syndication.feeds import Feedfrom mysite.blog.models import Entryclass LatestEntries(Feed):title = &quot;My Blog&quot;link = &quot;/archive/&quot;description = &quot;The latest news about stuff.&quot;def items(self):return Entry.objects.order_by('-pub_date')[:5]</pre><p class="cn" id="cn102">要注意的重要的事情如下所示:</p><ul class="simple"><li class="cn" id="cn103"><p class="first cn" id="cn103">子类 <tt class="docutils literal"><span class="pre">django.contrib.syndication.feeds.Feed</span></tt> .</p></li></ul><ul class="simple"><li class="cn" id="cn104"><p class="first cn" id="cn104"><tt class="docutils literal"><span class="pre">title</span></tt> , <tt class="docutils literal"><span class="pre">link</span></tt> , 和 <tt class="docutils literal"><span class="pre">description</span></tt> 对应一个标准 RSS 里的 <tt class="docutils literal"><span class="pre">&lt;title&gt;</span></tt> , <tt class="docutils literal"><span class="pre">&lt;link&gt;</span></tt> , 和 <tt class="docutils literal"><span class="pre">&lt;description&gt;</span></tt> 标签.</p></li></ul><ul class="simple"><li class="cn" id="cn105"><p class="first cn" id="cn105"><tt class="docutils literal"><span class="pre">items()</span></tt> 是一个方法，返回一个用以包含在包含在feed的 <tt class="docutils literal"><span class="pre">&lt;item&gt;</span></tt> 元素里的 list 虽然例子里用Djangos database API返回的 <tt class="docutils literal"><span class="pre">NewsItem</span></tt> 对象, <tt class="docutils literal"><span class="pre">items()</span></tt> 不一定必须返回 model的实例 Although this example returns<tt class="docutils literal"><span class="pre">Entry</span></tt> objects using Django&#8217;s database API, <tt class="docutils literal"><span class="pre">items()</span></tt> doesn&#8217;t have toreturn model instances.</p></li></ul><p class="cn" id="cn106">还有一个步骤，在一个RSS feed里，每个(item)有一个(title)，(link)和(description)，我们需要告诉框架 把数据放到这些元素中 In an RSS feed, each <tt class="docutils literal"><span class="pre">&lt;item&gt;</span></tt> has a <tt class="docutils literal"><span class="pre">&lt;title&gt;</span></tt> ,<tt class="docutils literal"><span class="pre">&lt;link&gt;</span></tt> , and <tt class="docutils literal"><span class="pre">&lt;description&gt;</span></tt> . We need to tell the framework what data to putinto those elements.</p><blockquote><p class="cn" id="cn107">如果要指定 <tt class="docutils literal"><span class="pre">&lt;title&gt;</span></tt> 和 <tt class="docutils literal"><span class="pre">&lt;description&gt;</span></tt> ，可以建立一个Django模板（见Chapter 4）名字叫 <tt class="docutils literal"><span class="pre">feeds/latest_title.html</span></tt> 和 <tt class="docutils literal"><span class="pre">feeds/latest_description.html</span></tt> ，后者是URLConf里为对应feed指定的 <tt class="docutils literal"><span class="pre">slug</span></tt> 。注意 <tt class="docutils literal"><span class="pre">.html</span></tt> 后缀是必须的。 Note that the <tt class="docutils literal"><span class="pre">.html</span></tt> extension isrequired.</p><p class="cn" id="cn108">RSS系统模板渲染每一个条目，需要给传递2个参数给模板上下文变量：</p><ul class="simple"><li class="cn" id="cn109"><p class="first cn" id="cn109"><tt class="docutils literal"><span class="pre">obj</span></tt> : 当前对象 ( 返回到 <tt class="docutils literal"><span class="pre">items()</span></tt> 任意对象之一 )。</p></li></ul><ul class="simple"><li class="cn" id="cn110"><p class="first cn" id="cn110"><tt class="docutils literal"><span class="pre">site</span></tt> : 一个表示当前站点的 <tt class="docutils literal"><span class="pre">django.models.core.sites.Site</span></tt> 对象。 这对于 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">site.domain</span> <span class="pre">}}</span></tt> 或者 <tt class="docutils literal"><span class="pre">{{</span> <span class="pre">site.name</span> <span class="pre">}}</span></tt> 很有用。</p></li></ul><p class="cn" id="cn111">如果你在创建模板的时候，没有指明标题或者描述信息，框架会默认使用 <tt class="docutils literal"><span class="pre">&quot;{{</span> <span class="pre">obj</span> <span class="pre">}}&quot;</span></tt> ，对象的字符串表示。 (For model objects, this will be the<tt class="docutils literal"><span class="pre">__unicode__()</span></tt> method.</p><p class="cn" id="cn112">你也可以通过修改 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类中的两个属性 <tt class="docutils literal"><span class="pre">title_template</span></tt> 和 <tt class="docutils literal"><span class="pre">description_template</span></tt> 来改变这两个模板的名字。</p><p class="cn" id="cn113">你有两种方法来指定 <tt class="docutils literal"><span class="pre">&lt;link&gt;</span></tt> 的内容。 Django 首先执行 <tt class="docutils literal"><span class="pre">items()</span></tt> 中每一项的 <tt class="docutils literal"><span class="pre">get_absolute_url()</span></tt> 方法。 如果该方法不存在，就会尝试执行 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类中的 <tt class="docutils literal"><span class="pre">item_link()</span></tt> 方法，并将自身作为 <tt class="docutils literal"><span class="pre">item</span></tt> 参数传递进去。</p><p class="cn" id="cn114"><tt class="docutils literal"><span class="pre">get_absolute_url()</span></tt> 和 <tt class="docutils literal"><span class="pre">item_link()</span></tt> 都应该以Python字符串形式返回URL。</p><p class="cn" id="cn115">对于前面提到的 <tt class="docutils literal"><span class="pre">LatestEntries</span></tt> 例子，我们可以实现一个简单的feed模板。 <tt class="docutils literal"><span class="pre">latest_title.html</span></tt> 包括：</p></blockquote><pre class="cn literal-block" id="cn117">{{ obj.title }}</pre><blockquote><p class="cn" id="cn118">并且 <tt class="docutils literal"><span class="pre">latest_description.html</span></tt> 包含:</p></blockquote><pre class="cn literal-block" id="cn120">{{ obj.description }}</pre><blockquote><p class="cn" id="cn121">这真是 <em>太</em> 简单了！</p></blockquote></div><div class="section" id="id6"><span id="cn122"></span><h3 class="cn" id="cn122">一个更复杂的Feed</h3><p class="cn" id="cn123">框架通过参数支持更加复杂的feeds。</p><p class="cn" id="cn124">For example, say your blog offers an RSS feed for every distinct tag you&#8217;ve used tocategorize your entries. 如果为每一个单独的区域建立一个 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类就显得很不明智。</p><p class="cn" id="cn125">取而代之的方法是，使用聚合框架来产生一个通用的源，使其可以根据feeds URL返回相应的信息。</p><p class="cn" id="cn126">Your tag-specific feeds could use URLs like this:</p><ul class="simple"><li class="cn" id="cn127"><p class="first cn" id="cn127"><tt class="docutils literal"><span class="pre">http://example.com/feeds/tags/python/</span></tt> : Returns recent entries tagged withpython</p></li></ul><ul class="simple"><li class="cn" id="cn128"><p class="first cn" id="cn128"><tt class="docutils literal"><span class="pre">http://example.com/feeds/tags/cats/</span></tt> : Returns recent entries tagged withcats</p></li></ul><p class="cn" id="cn129">固定的那一部分是 <tt class="docutils literal"><span class="pre">&quot;beats&quot;</span></tt> （区域）。</p><p class="cn" id="cn130">举个例子会澄清一切。 下面是每个地区特定的feeds：</p><pre class="cn literal-block" id="cn132">from django.core.exceptions import ObjectDoesNotExistfrom mysite.blog.models import Entry, Tagclass TagFeed(Feed):def get_object(self, bits):# In case of &quot;/feeds/tags/cats/dogs/mice/&quot;, or other such# clutter, check that bits has only one member.if len(bits) != 1:raise ObjectDoesNotExistreturn Tag.objects.get(tag=bits[0])def title(self, obj):return &quot;My Blog: Entries tagged with %s&quot; % obj.tagdef link(self, obj):return obj.get_absolute_url()def description(self, obj):return &quot;Entries tagged with %s&quot; % obj.tagdef items(self, obj):entries = Entry.objects.filter(tags__id__exact=obj.id)return entries.order_by('-pub_date')[:30]</pre><p class="cn" id="cn133">以下是RSS框架的基本算法，我们假设通过URL <tt class="docutils literal"><span class="pre">/rss/beats/0613/</span></tt> 来访问这个类：</p><blockquote><p class="cn" id="cn134">框架获得了URL <tt class="docutils literal"><span class="pre">/rss/beats/0613/</span></tt> 并且注意到URL中的slug部分后面含有更多的信息。 它将斜杠(<tt class="docutils literal"><span class="pre">&quot;/&quot;</span></tt> )作为分隔符，把剩余的字符串分割开作为参数，调用 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类的 <tt class="docutils literal"><span class="pre">get_object()</span></tt> 方法。</p><p class="cn" id="cn135">在这个例子中，添加的信息是 <tt class="docutils literal"><span class="pre">['0613']</span></tt> 。对于 <tt class="docutils literal"><span class="pre">/rss/beats/0613/foo/bar/</span></tt> 的一个URL请求， 这些信息就是 <tt class="docutils literal"><span class="pre">['0613',</span> <span class="pre">'foo',</span> <span class="pre">'bar']</span></tt> 。</p><p class="cn" id="cn136"><tt class="docutils literal"><span class="pre">get_object()</span></tt> 就根据给定的 <tt class="docutils literal"><span class="pre">bits</span></tt> 值来返回区域信息。</p><p class="cn" id="cn137">In this case, it uses the Django database API to retrieve the <tt class="docutils literal"><span class="pre">Tag</span></tt> . Notethat <tt class="docutils literal"><span class="pre">get_object()</span></tt> should raise <tt class="docutils literal"><span class="pre">django.core.exceptions.ObjectDoesNotExist</span></tt>if given invalid parameters. 在 <tt class="docutils literal"><span class="pre">Beat.objects.get()</span></tt> 调用中也没有出现 <tt class="docutils literal"><span class="pre">try</span></tt> /<tt class="docutils literal"><span class="pre">except</span></tt> 代码块。 函数在出错时抛出 <tt class="docutils literal"><span class="pre">Beat.DoesNotExist</span></tt> 异常，而 <tt class="docutils literal"><span class="pre">Beat.DoesNotExist</span></tt> 是 <tt class="docutils literal"><span class="pre">ObjectDoesNotExist</span></tt> 异常的一个子类型。</p><p class="cn" id="cn138">为产生 <tt class="docutils literal"><span class="pre">&lt;title&gt;</span></tt> ， <tt class="docutils literal"><span class="pre">&lt;link&gt;</span></tt> ， 和 <tt class="docutils literal"><span class="pre">&lt;description&gt;</span></tt> 的feeds， Django使用 <tt class="docutils literal"><span class="pre">title()</span></tt> , <tt class="docutils literal"><span class="pre">link()</span></tt> , 和 <tt class="docutils literal"><span class="pre">description()</span></tt> 方法。 在上面的例子中，它们都是简单的字符串类型的类属性，而这个例子表明，它们既可以是字符串， <em>也可以是</em> 方法。 对于每一个 <tt class="docutils literal"><span class="pre">title</span></tt> ， <tt class="docutils literal"><span class="pre">link</span></tt> 和 <tt class="docutils literal"><span class="pre">description</span></tt> 的组合，Django使用以下的算法：</p><ol class="arabic simple"><li class="cn" id="cn139"><p class="first cn" id="cn139">试图调用一个函数，并且以 <tt class="docutils literal"><span class="pre">get_object()</span></tt> 返回的对象作为参数传递给 <tt class="docutils literal"><span class="pre">obj</span></tt> 参数。</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn140"><p class="first cn" id="cn140">如果没有成功，则不带参数调用一个方法。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn141"><p class="first cn" id="cn141">还不成功，则使用类属性。</p></li></ol><p class="cn" id="cn142">最后，值得注意的是，这个例子中的 <tt class="docutils literal"><span class="pre">items()</span></tt> 使用 <tt class="docutils literal"><span class="pre">obj</span></tt> 参数。对于 <tt class="docutils literal"><span class="pre">items</span></tt> 的算法就如同上面第一步所描述的那样，首先尝试 <tt class="docutils literal"><span class="pre">items(obj)</span></tt> ， 然后是 <tt class="docutils literal"><span class="pre">items()</span></tt> ，最后是 <tt class="docutils literal"><span class="pre">items</span></tt> 类属性（必须是一个列表）。</p></blockquote><p class="cn" id="cn143"><tt class="docutils literal"><span class="pre">Feed</span></tt> 类所有方法和属性的完整文档，请参考官方的Django文档 (<a class="reference external" href="http://www.djangoproject.com/documentation/0.96/syndication_feeds/">http://www.djangoproject.com/documentation/0.96/syndication_feeds/</a>) 。</p></div><div class="section" id="id7"><span id="cn144"></span><h3 class="cn" id="cn144">指定Feed的类型</h3><p class="cn" id="cn145">默认情况下, 聚合框架生成RSS 2.0. 要改变这样的情况, 在 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类中添加一个 <tt class="docutils literal"><span class="pre">feed_type</span></tt> 属性. To change that, add a<tt class="docutils literal"><span class="pre">feed_type</span></tt> attribute to your <tt class="docutils literal"><span class="pre">Feed</span></tt> class:</p><pre class="cn literal-block" id="cn147">from django.utils.feedgenerator import Atom1Feedclass MyFeed(Feed):feed_type = Atom1Feed</pre><p class="cn" id="cn148">注意你把 <tt class="docutils literal"><span class="pre">feed_type</span></tt> 赋值成一个类对象，而不是类实例。 目前合法的Feed类型如表11-1所示。</p><table class="cn docutils" id="cn149"><caption>表 11-1.  Feed 类型</caption><colgroup><col width="73%" /><col width="27%" /></colgroup><thead valign="bottom"><tr><th class="head">Feed 类</th><th class="head">类型</th></tr></thead><tbody valign="top"><tr><td><tt class="docutils literal"><span class="pre">django.utils.feedgenerator.Rss201rev2Feed</span></tt></td><td>RSS 2.01 (default)</td></tr><tr><td><tt class="docutils literal"><span class="pre">django.utils.feedgenerator.RssUserland091Feed</span></tt></td><td>RSS 0.91</td></tr><tr><td><tt class="docutils literal"><span class="pre">django.utils.feedgenerator.Atom1Feed</span></tt></td><td>Atom 1.0</td></tr></tbody></table></div><div class="section" id="id8"><span id="cn150"></span><h3 class="cn" id="cn150">闭包</h3><p class="cn" id="cn151">为了指定闭包（例如，与feed项比方说MP3 feeds相关联的媒体资源信息），使用 <tt class="docutils literal"><span class="pre">item_enclosure_url</span></tt> ， <tt class="docutils literal"><span class="pre">item_enclosure_length</span></tt> ， 以及 <tt class="docutils literal"><span class="pre">item_enclosure_mime_type</span></tt> ，比如</p><pre class="cn literal-block" id="cn153">from myproject.models import Songclass MyFeedWithEnclosures(Feed):title = &quot;Example feed with enclosures&quot;link = &quot;/feeds/example-with-enclosures/&quot;def items(self):return Song.objects.all()[:30]def item_enclosure_url(self, item):return item.song_urldef item_enclosure_length(self, item):return item.song_lengthitem_enclosure_mime_type = &quot;audio/mpeg&quot;</pre><p class="cn" id="cn154">当然，你首先要创建一个包含有 <tt class="docutils literal"><span class="pre">song_url</span></tt> 和 <tt class="docutils literal"><span class="pre">song_length</span></tt> （比如按照字节计算的长度）域的 <tt class="docutils literal"><span class="pre">Song</span></tt> 对象。</p></div><div class="section" id="id9"><span id="cn155"></span><h3 class="cn" id="cn155">语言</h3><p class="cn" id="cn156">聚合框架自动创建的Feed包含适当的 <tt class="docutils literal"><span class="pre">&lt;language&gt;</span></tt> 标签(RSS 2.0) 或 <tt class="docutils literal"><span class="pre">xml:lang</span></tt> 属性(Atom). 他直接来自于您的 <tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt> 设置. This comes directlyfrom your <tt class="docutils literal"><span class="pre">LANGUAGE_CODE</span></tt> setting.</p></div><div class="section" id="urls"><span id="cn157"></span><h3 class="cn" id="cn157">URLs</h3><p class="cn" id="cn158"><tt class="docutils literal"><span class="pre">link</span></tt> 方法/属性可以以绝对URL的形式（例如， <tt class="docutils literal"><span class="pre">&quot;/blog/&quot;</span></tt> ）或者指定协议和域名的URL的形式返回（例如 <tt class="docutils literal"><span class="pre">&quot;http://www.example.com/blog/&quot;</span></tt> ）。如果 <tt class="docutils literal"><span class="pre">link</span></tt> 没有返回域名，聚合框架会根据 <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> 设置，自动的插入当前站点的域信息。 (See Chapter 16 for more on <tt class="docutils literal"><span class="pre">SITE_ID</span></tt> and the sitesframework.)</p><p class="cn" id="cn159">Atom feeds需要 <tt class="docutils literal"><span class="pre">&lt;link</span> <span class="pre">rel=&quot;self&quot;&gt;</span></tt> 指明feeds现在的位置。The syndication framework populates this automatically.</p></div><div class="section" id="atom-and-rss"><span id="cn160"></span><h3 class="cn" id="cn160">同时发布Atom and RSS</h3><p class="cn" id="cn161">一些开发人员想 <em>同时</em> 支持Atom和RSS。这在Django中很容易实现： 只需创建一个你的 <tt class="docutils literal"><span class="pre">feed</span></tt> 类的子类，然后修改 <tt class="docutils literal"><span class="pre">feed_type</span></tt> ，并且更新URLconf内容。 下面是一个完整的例子： Here&#8217;s a full example:</p><pre class="cn literal-block" id="cn163">from django.contrib.syndication.feeds import Feedfrom django.utils.feedgenerator import Atom1Feedfrom mysite.blog.models import Entryclass RssLatestEntries(Feed):title = &quot;My Blog&quot;link = &quot;/archive/&quot;description = &quot;The latest news about stuff.&quot;def items(self):return Entry.objects.order_by('-pub_date')[:5]class AtomLatestEntries(RssLatestEntries):feed_type = Atom1Feed</pre><p class="cn" id="cn164">这是与之相对应那个的URLconf：</p><pre class="cn literal-block" id="cn166">from django.conf.urls.defaults import *from myproject.feeds import RssLatestEntries, AtomLatestEntriesfeeds = {'rss': RssLatestEntries,'atom': AtomLatestEntries,}urlpatterns = patterns('',# ...(r'^feeds/(?P&lt;url&gt;.*)/$', 'django.contrib.syndication.views.feed',{'feed_dict': feeds}),# ...)</pre></div></div><div class="section" id="sitemap"><span id="cn167"></span><h2 class="cn" id="cn167">Sitemap 框架</h2><p class="cn" id="cn168"><em>sitemap</em> 是你服务器上的一个XML文件，它告诉搜索引擎你的页面的更新频率和某些页面相对于其它页面的重要性。 这个信息会帮助搜索引擎索引你的网站。</p><p class="cn" id="cn169">例如，这是 Django 网站(<a class="reference external" href="http://www.djangoproject.com/sitemap.xml">http://www.djangoproject.com/sitemap.xml</a>)sitemap的一部分：</p><pre class="cn literal-block" id="cn171">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;&lt;url&gt;&lt;loc&gt;http://www.djangoproject.com/documentation/&lt;/loc&gt;&lt;changefreq&gt;weekly&lt;/changefreq&gt;&lt;priority&gt;0.5&lt;/priority&gt;&lt;/url&gt;&lt;url&gt;&lt;loc&gt;http://www.djangoproject.com/documentation/0_90/&lt;/loc&gt;&lt;changefreq&gt;never&lt;/changefreq&gt;&lt;priority&gt;0.1&lt;/priority&gt;&lt;/url&gt;...&lt;/urlset&gt;</pre><p class="cn" id="cn172">需要了解更多有关 sitemaps 的信息, 请参见 <a class="reference external" href="http://www.sitemaps.org/">http://www.sitemaps.org/</a>.</p><p class="cn" id="cn173">Django sitemap 框架允许你用 Python 代码来表述这些信息，从而自动创建这个XML文件。 要创建一个站点地图，你只需要写一个`` Sitemap`` 类，并且在URLconf中指向它。</p><div class="section" id="id10"><span id="cn174"></span><h3 class="cn" id="cn174">安装</h3><p class="cn" id="cn175">要安装 sitemap 应用程序, 按下面的步骤进行:</p><ol class="arabic simple"><li class="cn" id="cn176"><p class="first cn" id="cn176">将 <tt class="docutils literal"><span class="pre">'django.contrib.sitemaps'</span></tt> 添加到您的 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 设置中.</p></li></ol><ol class="arabic simple" start="2"><li class="cn" id="cn177"><p class="first cn" id="cn177">确保 <tt class="docutils literal"><span class="pre">'django.template.loaders.app_directories.load_template_source'</span></tt> 在您的 <tt class="docutils literal"><span class="pre">TEMPLATE_LOADERS</span></tt> 设置中。 默认情况下它在那里, 所以, 如果你已经改变了那个设置的话, 只需要改回来即可。</p></li></ol><ol class="arabic simple" start="3"><li class="cn" id="cn178"><p class="first cn" id="cn178">确定您已经安装了 sites 框架 (参见第14章).</p></li></ol><p class="cn" id="cn179">Note</p><p class="cn" id="cn180">sitemap 应用程序没有安装任何数据库表. 它需要加入到 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中的唯一原因是: 这样 <tt class="docutils literal"><span class="pre">load_template_source</span></tt> 模板加载器可以找到默认的模板. The only reason itneeds to go into <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> is so the <tt class="docutils literal"><span class="pre">load_template_source</span></tt> templateloader can find the default templates.</p></div><div class="section" id="initialization"><span id="cn181"></span><h3 class="cn" id="cn181">Initialization</h3><p class="cn" id="cn182">要在您的Django站点中激活sitemap生成, 请在您的 URLconf 中添加这一行:</p><pre class="cn literal-block" id="cn184">(r'^sitemap\.xml$', 'django.contrib.sitemaps.views.sitemap', {'sitemaps': sitemaps})</pre><p class="cn" id="cn185">This line tells Django to build a sitemap when a client accesses <tt class="docutils literal"><span class="pre">/sitemap.xml</span></tt> .Note that the dot character in <tt class="docutils literal"><span class="pre">sitemap.xml</span></tt> is escaped with a backslash, becausedots have a special meaning in regular expressions.</p><p class="cn" id="cn186">sitemap文件的名字无关紧要，但是它在服务器上的位置却很重要。 搜索引擎只索引你的sitemap中当前URL级别及其以下级别的链接。 用一个实例来说，如果 <tt class="docutils literal"><span class="pre">sitemap.xml</span></tt> 位于你的根目录，那么它将引用任何的URL。 然而，如果你的sitemap位于 <tt class="docutils literal"><span class="pre">/content/sitemap.xml</span></tt> ，那么它只引用以 <tt class="docutils literal"><span class="pre">/content/</span></tt> 打头的URL。</p><p class="cn" id="cn187">sitemap视图需要一个额外的必须的参数： <tt class="docutils literal"><span class="pre">{'sitemaps':</span> <span class="pre">sitemaps}</span></tt> .<tt class="docutils literal"><span class="pre">sitemaps</span></tt> should be a dictionary that maps a short section label (e.g., <tt class="docutils literal"><span class="pre">blog</span></tt>or <tt class="docutils literal"><span class="pre">news</span></tt> ) to its <tt class="docutils literal"><span class="pre">Sitemap</span></tt> class (e.g., <tt class="docutils literal"><span class="pre">BlogSitemap</span></tt> or <tt class="docutils literal"><span class="pre">NewsSitemap</span></tt> ).It may also map to an <em>instance</em> of a <tt class="docutils literal"><span class="pre">Sitemap</span></tt> class (e.g.,<tt class="docutils literal"><span class="pre">BlogSitemap(some_var)</span></tt> ).</p></div><div class="section" id="id11"><span id="cn188"></span><h3 class="cn" id="cn188">Sitemap 类</h3><p class="cn" id="cn189"><tt class="docutils literal"><span class="pre">Sitemap</span></tt> 类展示了一个进入地图站点简单的Python类片断.例如,一个 <tt class="docutils literal"><span class="pre">Sitemap</span></tt> 类能展现所有日志入口，而另外一个能够调度所有的日历事件。 For example, one <tt class="docutils literal"><span class="pre">Sitemap</span></tt> class could represent all the entries ofyour weblog, while another could represent all of the events in your eventscalendar.</p><p class="cn" id="cn190">在最简单的例子中，所有部分可以全部包含在一个 <tt class="docutils literal"><span class="pre">sitemap.xml</span></tt> 中，也可以使用框架来产生一个站点地图，为每一个独立的部分产生一个单独的站点文件。</p><p class="cn" id="cn191"><tt class="docutils literal"><span class="pre">Sitemap</span></tt> 类必须是 <tt class="docutils literal"><span class="pre">django.contrib.sitemaps.Sitemap</span></tt> 的子类. 他们可以存在于您的代码树的任何地方。</p><p class="cn" id="cn192">例如假设你有一个blog系统，有一个 <tt class="docutils literal"><span class="pre">Entry</span></tt> 的model，并且你希望你的站点地图包含所有连到你的blog入口的超链接。 你的 <tt class="docutils literal"><span class="pre">Sitemap</span></tt> 类很可能是这样的：</p><pre class="cn literal-block" id="cn194">from django.contrib.sitemaps import Sitemapfrom mysite.blog.models import Entryclass BlogSitemap(Sitemap):changefreq = &quot;never&quot;priority = 0.5def items(self):return Entry.objects.filter(is_draft=False)def lastmod(self, obj):return obj.pub_date</pre><p class="cn" id="cn195">声明一个 <tt class="docutils literal"><span class="pre">Sitemap</span></tt> 和声明一个 <tt class="docutils literal"><span class="pre">Feed</span></tt> 看起来很类似；这都是预先设计好的。</p><p class="cn" id="cn196">如同 <tt class="docutils literal"><span class="pre">Feed</span></tt> 类一样， <tt class="docutils literal"><span class="pre">Sitemap</span></tt> 成员也既可以是方法，也可以是属性。 想要知道更详细的内容，请参见上文 《一个复杂的例子》章节。</p><p class="cn" id="cn197">一个 <tt class="docutils literal"><span class="pre">Sitemap</span></tt> 类可以定义如下 方法/属性:</p><blockquote><p class="cn" id="cn198"><tt class="docutils literal"><span class="pre">items</span></tt> (<strong>必需</strong> )：提供对象列表。 框架并不关心对象的 <em>类型</em> ；唯一关心的是这些对象会传递给 <tt class="docutils literal"><span class="pre">location()</span></tt> ， <tt class="docutils literal"><span class="pre">lastmod()</span></tt> ， <tt class="docutils literal"><span class="pre">changefreq()</span></tt> ，和 <tt class="docutils literal"><span class="pre">priority()</span></tt> 方法。</p><p class="cn" id="cn199"><tt class="docutils literal"><span class="pre">location</span></tt> （可选）： 给定对象的绝对URL。 绝对URL不包含协议名称和域名。 下面是一些例子：</p><ul class="simple"><li class="cn" id="cn200"><p class="first cn" id="cn200">好的: <tt class="docutils literal"><span class="pre">'/foo/bar/'</span></tt> <tt class="docutils literal"><span class="pre">'/foo/bar/'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn201"><p class="first cn" id="cn201">差的: <tt class="docutils literal"><span class="pre">'example.com/foo/bar/'</span></tt> <tt class="docutils literal"><span class="pre">'example.com/foo/bar/'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn202"><p class="first cn" id="cn202">Bad: <tt class="docutils literal"><span class="pre">'http://example.com/foo/bar/'</span></tt></p></li></ul><p class="cn" id="cn203">如果没有提供 <tt class="docutils literal"><span class="pre">location</span></tt> , 框架将会在每个 <tt class="docutils literal"><span class="pre">items()</span></tt> 返回的对象上调用 <tt class="docutils literal"><span class="pre">get_absolute_url()</span></tt> 方法.</p><p class="cn" id="cn204"><tt class="docutils literal"><span class="pre">lastmod</span></tt> (可选): 对象的最后修改日期, 作为一个Python <tt class="docutils literal"><span class="pre">datetime</span></tt> 对象. The object&#8217;s last modification date, as a Python<tt class="docutils literal"><span class="pre">datetime</span></tt> object.</p><p class="cn" id="cn205"><tt class="docutils literal"><span class="pre">changefreq</span></tt> （可选）： 对象变更的频率。 可选的值如下（详见Sitemaps文档）：</p><ul class="simple"><li class="cn" id="cn206"><p class="first cn" id="cn206"><tt class="docutils literal"><span class="pre">'always'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn207"><p class="first cn" id="cn207"><tt class="docutils literal"><span class="pre">'hourly'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn208"><p class="first cn" id="cn208"><tt class="docutils literal"><span class="pre">'daily'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn209"><p class="first cn" id="cn209"><tt class="docutils literal"><span class="pre">'weekly'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn210"><p class="first cn" id="cn210"><tt class="docutils literal"><span class="pre">'monthly'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn211"><p class="first cn" id="cn211"><tt class="docutils literal"><span class="pre">'yearly'</span></tt></p></li></ul><ul class="simple"><li class="cn" id="cn212"><p class="first cn" id="cn212"><tt class="docutils literal"><span class="pre">'never'</span></tt></p></li></ul><p class="cn" id="cn213"><tt class="docutils literal"><span class="pre">priority</span></tt> （可选）： 取值范围在 <tt class="docutils literal"><span class="pre">0.0</span></tt> and <tt class="docutils literal"><span class="pre">1.0</span></tt> 之间，用来表明优先级。</p></blockquote></div><div class="section" id="id12"><span id="cn214"></span><h3 class="cn" id="cn214">快捷方式</h3><p class="cn" id="cn215">sitemap框架提供了一些常用的类。 在下一部分中会看到。</p><div class="section" id="flatpagesitemap"><span id="cn216"></span><h4 class="cn" id="cn216">FlatPageSitemap</h4><p class="cn" id="cn217"><tt class="docutils literal"><span class="pre">django.contrib.sitemaps.FlatPageSitemap</span></tt> 类涉及到站点中所有的flat page，并在sitemap中建立一个入口。 但仅仅只包含 <tt class="docutils literal"><span class="pre">location</span></tt> 属性，不支持 <tt class="docutils literal"><span class="pre">lastmod</span></tt> ， <tt class="docutils literal"><span class="pre">changefreq</span></tt> ，或者 <tt class="docutils literal"><span class="pre">priority</span></tt> 。</p><p class="cn" id="cn218">参见第16章获取有关flat page的更多的内容.</p></div><div class="section" id="genericsitemap"><span id="cn219"></span><h4 class="cn" id="cn219">GenericSitemap</h4><p class="cn" id="cn220"><tt class="docutils literal"><span class="pre">GenericSitemap</span></tt> 与所有的通用视图一同工作（详见第9章）。</p><p class="cn" id="cn221">你可以如下使用它，创建一个实例，并通过 <tt class="docutils literal"><span class="pre">info_dict</span></tt> 传递给通用视图。 唯一的要求是字典包含 <tt class="docutils literal"><span class="pre">queryset</span></tt> 这一项。 也可以用 <tt class="docutils literal"><span class="pre">date_field</span></tt> 来指明从 <tt class="docutils literal"><span class="pre">queryset</span></tt> 中取回的对象的日期域。 这会被用作站点地图中的 <tt class="docutils literal"><span class="pre">lastmod</span></tt> 属性。</p><p class="cn" id="cn222">下面是一个使用 <tt class="docutils literal"><span class="pre">FlatPageSitemap</span></tt> and <tt class="docutils literal"><span class="pre">GenericSiteMap</span></tt> （包括前面所假定的 <tt class="docutils literal"><span class="pre">Entry</span></tt> 对象）的URLconf：</p><pre class="cn literal-block" id="cn224">from django.conf.urls.defaults import *from django.contrib.sitemaps import FlatPageSitemap, GenericSitemapfrom mysite.blog.models import Entryinfo_dict = {'queryset': Entry.objects.all(),'date_field': 'pub_date',}sitemaps = {'flatpages': FlatPageSitemap,'blog': GenericSitemap(info_dict, priority=0.6),}urlpatterns = patterns('',# some generic view using info_dict# ...# the sitemap(r'^sitemap\.xml$','django.contrib.sitemaps.views.sitemap',{'sitemaps': sitemaps}))</pre></div></div><div class="section" id="id13"><span id="cn225"></span><h3 class="cn" id="cn225">创建一个Sitemap索引</h3><p class="cn" id="cn226">sitemap框架同样可以根据 <tt class="docutils literal"><span class="pre">sitemaps</span></tt> 字典中定义的单独的sitemap文件来建立索引。 用法区别如下：</p><ul class="simple"><li class="cn" id="cn227"><p class="first cn" id="cn227">您在您的URLconf 中使用了两个视图: <tt class="docutils literal"><span class="pre">django.contrib.sitemaps.views.index</span></tt> 和 <tt class="docutils literal"><span class="pre">django.contrib.sitemaps.views.sitemap</span></tt> . `` django.contrib.sitemaps.views.index`` 和`` django.contrib.sitemaps.views.sitemap``</p></li></ul><ul class="simple"><li class="cn" id="cn228"><p class="first cn" id="cn228"><tt class="docutils literal"><span class="pre">django.contrib.sitemaps.views.sitemap</span></tt> 视图需要带一个 <tt class="docutils literal"><span class="pre">section</span></tt> 关键字参数.</p></li></ul><p class="cn" id="cn229">这里是前面的例子的相关的 URLconf 行看起来的样子:</p><pre class="cn literal-block" id="cn231">(r'^sitemap.xml$','django.contrib.sitemaps.views.index',{'sitemaps': sitemaps}),(r'^sitemap-(?P&lt;section&gt;.+).xml$','django.contrib.sitemaps.views.sitemap',{'sitemaps': sitemaps})</pre><p class="cn" id="cn232">这将自动生成一个 <tt class="docutils literal"><span class="pre">sitemap.xml</span></tt> 文件, 它同时引用 <tt class="docutils literal"><span class="pre">sitemap-flatpages.xml</span></tt> 和 <tt class="docutils literal"><span class="pre">sitemap-blog.xml</span></tt> . <tt class="docutils literal"><span class="pre">Sitemap</span></tt> 类和 <tt class="docutils literal"><span class="pre">sitemaps</span></tt> 目录根本没有更改.</p></div><div class="section" id="google"><span id="cn233"></span><h3 class="cn" id="cn233">通知Google</h3><p class="cn" id="cn234">当你的sitemap变化的时候，你会想通知Google，以便让它知道对你的站点进行重新索引。 框架就提供了这样的一个函数：<tt class="docutils literal"><span class="pre">django.contrib.sitemaps.ping_google()</span></tt> 。</p><p class="cn" id="cn235"><tt class="docutils literal"><span class="pre">ping_google()</span></tt> 有一个可选的参数 <tt class="docutils literal"><span class="pre">sitemap_url</span></tt> ，它应该是你的站点地图的URL绝对地址（例如：</p><p class="cn" id="cn236">如果不能够确定你的sitemap URL, <tt class="docutils literal"><span class="pre">ping_google()</span></tt> 会引发 <tt class="docutils literal"><span class="pre">django.contrib.sitemaps.SitemapNotFound</span></tt> 异常。</p><p class="cn" id="cn237">我们可以通过模型中的 <tt class="docutils literal"><span class="pre">save()</span></tt> 方法来调用 <tt class="docutils literal"><span class="pre">ping_google()</span></tt> ：</p><pre class="cn literal-block" id="cn239">from django.contrib.sitemaps import ping_googleclass Entry(models.Model):# ...def save(self, *args, **kwargs):super(Entry, self).save(*args, **kwargs)try:ping_google()except Exception:# Bare 'except' because we could get a variety# of HTTP-related exceptions.pass</pre><p class="cn" id="cn240">一个更有效的解决方案是用 <tt class="docutils literal"><span class="pre">cron</span></tt> 脚本或任务调度表来调用 <tt class="docutils literal"><span class="pre">ping_google()</span></tt> ，该方法使用Http直接请求Google服务器，从而减少每次调用 <tt class="docutils literal"><span class="pre">save()</span></tt> 时占用的网络带宽。 The function makes an HTTP request toGoogle&#8217;s servers, so you may not want to introduce that network overhead each timeyou call <tt class="docutils literal"><span class="pre">save()</span></tt> .</p><p class="cn" id="cn241">Finally, if <tt class="docutils literal"><span class="pre">'django.contrib.sitemaps'</span></tt> is in your <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> , then your<tt class="docutils literal"><span class="pre">manage.py</span></tt> will include a new command, <tt class="docutils literal"><span class="pre">ping_google</span></tt> . This is useful forcommand-line access to pinging. For example:</p><pre class="cn literal-block" id="cn243">python manage.py ping_google /sitemap.xml</pre></div></div><div class="section" id="id14"><span id="cn244"></span><h2 class="cn" id="cn244">下一章</h2><p class="cn" id="cn245">下面, 我们要继续深入挖掘所有的Django给你的很好的内置工具。` 第十四章 &lt;chapter14.html&gt;`__ 查看创建用户自定义站点需要的工具sessions, users 和authentication.</p></div></div></div></div></div></div><div id="ft"><div class="nav"><a href="chapter12.html">| 上一章</a> |<a href="index.html">目  录</a> |<a href="chapter14.html">下一章 </a> |</div></div></div><div style="visibility: hidden; opacity: 0.3; width: 730px;" id="highlight-floater"></div><!-- comment dialog --><div style="display: none; width: 498px; height: 398px;" id="djangobookcomments" class="yresizable-pinned"><div class="hd" id="djangobookcomments-head">Comments <span class="close" onclick="Comments.close();">X</span></div><div class="bd"><div id="comment-tabs"><!-- comment form --><div style="display: block;" id="comment-tabs-form" class="tab yui-ext-tabitembody"><form action="comments/" method="post" id="commentform"><p><input name="nodenum" value="" type="hidden"><label for="id_name">姓名 (必填)</label><input name="name" id="id_name" value="" tabindex="1" type="text"></p><p><label for="id_email">E-mail (必填; 不会显示)</label><input name="email" id="id_email" value="" tabindex="2" type="text"></p><p><label for="id_url">网站</label><input name="url" id="id_url" value="" tabindex="3" type="text"></p><p><label for="id_comment">评注</label><textarea style="width: 466px; height: 116px;" name="comment" id="id_comment" tabindex="4" cols="40" rows="15"></textarea></p></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="comment-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-comments-list"></ol></div><!-- all comments tab: also dynamic --><div style="display: none;" id="comment-tabs-all" class="tab yui-ext-tabitembody"><ol id="all-comments-list"></ol></div><!-- help --><div style="display: none;" id="comment-tabs-help" class="tab yui-ext-tabitembody"><h4>关于本评注系统</h4><p>本站使用上下文关联的评注系统来收集反馈信息。不同于一般对整章做评注的做法，我们允许你对每一个独立的“文本块”做评注。一个“文本块”看起来是这样的：</p><p class="image"><img src="sitemedia/comments1.png" height="100" width="350"></p><p>一个“文本块”是一个段落，一个列表项，一段代码，或者其他一小段内容。你选中它会高亮度显示:</p><p class="image"><img src="sitemedia/comments2.png" height="100" width="350"></p><p>要对文本块做评注，你只需要点击它旁边的标识块:</p><p class="image"><img src="sitemedia/comments3.png" height="100" width="350"></p><p>我们会仔细阅读每个评论，如果可能的话我们也会把评注考虑到未来的版本中去:</p><p>如果你愿意你的评注被采用，请确保留下你的全名 (注意不是昵称或简称）</p><p class="image"><img src="sitemedia/comments4.png" height="100" width="350"></p><p>Many, many thanks to <a href="http://www.jackslocum.com/yui/">Jack Slocum</a>;the inspiration and much of the code for the comment system comes from Jack'sblog, and this site couldn't have been built without his wonderful<code>YAHOO.ext</code> library.  Thanks also to Yahoo for YUI itself.</p></div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobookcomments-message"></div><div id="comments-submit-wrapper"><input style="visibility: visible;" id="comment-submit" value="提交" onclick="Comments.submitComment();" type="button"><input id="comment-close" value="关闭" onclick="Comments.close();" type="button"></div></div></div><!-- translation dialog --><div style="display: none; width: 550px; height: 440px;" id="djangobooktranslations" class="yresizable-pinned"><div class="hd" id="djangobooktranslations-head">Translations <span class="close" onclick="Translations.close();">X</span></div><div class="bd"><div id="translation-tabs"><!-- comment form --><div style="display: block;" id="translation-tabs-form" class="tab yui-ext-tabitembody"><form action="translations/" method="post" id="translationform"></form></div><!-- comments on this node tab: filled in dynamically --><div style="display: none;" id="translation-tabs-current" class="tab yui-ext-tabitembody"><ol id="current-translations-list"></ol></div><!-- settings --><div style="display: none;" id="translation-tabs-settings" class="tab yui-ext-tabitembody"></div><!-- help --><div style="display: none;" id="translation-tabs-help" class="tab yui-ext-tabitembody">帮助</div></div></div><div class="ft"><div style="visibility: hidden;" class="" id="djangobooktranslations-message">Loading .....</div><div id="translations-submit-wrapper"><input style="visibility: visible;" id="translation-prev" value="上一段" onclick="Translations.prev();" type="button"><input style="visibility: visible;" id="translation-next" value="下一段" onclick="Translations.next();" type="button"><input style="visibility: visible;" id="translation-submit-next" value="提交&下一段" onclick="Translations.submitNext();" type="button"><input style="visibility: visible;" id="translation-submit" value="提交" onclick="Translations.submitTranslation();" type="button"><input id="translation-close" value="关闭" onclick="Translations.close();" type="button"></div></div></div> <!-- end translation dialog --><div id="ft">Copyright 2006 Adrian Holovaty and Jacob Kaplan-Moss.<br>Thiswork is licensed under the <a href="http://new.djangobook.com/license/">GNU Free DocumentLicense</a>.<br/>Hosting graciously provided by <a href="http://mediatemple.net/"><img style="vertical-align: middle; position: relative; top: -1px;" src="sitemedia/mt.png" alt="media temple"></a><br/>Chinese translate hosting by <a href="mailto:info@py3k.cn">py3k.cn</a>.</div><div class="ends"><div><script type="text/javascript" src="sitemedia/v2/css/djangobook.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">var pageTracker = _gat._getTracker("UA-794487-4");pageTracker._initData();pageTracker._trackPageview();</script></body></html>