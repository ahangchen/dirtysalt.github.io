<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>leveldb</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="dirtysalt" />
<link rel="shortcut icon" href="http://dirtysalt.info/css/favicon.ico" />
<link rel="stylesheet" type="text/css" href="./css/site.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">leveldb</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. Introduction</a></li>
<li><a href="#orgheadline2">2. WriteBatch</a></li>
<li><a href="#orgheadline6">3. BloomFilter</a>
<ul>
<li><a href="#orgheadline3">3.1. Format</a></li>
<li><a href="#orgheadline4">3.2. FilterBlockBuilder</a></li>
<li><a href="#orgheadline5">3.3. FilterBlockReader</a></li>
</ul>
</li>
<li><a href="#orgheadline10">4. Storage</a>
<ul>
<li><a href="#orgheadline7">4.1. MemTable</a></li>
<li><a href="#orgheadline8">4.2. RedoLog</a></li>
<li><a href="#orgheadline9">4.3. DiskTable</a></li>
</ul>
</li>
<li><a href="#orgheadline11">5. Compaction</a></li>
<li><a href="#orgheadline12">6. Recovery</a></li>
<li><a href="#orgheadline13">7. Snapshot</a></li>
<li><a href="#orgheadline14">8. Cache</a></li>
<li><a href="#orgheadline15">9. Option</a></li>
<li><a href="#orgheadline318">10. ReadingCode</a>
<ul>
<li><a href="#orgheadline37">10.1. Interface</a>
<ul>
<li><a href="#orgheadline16">10.1.1. cache.h</a></li>
<li><a href="#orgheadline17">10.1.2. comparator.h</a></li>
<li><a href="#orgheadline18">10.1.3. db.h</a></li>
<li><a href="#orgheadline25">10.1.4. env.h</a></li>
<li><a href="#orgheadline26">10.1.5. filter_policy.h</a></li>
<li><a href="#orgheadline27">10.1.6. iterator.h</a></li>
<li><a href="#orgheadline31">10.1.7. options.h</a></li>
<li><a href="#orgheadline32">10.1.8. slice.h</a></li>
<li><a href="#orgheadline33">10.1.9. status.h</a></li>
<li><a href="#orgheadline34">10.1.10. table_builder.h</a></li>
<li><a href="#orgheadline35">10.1.11. table.h</a></li>
<li><a href="#orgheadline36">10.1.12. write_batch.h</a></li>
</ul>
</li>
<li><a href="#orgheadline38">10.2. Implementation</a></li>
<li><a href="#orgheadline164">10.3. DB</a>
<ul>
<li><a href="#orgheadline39">10.3.1. FileName</a></li>
<li><a href="#orgheadline40">10.3.2. Config</a></li>
<li><a href="#orgheadline74">10.3.3. DBImpl</a></li>
<li><a href="#orgheadline87">10.3.4. DBIter</a></li>
<li><a href="#orgheadline88">10.3.5. LookupKey</a></li>
<li><a href="#orgheadline89">10.3.6. ValueType</a></li>
<li><a href="#orgheadline90">10.3.7. SequenceNumber</a></li>
<li><a href="#orgheadline98">10.3.8. InternalKey</a></li>
<li><a href="#orgheadline102">10.3.9. InternalKeyComparator</a></li>
<li><a href="#orgheadline103">10.3.10. FileMetaData</a></li>
<li><a href="#orgheadline121">10.3.11. Version</a></li>
<li><a href="#orgheadline142">10.3.12. VersionSet</a></li>
<li><a href="#orgheadline147">10.3.13. VersionSetBuilder</a></li>
<li><a href="#orgheadline156">10.3.14. Compaction</a></li>
<li><a href="#orgheadline157">10.3.15. CompactionState</a></li>
<li><a href="#orgheadline161">10.3.16. VersionEdit</a></li>
<li><a href="#orgheadline162">10.3.17. ByteWiseComparatorImpl</a></li>
<li><a href="#orgheadline163">10.3.18. SnapshotImpl</a></li>
</ul>
</li>
<li><a href="#orgheadline179">10.4. Posix</a>
<ul>
<li><a href="#orgheadline169">10.4.1. PosixEnv</a></li>
<li><a href="#orgheadline170">10.4.2. PosixFileLock</a></li>
<li><a href="#orgheadline171">10.4.3. PosixLogger</a></li>
<li><a href="#orgheadline172">10.4.4. PosixRandomAccessFile</a></li>
<li><a href="#orgheadline173">10.4.5. PosixSequentialFile</a></li>
<li><a href="#orgheadline178">10.4.6. PosixMmapFile</a></li>
</ul>
</li>
<li><a href="#orgheadline188">10.5. Cache</a>
<ul>
<li><a href="#orgheadline180">10.5.1. ShardedLRUCache</a></li>
<li><a href="#orgheadline185">10.5.2. LRUCache</a></li>
<li><a href="#orgheadline186">10.5.3. LRUHandle</a></li>
<li><a href="#orgheadline187">10.5.4. HandleTable</a></li>
</ul>
</li>
<li><a href="#orgheadline205">10.6. Batch</a>
<ul>
<li><a href="#orgheadline197">10.6.1. WriteBatch</a></li>
<li><a href="#orgheadline202">10.6.2. MemTable</a></li>
<li><a href="#orgheadline203">10.6.3. MemTableInserter</a></li>
<li><a href="#orgheadline204">10.6.4. MemtableIterator</a></li>
</ul>
</li>
<li><a href="#orgheadline219">10.7. Log</a>
<ul>
<li><a href="#orgheadline206">10.7.1. LogFormat</a></li>
<li><a href="#orgheadline210">10.7.2. LogWriter</a></li>
<li><a href="#orgheadline218">10.7.3. LogReader</a></li>
</ul>
</li>
<li><a href="#orgheadline298">10.8. Table</a>
<ul>
<li><a href="#orgheadline220">10.8.1. TableFormat</a></li>
<li><a href="#orgheadline221">10.8.2. BuildTable</a></li>
<li><a href="#orgheadline225">10.8.3. TableCache</a></li>
<li><a href="#orgheadline234">10.8.4. Table</a></li>
<li><a href="#orgheadline242">10.8.5. TableBuilder</a></li>
<li><a href="#orgheadline249">10.8.6. BlockBuilder</a></li>
<li><a href="#orgheadline253">10.8.7. Block</a></li>
<li><a href="#orgheadline265">10.8.8. BlockIterator</a></li>
<li><a href="#orgheadline268">10.8.9. BlockHandle</a></li>
<li><a href="#orgheadline271">10.8.10. Footer</a></li>
<li><a href="#orgheadline272">10.8.11. ReadBlock</a></li>
<li><a href="#orgheadline273">10.8.12. IteratorWrapper</a></li>
<li><a href="#orgheadline274">10.8.13. EmptyIterator</a></li>
<li><a href="#orgheadline285">10.8.14. TwoLevelIterator</a></li>
<li><a href="#orgheadline297">10.8.15. MergingIterator</a></li>
</ul>
</li>
<li><a href="#orgheadline317">10.9. Util</a>
<ul>
<li><a href="#orgheadline299">10.9.1. Arena</a></li>
<li><a href="#orgheadline300">10.9.2. Coding</a></li>
<li><a href="#orgheadline301">10.9.3. Histogram</a></li>
<li><a href="#orgheadline312">10.9.4. SkipList</a></li>
<li><a href="#orgheadline313">10.9.5. AtomicPointer</a></li>
<li><a href="#orgheadline314">10.9.6. CRC32C</a></li>
<li><a href="#orgheadline315">10.9.7. Hash</a></li>
<li><a href="#orgheadline316">10.9.8. BloomFilterPolicy</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline320">11. Discussion</a>
<ul>
<li><a href="#orgheadline319">11.1. leveldb通过iterator遍历，对于相同的key如何保证获取到最新的值（hpplinux)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="http://code.google.com/p/leveldb/">http://code.google.com/p/leveldb/</a>
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
相关资源：
</p>
<ul class="org-ul">
<li>使用文档. <a href="http://leveldb.googlecode.com/svn/trunk/doc/index.html">http://leveldb.googlecode.com/svn/trunk/doc/index.html</a></li>
<li>设计说明. <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a></li>
<li>leveldb和baidu内部kv系统对比. <a href="http://hi.baidu.com/little_fxxker/blog/item/1915f300f7548a046b60fb08.html">http://hi.baidu.com/little_fxxker/blog/item/1915f300f7548a046b60fb08.html</a></li>
<li><a href="http://blog.csdn.net/anderscloud/article/details/7182165">http://blog.csdn.net/anderscloud/article/details/7182165</a></li>
</ul>

<p>
leveldb是一个kv存储系统，其中kv都是二进制。用户接口非常简单就是Put(k,v),Get(k),Delete(k).但是还有以下特性
</p>
<ul class="org-ul">
<li>k有序存储.因为k是二进制没有解释的所以用户需要提供比较函数</li>
<li>支持遍历包括前向和反向</li>
<li>支持atomic write</li>
<li>支持filter policy(bloomfilter)</li>
<li>数据支持自动压缩(使用snappy压缩算法.关于snappy分析可以看<a href="snappy.html">这里</a>)</li>
<li>底层提供了抽象接口，允许用户定制</li>
</ul>
<p>
当然也存在一定的限制
</p>
<ul class="org-ul">
<li>不是SQL数据库，没有数据关系模型</li>
<li>一个table只允许一个process访问</li>
<li>单机系统没有client-server.</li>
</ul>

<p>
目录层次划分是这样的(意图是我猜想的)
</p>
<ul class="org-ul">
<li>db // 和db逻辑相关的内容</li>
<li>helpers // 里面有一个内存db接口</li>
<li>include // Interface</li>
<li>port // 操作系统相关的移植接口</li>
<li>table // 表存储结构</li>
<li>util // 公用部分.</li>
</ul>

<p>
leveldb还是比较麻烦的.开始阅读的时候(像我)很多策略细节就可以直接忽略.比如什么时候触发compaction的,以及挑选什么层次进行compaction的输出,
选择那些文件进行compaction等.阅读的时候需要了解每个类到底是用来做什么的.个人觉得里面最迷惑的东西就是Version/VersionEdit/VersionSet是用来做什么的.
所谓Version就是做一个compaction时候产生的一个对象.VersionSet是当前DB里面所有的Version.VersionEdit是针对Version的修改.包括添加和删除哪些文件等.
每次compaction时候会产生version表示这个哪些文件是需要的.在回收文件的时候会查看每一个version持有的文件,这样就可以确定哪些文件是不需要的了.
每次进行compaction都会产生这么一个version对象.将对version进行的操作称为version_edit.同时会将这个version_edit写入manifest文件里面去.
这样在恢复DB的时候，首先可以从manifest里面读取到挂掉之前的version是怎么样的.然后通过读取剩余的version_edit得到挂掉之前的version.
同时会读取log文件将挂掉之前操作的kv恢复.
</p>

<p>
#note: 最近看到一篇文章比较leveldb和mysql存储引擎性能(可能是innodb).里面提到了连续插入性能的抖动很大.这可能
和底层为了达到读取高效率不断地进行compaction有关的.关于compaction挑选以及触发这个策略的话以后可以好好研究一下.
</p>

<p>
#note: compaction策略没有仔细分析，但是这个部分是精髓。如何控制compaction策略来针对应用达到最好的读写平衡。另外对于Recovery部分没有仔细看代码，
但是我觉得这个部分倒不是很大的问题，可能学到的东西不多但是需要非常仔细地阅读才行。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> WriteBatch</h2>
<div class="outline-text-2" id="text-2">
<p>
leveldb使用WriteBatch来达到atomic write操作.WriteBatch过程非常简单，就是将atomic write的内容全部写到一个内存buffer上，然后提交这个WriteBatch.
至于具体的分析可以查看"Code Analysis/Batch/WriteBatch"这节的分析。使用WriteBatch一方面可以做到原子操作，另外一方面可以提高吞吐。
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">3</span> BloomFilter</h2>
<div class="outline-text-2" id="text-3">
<p>
相关资源：
</p>
<ul class="org-ul">
<li>Bloom Filter. <a href="http://en.wikipedia.org/wiki/Bloom_filter">http://en.wikipedia.org/wiki/Bloom_filter</a></li>
<li>LevelDB Bloom Filter实现. <a href="http://duanple.blog.163.com/blog/static/7097176720123227403134/">http://duanple.blog.163.com/blog/static/7097176720123227403134/</a></li>
</ul>

<p>
bloom filter原理非常简单，似乎没有必要详细分析。关于代码部分的话可以看Code Analysis/Util/BloomFilter.
至于filter在磁盘上面是如何存储的可以参看下面一节Storage/DiskTable分析。
</p>

<p>
meta block存放了bloom filter信息，这样可以减少磁盘读取。关于Table内部支持bloom filter在table/filter_block.h有实现。
分别是FilterBlockBuilder和FilterBlockReader.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">3.1</span> Format</h3>
<div class="outline-text-3" id="text-3-1">
<p>
leveldb是这么分配filter block的.以base(2KB)计算.如果block offset在[base*i,base*(i+1)-1]之间的话，那么就在filter i上面。存储格式是这样的。
</p>
<pre class="example">
[filter 0]
[filter 1]
[filter 2]
...
[filter N-1]
[offset of filter 0]                  : 4 bytes
[offset of filter 1]                  : 4 bytes
[offset of filter 2]                  : 4 bytes
...
[offset of filter N-1]                : 4 bytes
[offset of beginning of offset array] : 4 bytes
lg(base)                              : 1 byte
</pre>
<p>
那么这个就是一个filter block的格式。filter block存放在meta block里面。在meta index block内部会记录key,filter block handle.其中key就是这个filter的名字,handle就是这个filter block offset.看看下面代码会更容易理解。
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">3.2</span> FilterBlockBuilder</h3>
<div class="outline-text-3" id="text-3-2">
<p>
对于Table在初始化之前会调用StartBlock.并且在每次进行Flush Data Block时候也会根据Data Block offset调用。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">FilterBlockBuilder</span>::<span class="org-function-name">StartBlock</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">block_offset</span>) {
  <span class="org-type">uint64_t</span> <span class="org-variable-name">filter_index</span> = (block_offset / kFilterBase);
  assert(filter_index &gt;= filter_offsets_.size());
  <span class="org-keyword">while</span> (filter_index &gt; filter_offsets_.size()) {
    GenerateFilter();
  }
}
</pre>
</div>
<p>
可以看到两个data block offset跨越超过base的话那么会产生几个empty filter.但是默认实现的话empty filter不占用太多空间。
</p>

<p>
然后每次Table在AddKey时候也会调用FilterBlock::AddKey
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">FilterBlockBuilder</span>::<span class="org-function-name">AddKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-type">Slice</span> <span class="org-variable-name">k</span> = key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
}
</pre>
</div>
<p>
注意这里keys_是一个string.start_记录每个新增key的偏移。AddKey是将这段时间内添加的Key全部缓存下来。
</p>

<p>
然后每次Flush的时候都会产生filter.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">FilterBlockBuilder</span>::<span class="org-function-name">GenerateFilter</span>() {
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">num_keys</span> = start_.size();
  <span class="org-keyword">if</span> (num_keys == 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Fast path if there are no keys for this filter</span>
    filter_offsets_.push_back(result_.size());
    <span class="org-keyword">return</span>;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Make list of keys from flattened key structure</span>
  start_.push_back(keys_.size());  <span class="org-comment-delimiter">// </span><span class="org-comment">Simplify length computation</span>
  tmp_keys_.resize(num_keys);
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; num_keys; i++) {
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">base</span> = keys_.data() + start_[i];
    <span class="org-type">size_t</span> <span class="org-variable-name">length</span> = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Generate filter for current set of keys and append to result_.</span>
  filter_offsets_.push_back(result_.size()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35760;&#24405;&#27599;&#20010;filter&#30340;&#20559;&#31227;.</span>
  policy_-&gt;CreateFilter(&amp;tmp_keys_[0], num_keys, &amp;result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
}
</pre>
</div>

<p>
最后filter block需要刷新出去调用Flush方法。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Slice</span> <span class="org-constant">FilterBlockBuilder</span>::<span class="org-function-name">Finish</span>() {
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>start_.empty()) {
    GenerateFilter();
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Append array of per-filter offsets</span>
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">array_offset</span> = result_.size();
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; filter_offsets_.size(); i++) {
    PutFixed32(&amp;result_, filter_offsets_[i]); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#20351;&#29992;Fixed32&#34920;&#31034;&#20063;&#38750;&#24120;&#22909;&#29702;&#35299;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#25165;&#33021;&#24555;&#36895;&#22320;&#26144;&#23556;&#21040;&#23545;&#24212;&#30340;filter&#19978;&#38754;&#12290;</span>
  }

  PutFixed32(&amp;result_, array_offset); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;array offset&#34920;&#31034;filter offset&#30340;&#36215;&#22987;&#22320;&#22336;</span>
  result_.push_back(kFilterBaseLg);  <span class="org-comment-delimiter">// </span><span class="org-comment">Save encoding parameter in result</span>
  <span class="org-keyword">return</span> Slice(result_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;slice&#23601;&#26159;&#26368;&#32456;&#38656;&#35201;write&#30340;&#25968;&#25454;.</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">3.3</span> FilterBlockReader</h3>
<div class="outline-text-3" id="text-3-3">
<p>
了解上面的filter block的存储格式之后Reader就非常简单。构造函数首先计算出各个参数。simple huh?
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">FilterBlockReader</span>::<span class="org-function-name">FilterBlockReader</span>(<span class="org-keyword">const</span> <span class="org-type">FilterPolicy</span>* <span class="org-variable-name">policy</span>,
                                     <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">contents</span>)
    : policy_(policy),
      data_(<span class="org-constant">NULL</span>),
      offset_(<span class="org-constant">NULL</span>),
      num_(0),
      base_lg_(0) {
  <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = contents.size();
  <span class="org-keyword">if</span> (n &lt; 5) <span class="org-keyword">return</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">1 byte for base_lg_ and 4 for start of offset array</span>
  base_lg_ = contents[n-1];
  <span class="org-type">uint32_t</span> <span class="org-variable-name">last_word</span> = DecodeFixed32(contents.data() + n - 5);
  <span class="org-keyword">if</span> (last_word &gt; n - 5) <span class="org-keyword">return</span>;
  data_ = contents.data();
  offset_ = data_ + last_word;
  num_ = (n - 5 - last_word) / 4;
}
</pre>
</div>

<p>
阅读完成后面的Storage一节之后就会发现query key的话首先是在data index block找到这个key所在的data block offset的。
所以这里filter就是判断某个offset的data block是否含所有key.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">FilterBlockReader</span>::<span class="org-function-name">KeyMayMatch</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">block_offset</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-type">uint64_t</span> <span class="org-variable-name">index</span> = block_offset &gt;&gt; base_lg_;
  <span class="org-keyword">if</span> (index &lt; num_) {
    <span class="org-type">uint32_t</span> <span class="org-variable-name">start</span> = DecodeFixed32(offset_ + index*4); <span class="org-comment-delimiter">// </span><span class="org-comment">filter&#36215;&#22987;&#22320;&#22336;</span>
    <span class="org-type">uint32_t</span> <span class="org-variable-name">limit</span> = DecodeFixed32(offset_ + index*4 + 4); <span class="org-comment-delimiter">// </span><span class="org-comment">filter&#32456;&#27490;&#22320;&#22336;</span>
    <span class="org-keyword">if</span> (start &lt;= limit &amp;&amp; limit &lt;= (offset_ - data_)) {
      <span class="org-type">Slice</span> <span class="org-variable-name">filter</span> = Slice(data_ + start, limit - start);
      <span class="org-keyword">return</span> policy_-&gt;KeyMayMatch(key, filter); <span class="org-comment-delimiter">// </span><span class="org-comment">filter&#21028;&#26029;&#26159;&#21542;&#23384;&#22312;key.</span>
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (start == limit) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Empty filters do not match any keys</span>
      <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Errors are treated as potential matches</span>
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10"><span class="section-number-2">4</span> Storage</h2>
<div class="outline-text-2" id="text-4">
<p>
相关资源：
</p>
<ul class="org-ul">
<li>Table Format. <a href="http://leveldb.googlecode.com/svn/trunk/doc/table_format.txt">http://leveldb.googlecode.com/svn/trunk/doc/table_format.txt</a> sst table存储格式。</li>
<li>Log Format. <a href="http://leveldb.googlecode.com/svn/trunk/doc/log_format.txt">http://leveldb.googlecode.com/svn/trunk/doc/log_format.txt</a> block存储格式。</li>
<li>LevelDB SSTable格式详解. <a href="http://wenku.baidu.com/view/19f83f51be23482fb4da4c29.html">http://wenku.baidu.com/view/19f83f51be23482fb4da4c29.html</a></li>
</ul>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">4.1</span> MemTable</h3>
<div class="outline-text-3" id="text-4-1">
<p>
memtable在leveldb内部实现就是一个skiplist.所有的update都不是in-place的，对于memtable里面的修改来说的话使用的也是使用添加的方式完成的。
对于每个操作都会分配一个sequence number.所以底层也没有办法直接覆盖。对于sequence number很明显就是需要实现snapshot.底层的话leveldb
持有两个memtable,一个memtable用于接收当前的操作是mutable的，一个memtable是immutable专门用于dump to disk的，内部实现类似于双buffer机制。
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">4.2</span> RedoLog</h3>
<div class="outline-text-3" id="text-4-2">
<p>
我们首先阅读Log Format文档看看log存储格式(leveldb采用redo-log来记日志)。每个block都划分成为32KB，里面可能会存在很多条记录，
对于跨块的记录来说的里面存在type字段用来标记这个块是否已经结束。另外值得注意的就是每个记录之前带上了32bit的checksum.对于每条记录多4字节还是很大开销的，
但是其实这也反应了leveldb的定位，就是针对fault-tolerant的分布式系统设计。这些分布式系统架在commodity PC上面，磁盘可能很容易出现问题。
在文档最后作者也给给出了这种block存储方式(recordio)的利弊。
</p>
<pre class="example">
Some benefits over the recordio format:

(1) We do not need any heuristics for resyncing - just go to next
block boundary and scan.  If there is a corruption, skip to the next
block.  As a side-benefit, we do not get confused when part of the
contents of one log file are embedded as a record inside another log
file.

(2) Splitting at approximate boundaries (e.g., for mapreduce) is
simple: find the next block boundary and skip records until we
hit a FULL or FIRST record.

(3) We do not need extra buffering for large records.

Some downsides compared to recordio format:

(1) No packing of tiny records.  This could be fixed by adding a new
record type, so it is a shortcoming of the current implementation,
not necessarily the format.

(2) No compression.  Again, this could be fixed by adding new record types.
</pre>
<p>
pros有：
</p>
<ul class="org-ul">
<li>如果磁盘数据发生损坏的话，那么对于数据定位的话非常简单。如果这个block出现问题的话那么直接跳过这个block即可。</li>
<li>程序处理方面可以很容易地找到边界。</li>
<li>对于单条大数据处理的话我们不需要分配很大的内存来做buffer.</li>
</ul>
<p>
cons有：
</p>
<ul class="org-ul">
<li>没有针对小record进行优化，比如如果record足够小的话完全可以在length部分使用1个字节。</li>
<li>没有进行压缩。对于压缩率完全取决于实现。对于小数据来说的话压缩比可能不高，对于大数据来说比如超过32KB的话，</li>
</ul>
<p>
取决于是按照32KB单个block压缩呢(压缩率可能不高),还是先针对整体压缩(压缩率可能比较耗，但是却需要很大的buffer).
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">4.3</span> DiskTable</h3>
<div class="outline-text-3" id="text-4-3">
<p>
然后可以看看Table Format文档关于table存储格式。table存储格式里面主要包括几个部分：
</p>
<ul class="org-ul">
<li>data block</li>
<li>meta block</li>
<li>meta index block</li>
<li>data index block</li>
<li>footer</li>
</ul>
<p>
footer部分是放在最末尾的，里面包含了data index block以及meta index block的偏移信息，读取table时候从末尾读取。
</p>

<p>
首先我们看看data block是如何组织的。对于DiskTable(TableBuilder)就是不断地Add(Key,Value).当缓存的数据达到一定大小之后，
就会调用Flush这样就形成了一个Block.对于一个Block内部而言的话，有个很重要的概念就是restart point.所谓restart point就是为了解决
前缀压缩的问题的，所谓的restart point就是基准key。假设我们顺序加入abcd,abce,abcf.我们以abcd为restart point的话，那么abce可以存储为
(3,e),abcf存储为(3,f).对于restart point采用全量存储，而对于之后的部分采用增量存储。一个restart block可能存在多个restart point,
将这些restart point在整个table offset记录下来，然后放在data block最后面。每个data block尾部还有一个type和CRC32.其中type可以选择是否
需要针对这个data block进行snappy压缩，而CRC32是针对这个data block的校验。
</p>

<p>
data index block组织形式和data block非常类似，只不过有两个不同。1)data index block从不刷新直到Table构造完成之后才会刷新，所以
对于一个table而言的话只有一个data index block.2)data index block添加的key/value是在data block形成的时候添加的，添加key非常取巧
，是上一个data block和这个data block的一个key seperator.比如上一个data block的max key是abcd,而这个data block的min key是ad.那么这个
seperator可以设置成为ac.seperator的生成可以参考Comparator.使用尽量短的seperator可以减小磁盘开销并且提高效率。而对于添加的value就是
这个data block的offset.同样在data index block也会存在restart point.
</p>

<p>
然后看看进行一个key的query是如何进行的。首先读取出data index block(这个部分可以常驻内存)，得到里面的restart point部分。针对restart point
进行二分。因为restart point指向的key都是全量的key.如果确定在某两个restart point之间之后，就可以遍历这个restart point之间范围分析seperator.
得到想要查找的seperator之后对应的value就是某个data block offset.读取这个data block和之前的方法一样就可以查找key了。对于遍历来说，过程是一样的。
</p>

<p>
这里我们稍微分析一下这样的工作方式的优缺点。对于写或者是merge来说的话，效率相当的高，所有写都是顺序写并且还可以进行压缩。影响写效率的话一个重要参数就是flush block的参数。
但是对于读来说的话，个人觉得过程有点麻烦，但是可以实现得高效率。对于flush block调节会影响到data index block和data block占用内存大小。如果flush block过大的话，
那么会造成data index block耗费内存小，但是每次读取出一个data block内存很大。如果flush block过小的话，那么data index block耗费内存很大，但是每次读取data block内存很小。
而restart point数量会影响过多的话，那么可能会占用稍微大一些的内存空间，但是会使得查找过程更快(遍历数更少).
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11"><span class="section-number-2">5</span> Compaction</h2>
<div class="outline-text-2" id="text-5">
<p>
对于Compaction触发的策略牵扯到了算法问题，自己表示没有仔细看这个策略(其实当时看了但是完全没有理解).这里谈谈compaction如何删除文件的问题。
在leveldb里面每次做一个compaction都会产生一个version对象添加到versionset里面，version里面包含了这个version管理了哪些文件。
每次进行读取都会从某个version读取，然后针对这个version做一个引用计数。然后每次需要删除一些不必要的文件时候就会遍历versionset了解哪些文件
还需要，然后对比文件系统目录下面的文件就知道哪些文件不再需要，即可删除。
</p>

<p>
#note: 这里稍微总结一下 <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 提到的compaction策略。可能阅读完了这些策略之后反过头来看看
代码可能会更好，只是记得当时阅读compaction策略太痛苦了所以直接忽略了。
</p>

<p>
每个level都有一定的大小限制，并且每个level里面的文件的key都是不会overlap的(L0除外).触发条件很多，文档上描述是某个level超过一定限制。
但是之前阅读代码发现其实并不是这样的，可以参看函数VersionSet::PickCompaction.可以看到有两个触发条件size_compaction和seek_compaction.
所谓的size_compaction就是说某个level超过一定大小，而seek_compaction指某个文件被seek次数超过一定次数之后会触发(关于这个值的更新可以查看VersionSet::Builder::Apply,
在一个文件初始创建的时候就已经设置好了allowed_seeks次数).
</p>

<p>
前面是触发条件，后面来说说compaction策略.文档上描述非常简单但是事实不是这样。如果需要compact某个level的话，如果level&gt;0的话那么对于这个level
只会选出一个file来和level+1中存在overlap的文件进行合并然后生成一个新的文件。如果level==0的话那么对于这个level可能选择多个文件出来和level+1中overlap
文件合并。对于选取level中文件来说的话是采用rotate keyspace的方式来挑选的。在生成新文件的时候，通常会有两个情况拆分出一个新文件。1)
文件过大 2)文件和level+2中超过10个存在overlap. 2)情况非常好理解，因为如果产生一个大文件和level+2 overlap文件数量过多的话，那么进行level+1的compaction
时间就会非常长并且随机读非常严重。
</p>

<p>
<a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 文档Timing这节个人感觉非常有价值。作者估算了一下compaction对于整个系统带宽带来的影响。
按照2MB一个sst文件在level(&gt;0)上面的compaction来计算的话，一次compaction需要read 26MB和write 26MB~=50MB.假设磁盘带宽100MB/s我们通过后台线程限制速度的话，
那么做compaction需要耗费5s时间。假设用户写速度也在10MS/s的话，那么会生成50MB数据相当于25个sst level0文件。这样对读来说会造成很大影响。
作者给出的建议包括：
</p>
<pre class="example">
Solution 1: To reduce this problem, we might want to increase the log switching threshold when the number of level-0 files is large.
Though the downside is that the larger this threshold, the more memory we will need to hold the corresponding memtable.

Solution 2: We might want to decrease write rate artificially when the number of level-0 files goes up.

Solution 3: We work on reducing the cost of very wide merges. Perhaps most of the level-0 files will have their blocks sitting uncompressed
in the cache and we will only need to worry about the O(N) complexity in the merging iterator.
</pre>
<p>
其中第二点感觉非常好就是认为控制写入速度当level0文件过多的时候。在db_impl.cc DBImpl::MakeRoomForWrite这个应该是在memtable缺少空间的时候的函数.
</p>
<div class="org-src-container">

<pre class="src src-C++">  allow_delay &amp;&amp;
  versions_-&gt;NumLevelFiles(0) &gt;= <span class="org-constant">config</span>::kL0_SlowdownWritesTrigger) {
<span class="org-comment-delimiter">// </span><span class="org-comment">We are getting close to hitting a hard limit on the number of</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">L0 files.  Rather than delaying a single write by several</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">seconds when we hit the hard limit, start delaying each</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">individual write by 1ms to reduce latency variance.  Also,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">this delay hands over some CPU to the compaction thread in</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">case it is sharing the same core as the writer.</span>
mutex_.Unlock();
env_-&gt;SleepForMicroseconds(1000);
allow_delay = <span class="org-constant">false</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Do not delay a single write more than once</span>
mutex_.Lock();
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12"><span class="section-number-2">6</span> Recovery</h2>
<div class="outline-text-2" id="text-6">
<p>
#note: 这里稍微总结一下 <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 提到的关于recovery的部分。幸运的是在阅读这个文档的时候
也让我重新仔细地思考了一下这个recovery过程可能会如何进行的。
</p>

<p>
我们主要关注三个数据的恢复：
</p>
<ul class="org-ul">
<li>用户的data(log)</li>
<li>leveldb所管理的文件(MANIFEST)</li>
<li>内部生成的sequence number(MANIFEST)</li>
</ul>

<p>
对于用户的data而言可以通过记录log来完成。注意这个log里面都是db的insert/delete等操作。值得注意的是，每次生成新的memtable也会生成新的log文件。
这点是非常必要的，因为这样才可以将需要恢复哪些log对应起来。并且log里面每条日志都带上了sequence number,所以log里面的sequence number也有助于
sequence number恢复。
</p>

<p>
记录leveldb所管理的文件非常简单。我们观察管理文件变化只会发生在compaction的时候，在当前version下面删除一部分文件生成一部分文件。我们将
这些变化称为VersionEdit.每次compaction完成之后的话我们将这个version edit记录在MANIFEST内部，同时生成一个Version。version edit是增量,version是全量。
(至于如何记录这个没有仔细看.但是看代码里面似乎有全量也有增量的记录).如果创建一个新的MANIFEST文件的话，会将MANIFEST文件名称记录在CURRENT内部。
这样启动之后就知道读取哪个MANIFEST文件了。当然记录在MANIFEST内部的不仅仅是文件的变化，还有生成这个Version时候对应的log以及sequence number.
</p>

<p>
这样我们的recovery过程就非常简单了。读取CURRENT文件知道读取哪个MANIFEST文件。从MANIFEST文件里面构造Version并且回放VersionEdit.
根据当前的状态知道需要读取哪些log.然后回放log更新sequence number等状态。
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13"><span class="section-number-2">7</span> Snapshot</h2>
<div class="outline-text-2" id="text-7">
<p>
Snapshot集合在leveldb里面组织成为一个链表，oldest的节点必然最小的snapshot。对于每一个snapshot配备一个sequence number,
所以很明显oldest的节点的sequence number应该是最小的。每次进行compaction的时候会判断当前最小的sequence number
是多少然后将一些不必要的节点删除。另外在查询key的时候也会结合这个snapshot sequence number结合成为一个复合key进行查询。
</p>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">8</span> Cache</h2>
<div class="outline-text-2" id="text-8">
<p>
对于leveldb来说的话存在两个cache系统，一个是TableCache，一个是BlockCache.其中TableCache是用来缓存文件描述符的，
而BlockCache是用来做data block的缓存的(Table::BlockeReader).对于leveldb只有一个cache实现在Code Analysis/Cache里面做了详细分析。
</p>

<p>
我们这里最感兴趣的东西，应该就是每个cache的kv分别是什么。对于TableCahce的k是file_number,v是Table的Iterator
(Table::NewIterator).对于leveldb来说的话文件的file_number都是自增的所以使用file_number没有任何问题。对于BlockCache
来说的话k是(cache_id,offset),v是Block的内存。(#todo: 对于这个cache_id现在还不是非常理解，但是个人觉得
这个cache_id可以==file_number.使用cache_id就是每次Open的时候这个cache_id都会改变)
</p>

<p>
和BlockCache是针对disk block来进行cache的，另外一种cache方案就是Record Cache.相对Block Cache,Record Cache无疑更能够
提高使用效率包括内存大小以及Cache命中率。但是大家拒绝在内部使用RecordCache的原因非常简答，就是这个在应用层完成似乎更好，
应用层可以更好地进行Cache。在应用层完成同时会引入一个问题就是Cache一致性，但是其实维持这个一致性并不是一件很复杂的事情，
Cache主要用来解决读取问题，做写穿透并且让Cache失效即可。leveldb维护BlockCache一致性并不麻烦，因为leveldb的update并不是in-place的。
</p>

<p>
#note: 不过后来仔细想了一下觉得Record Cache还是在应用层做比较好，可以控制缓存策略比如大小失效时间。对于底层库还是在做BlockCache会比较好一些.
</p>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-2">
<h2 id="orgheadline15"><span class="section-number-2">9</span> Option</h2>
<div class="outline-text-2" id="text-9">
<p>
在options.h里面有一些leveldb可选的选项。
</p>
<ul class="org-ul">
<li>comparator.用户可以指定比较器</li>
<li>create_if_missing.如果数据库不存在就创建</li>
<li>error_if_exists.如果数据库存在就报错</li>
<li>paranoid_checks.尽可能多地进行错误检查</li>
<li>env.用户可以模拟db环境</li>
<li>info_log.leveldb本身logger.</li>
<li>write_buffer_size.memtable大小</li>
<li>max_open_files.最大打开fd数量</li>
<li>block_cache.Table读取data block的cache.</li>
<li>block_size.Table里面Block大小</li>
<li>block_restart_interval.在一个Block里面每隔多少个key创建一个restart point.</li>
<li>compression.DataBlock是否需要压缩</li>
<li>filter_policy.过滤策略默认就是bloom filter.</li>
<li>verify_checksums.读取block时候是否校验checksum</li>
<li>fill_cache.读取block是否会Cache.通常scan时候不要做cache</li>
<li>sync.leveldb内部发起write的话是否会调用fsync.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline318" class="outline-2">
<h2 id="orgheadline318"><span class="section-number-2">10</span> ReadingCode</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">10.1</span> Interface</h3>
<div class="outline-text-3" id="text-10-1">
<p>
我们首先看看leveldb给我们暴露的头文件有哪些.稍微简单地看看接口提供了哪些功能.头文件目录是include/leveldb
</p>
<ul class="org-ul">
<li>cache.h // kv内存cache接口</li>
<li>c.h // leveldb C接口</li>
<li>comparator.h // Slice的比较接口</li>
<li>db.h // db对象接口</li>
<li>env.h // 和环境相关的接口</li>
<li>filter_policy.h // 过滤策略相关的接口</li>
<li>iterator.h // 遍历接口</li>
<li>options.h // db操作的选项对象</li>
<li>slice.h // db操作的key对象(Slice)</li>
<li>status.h // db操作返回状态的对象</li>
<li>table_builder.h // 构建table</li>
<li>table.h // immutable persistent sortedtable.</li>
<li>write_batch.h // 批量(原子)写入对象</li>
</ul>
<p>
leveldb里面对象的实现方式，很多都是采用抽象类然后提供工厂模式来创建的，这样的话允许用户更换具体实现。
</p>
</div>

<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16"><span class="section-number-4">10.1.1</span> cache.h</h4>
<div class="outline-text-4" id="text-10-1-1">
<p>
Cache主要是用来作为kv查询cache部分.Cache接口非常简单，其中Handle是了为了管理cache item.注释写得非常好
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Cache</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Cache</span>() { }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Destroys all existing entries by calling the "deleter"</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">function that was passed to the constructor.</span>
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Cache</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Opaque handle to an entry stored in the cache.</span>
  <span class="org-keyword">struct</span> <span class="org-type">Handle</span> { };

  <span class="org-comment-delimiter">// </span><span class="org-comment">Insert a mapping from key-&gt;value into the cache and assign it</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the specified charge against the total cache capacity.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns a handle that corresponds to the mapping.  The caller</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">must call this-&gt;Release(handle) when the returned mapping is no</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">longer needed.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">When the inserted entry is no longer needed, the key and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">value will be passed to "deleter".</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Handle</span>* <span class="org-function-name">Insert</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">void</span>* <span class="org-variable-name">value</span>, <span class="org-type">size_t</span> <span class="org-variable-name">charge</span>,
                         <span class="org-type">void</span> (*<span class="org-variable-name">deleter</span>)(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">void</span>* <span class="org-variable-name">value</span>)) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">If the cache has no mapping for "key", returns NULL.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Else return a handle that corresponds to the mapping.  The caller</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">must call this-&gt;Release(handle) when the returned mapping is no</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">longer needed.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Handle</span>* <span class="org-function-name">Lookup</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Release a mapping returned by a previous Lookup().</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: handle must not have been released yet.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: handle must have been returned by a method on *this.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Release</span>(<span class="org-type">Handle</span>* <span class="org-variable-name">handle</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the value encapsulated in a handle returned by a</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">successful Lookup().</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: handle must not have been released yet.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: handle must have been returned by a method on *this.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span>* <span class="org-function-name">Value</span>(<span class="org-type">Handle</span>* <span class="org-variable-name">handle</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">If the cache contains entry for key, erase it.  Note that the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">underlying entry will be kept around until all existing handles</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to it have been released.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Erase</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a new numeric id.  May be used by multiple clients who are</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">sharing the same cache to partition the key space.  Typically the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">client will allocate a new id at startup and prepend the id to</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">its cache keys.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">uint64_t</span> <span class="org-function-name">NewId</span>() = 0;

 <span class="org-keyword">private</span>:
  <span class="org-type">void</span> <span class="org-function-name">LRU_Remove</span>(<span class="org-type">Handle</span>* <span class="org-variable-name">e</span>);
  <span class="org-type">void</span> <span class="org-function-name">LRU_Append</span>(<span class="org-type">Handle</span>* <span class="org-variable-name">e</span>);
  <span class="org-type">void</span> <span class="org-function-name">Unref</span>(<span class="org-type">Handle</span>* <span class="org-variable-name">e</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#20197;&#30475;&#21040;Handle&#21487;&#33021;&#23454;&#38469;&#19978;&#24213;&#23618;&#26377;&#24341;&#29992;&#35745;&#25968;&#23384;&#22312;.</span>

  <span class="org-keyword">struct</span> <span class="org-type">Rep</span>;
  <span class="org-type">Rep</span>* <span class="org-variable-name">rep_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">opaque&#23454;&#29616;&#25351;&#38024;&#30340;&#23384;&#22312;.</span>
};
</pre>
</div>
<p>
一般底层Handle有引用计数，然后调用Release的话会atomic dec.如果==0的话那么会调用Insert时候的deleter接口进行释放。
这里稍微总结一下Cache提供的接口
</p>
<ul class="org-ul">
<li>Insert // 插入kv返回Handle</li>
<li>Lookup // 查询k返回Handle</li>
<li>Value // 传入handle得到对应的value</li>
<li>Erase // 删除kv</li>
<li>NewId // 产生一个新id.</li>
</ul>

<p>
实现是ShardedLRUCache.这个后面会具体分析.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">extern</span> <span class="org-type">Cache</span>* <span class="org-function-name">NewLRUCache</span>(<span class="org-type">size_t</span> <span class="org-variable-name">capacity</span>);
<span class="org-type">Cache</span>* <span class="org-function-name">NewLRUCache</span>(<span class="org-type">size_t</span> <span class="org-variable-name">capacity</span>) {
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">ShardedLRUCache</span>(capacity);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17"><span class="section-number-4">10.1.2</span> comparator.h</h4>
<div class="outline-text-4" id="text-10-1-2">
<p>
comparator提供了slice对象的比较方法接口.但是还有两个接口值得提一下
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Advanced functions: these are used to reduce the space requirements</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">for internal data structures like index blocks.</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">If *start &lt; limit, changes *start to a short string in [start,limit).</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Simple comparator implementations may return with *start unchanged,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">i.e., an implementation of this method that does nothing is correct.</span>
<span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">FindShortestSeparator</span>(
    <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">start</span>,
    <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">limit</span>) <span class="org-keyword">const</span> = 0;

<span class="org-comment-delimiter">// </span><span class="org-comment">Changes *key to a short string &gt;= *key.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Simple comparator implementations may return with *key unchanged,</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">i.e., an implementation of this method that does nothing is correct.</span>
<span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">FindShortSuccessor</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> = 0;
</pre>
</div>
<p>
关于这两个接口注释都解释得十分清楚了。
</p>

<p>
实现是ByteWiseComparatorImpl.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Intentionally not destroyed to prevent destructor racing</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">with background threads.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">bytewise</span> = <span class="org-keyword">new</span> <span class="org-type">BytewiseComparatorImpl</span>;

<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-function-name">BytewiseComparator</span>() {
  <span class="org-keyword">return</span> bytewise;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18"><span class="section-number-4">10.1.3</span> db.h</h4>
<div class="outline-text-4" id="text-10-1-3">
<p>
db.h下面有几个对象
</p>
<ul class="org-ul">
<li>Snapshot(接口)</li>
<li>Range</li>
<li>DB(接口)</li>
</ul>

<p>
Snapshot结构非常简单，只是提供了一些虚析构函数接口。实现是SnapshotImpl.
</p>

<p>
Range的话就是两个Slice表示范围，表示[start,limit)
#+BEGGIN_SRC C++
// A range of keys
struct Range {
  Slice start;          <i>/ Included in the range
  Slice limit;          /</i> Not included in the range
</p>

<p>
  Range() { }
  Range(const Slice&amp; s, const Slice&amp; l) : start(s), limit(l) { }
};
#+END_SRC
</p>

<p>
DB是我们发起操作的对象。然后我们看看最关键的DB提供了哪些接口.注释写得清晰真的没有必要解释了:).
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A DB is a persistent ordered map from keys to values.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">A DB is safe for concurrent access from multiple threads without</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">any external synchronization.</span>
<span class="org-keyword">class</span> <span class="org-type">DB</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Open the database with the specified "name".</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Stores a pointer to a heap-allocated database in *dbptr and returns</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">OK on success.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Stores NULL in *dbptr and returns a non-OK status on error.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Caller should delete *dbptr when it is no longer needed.</span>
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">Open</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>,
                     <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>,
                     <span class="org-type">DB</span>** <span class="org-variable-name">dbptr</span>);

  <span class="org-function-name">DB</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">DB</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Set the database entry for "key" to "value".  Returns OK on success,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">and a non-OK status on error.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: consider setting options.sync = true.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Put</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">options</span>,
                     <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>,
                     <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Remove the database entry (if any) for "key".  Returns OK on</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">success, and a non-OK status on error.  It is not an error if "key"</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">did not exist in the database.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: consider setting options.sync = true.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">options</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Apply the specified updates to the database.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns OK on success, non-OK on failure.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: consider setting options.sync = true.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Write</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">options</span>, <span class="org-type">WriteBatch</span>* <span class="org-variable-name">updates</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">If the database contains an entry for "key" store the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">corresponding value in *value and return OK.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If there is no entry for "key" leave *value unchanged and return</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">a status for which Status::IsNotFound() returns true.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">May return some other Status on an error.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Get</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                     <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a heap-allocated iterator over the contents of the database.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The result of NewIterator() is initially invalid (caller must</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">call one of the Seek methods on the iterator before using it).</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Caller should delete the iterator when it is no longer needed.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The returned iterator should be deleted before this db is deleted.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Iterator</span>* <span class="org-function-name">NewIterator</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a handle to the current DB state.  Iterators created with</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">this handle will all observe a stable snapshot of the current DB</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">state.  The caller must call ReleaseSnapshot(result) when the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">snapshot is no longer needed.</span>
  <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">Snapshot</span>* <span class="org-function-name">GetSnapshot</span>() = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Release a previously acquired snapshot.  The caller must not</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">use "snapshot" after this call.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">ReleaseSnapshot</span>(<span class="org-keyword">const</span> <span class="org-type">Snapshot</span>* <span class="org-variable-name">snapshot</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">DB implementations can export properties about their state</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">via this method.  If "property" is a valid property understood by this</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">DB implementation, fills "*value" with its current value and returns</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">true.  Otherwise returns false.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Valid property names include:</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">"leveldb.num-files-at-level&lt;N&gt;" - return the number of files at level &lt;N&gt;,</span>
  <span class="org-comment-delimiter">//     </span><span class="org-comment">where &lt;N&gt; is an ASCII representation of a level number (e.g. "0").</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">"leveldb.stats" - returns a multi-line string that describes statistics</span>
  <span class="org-comment-delimiter">//     </span><span class="org-comment">about the internal operation of the DB.</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">"leveldb.sstables" - returns a multi-line string that describes all</span>
  <span class="org-comment-delimiter">//     </span><span class="org-comment">of the sstables that make up the db contents.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">GetProperty</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">property</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">For each i in [0,n-1], store in "sizes[i]", the approximate</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">file system space used by keys in "[range[i].start .. range[i].limit)".</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note that the returned sizes measure file system space usage, so</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">if the user data compresses by a factor of ten, the returned</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">sizes will be one-tenth the size of the corresponding user data size.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The results may not include the sizes of recently written data.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">GetApproximateSizes</span>(<span class="org-keyword">const</span> <span class="org-type">Range</span>* <span class="org-variable-name">range</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>,
                                   <span class="org-type">uint64_t</span>* <span class="org-variable-name">sizes</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Compact the underlying storage for the key range [*begin,*end].</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">In particular, deleted and overwritten versions are discarded,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">and the data is rearranged to reduce the cost of operations</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">needed to access the data.  This operation should typically only</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">be invoked by users who understand the underlying implementation.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">begin==NULL is treated as a key before all keys in the database.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">end==NULL is treated as a key after all keys in the database.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Therefore the following call will compact the entire database:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">db-&gt;CompactRange(NULL, NULL);</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">CompactRange</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">begin</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">end</span>) = 0;
};
</pre>
</div>
<p>
实现是DBImpl.这里稍微总结一下DB提供的接口
</p>
<ul class="org-ul">
<li>Open // 创建DB</li>
<li>Put //</li>
<li>Delete //</li>
<li>Write // batch(atomic)写入.</li>
<li>Get //</li>
<li>NewInterator // 创建迭代器</li>
<li>GetSnapshot // 创建snapshot</li>
<li>ReleaseSnapShot // 销毁snapshot</li>
<li>GetProperty // 获取属性</li>
<li>GetApproximateSizes // 根据range这个部分内容占用磁盘大小</li>
<li>CompactRange // 压缩range这个部分内容</li>
</ul>

<p>
此外还提供了两个函数用于删除DB以及修复DB.这个会单独讨论.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Destroy the contents of the specified database.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Be very careful using this method.</span>
<span class="org-type">Status</span> <span class="org-function-name">DestroyDB</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>, <span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">If a DB cannot be opened, you may attempt to call this method to</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">resurrect as much of the contents of the database as possible.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Some data may be lost, so be careful when calling this function</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">on a database that contains important information.</span>
<span class="org-type">Status</span> <span class="org-function-name">RepairDB</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>, <span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">10.1.4</span> env.h</h4>
<div class="outline-text-4" id="text-10-1-4">
<p>
env.h里面抽象了环境，这样用户可以很方便低进行定制.可以看到leveldb大量的设计依赖于虚函数。
对于这种存储系统用虚函数带来的开销应该是可以接受的。但是对于压缩或者是传输协议的话那么虚函数开销就不可以忽略了。
提供提供了默认环境实现在util/env_posix.cc里面。这个会在后面详细分析。所谓环境包括下面几个对象.
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline19"></a>Env<br  /><div class="outline-text-5" id="text-10-1-4-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Env</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Env</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Env</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a default environment suitable for the current operating</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">system.  Sophisticated users may wish to provide their own Env</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">implementation instead of relying on this default environment.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The result of Default() belongs to leveldb and must never be deleted.</span>
  <span class="org-keyword">static</span> <span class="org-type">Env</span>* <span class="org-function-name">Default</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a brand new sequentially-readable file with the specified name.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">On success, stores a pointer to the new file in *result and returns OK.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">On failure stores NULL in *result and returns non-OK.  If the file does</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">not exist, returns a non-OK status.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The returned file will only be accessed by one thread at a time.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewSequentialFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>,
                                   <span class="org-type">SequentialFile</span>** <span class="org-variable-name">result</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a brand new random access read-only file with the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">specified name.  On success, stores a pointer to the new file in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">*result and returns OK.  On failure stores NULL in *result and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">returns non-OK.  If the file does not exist, returns a non-OK</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">status.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The returned file may be concurrently accessed by multiple threads.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewRandomAccessFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>,
                                     <span class="org-type">RandomAccessFile</span>** <span class="org-variable-name">result</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create an object that writes to a new file with the specified</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">name.  Deletes any existing file with the same name and creates a</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">new file.  On success, stores a pointer to the new file in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">*result and returns OK.  On failure stores NULL in *result and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">returns non-OK.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The returned file will only be accessed by one thread at a time.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewWritableFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>,
                                 <span class="org-type">WritableFile</span>** <span class="org-variable-name">result</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true iff the named file exists.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">FileExists</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Store in *result the names of the children of the specified directory.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The names are relative to "dir".</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Original contents of *results are dropped.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">GetChildren</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dir</span>,
                             <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::<span class="org-type">string</span>&gt;* <span class="org-variable-name">result</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Delete the named file.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">DeleteFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create the specified directory.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">CreateDir</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dirname</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Delete the specified directory.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">DeleteDir</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dirname</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Store the size of fname in *file_size.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">GetFileSize</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>, <span class="org-type">uint64_t</span>* <span class="org-variable-name">file_size</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Rename file src to target.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">RenameFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">src</span>,
                            <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">target</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Lock the specified file.  Used to prevent concurrent access to</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the same db by multiple processes.  On failure, stores NULL in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">*lock and returns non-OK.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">On success, stores a pointer to the object that represents the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">acquired lock in *lock and returns OK.  The caller should call</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">UnlockFile(*lock) to release the lock.  If the process exits,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the lock will be automatically released.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If somebody else already holds the lock, finishes immediately</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">with a failure.  I.e., this call does not wait for existing locks</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to go away.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">May create the named file if it does not already exist.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">LockFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>, <span class="org-type">FileLock</span>** <span class="org-variable-name">lock</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Release the lock acquired by a previous successful call to LockFile.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: lock was returned by a successful LockFile() call</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: lock has not already been unlocked.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">UnlockFile</span>(<span class="org-type">FileLock</span>* <span class="org-variable-name">lock</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Arrange to run "(*function)(arg)" once in a background thread.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"function" may run in an unspecified thread.  Multiple functions</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">added to the same Env may run concurrently in different threads.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">I.e., the caller may not assume that background work items are</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">serialized.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Schedule</span>(
      <span class="org-type">void</span> (*<span class="org-variable-name">function</span>)(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>),
      <span class="org-type">void</span>* <span class="org-variable-name">arg</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Start a new thread, invoking "function(arg)" within the new thread.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">When "function(arg)" returns, the thread will be destroyed.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">StartThread</span>(<span class="org-type">void</span> (*<span class="org-variable-name">function</span>)(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>), <span class="org-type">void</span>* <span class="org-variable-name">arg</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">*path is set to a temporary directory that can be used for testing. It may</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">or many not have just been created. The directory may or may not differ</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">between runs of the same process, but subsequent calls will return the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">same directory.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">GetTestDirectory</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">path</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create and return a log file for storing informational messages.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewLogger</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>, <span class="org-type">Logger</span>** <span class="org-variable-name">result</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns the number of micro-seconds since some fixed point in time. Only</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">useful for computing deltas of time.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">uint64_t</span> <span class="org-function-name">NowMicros</span>() = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Sleep/delay the thread for the perscribed number of micro-seconds.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SleepForMicroseconds</span>(<span class="org-type">int</span> <span class="org-variable-name">micros</span>) = 0;
};
</pre>
</div>
<p>
稍微总结一下这些接口.对于这些接口创建的抽象对象，在后面也会详细解释。实现是PosixEnv.
</p>
<ul class="org-ul">
<li>Default // 获得默认的环境</li>
<li>NewSequentialFile // 创建顺序文件</li>
<li>NewRandomAccessFile // 创建随机文件</li>
<li>NewWritableFile // 创建可写文件</li>
<li>FileExists // 文件是否存在</li>
<li>GetChildren // 目录下面的文件</li>
<li>DeleteFile // 删除文件</li>
<li>CreateDir // 创建目录</li>
<li>DeleteDir // 删除目录</li>
<li>GetFileSize // filesize.</li>
<li>RenameFile // rename.</li>
<li>LockFile // 锁住文件</li>
<li>UnlockFile // 解锁文件</li>
<li>StartThread // 创建线程</li>
<li>GetTestDirectory // 测试目录</li>
<li>NewLogger // 创建logger打印到对应文件</li>
<li>NowMicros // 当前us.</li>
<li>SleepForMicroseconds // sleep us</li>
</ul>
<p>
环境还提供了一个EnvWrapper.这个类就是得到一个Env*对象然后重新转发出去。
</p>
</div></li>

<li><a id="orgheadline20"></a>FileLock<br  /><div class="outline-text-5" id="text-10-1-4-2">
<p>
FileLock接口非常简单，可以说就没有接口.唯一要做的事情就是和Env里面的LockFile与UnlockFile配合。实现是PosixFileLock.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Identifies a locked file.</span>
<span class="org-keyword">class</span> <span class="org-type">FileLock</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">FileLock</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">FileLock</span>();
 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying allowed</span>
  <span class="org-function-name">FileLock</span>(<span class="org-keyword">const</span> <span class="org-type">FileLock</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">FileLock</span>&amp;);
};
</pre>
</div>
</div></li>

<li><a id="orgheadline21"></a>Logger<br  /><div class="outline-text-5" id="text-10-1-4-3">
<p>
Logger接口也非常简单，就是Logv.允许打印变长参数.实现是PosixLogger.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">An interface for writing log messages.</span>
<span class="org-keyword">class</span> <span class="org-type">Logger</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Logger</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Logger</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Write an entry to the log file with the specified format.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Logv</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">format</span>, <span class="org-type">va_list</span> <span class="org-variable-name">ap</span>) = 0;

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying allowed</span>
  <span class="org-function-name">Logger</span>(<span class="org-keyword">const</span> <span class="org-type">Logger</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Logger</span>&amp;);
};
</pre>
</div>

<p>
为了编写方便提供了这么一个宏
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Log the specified data to *info_log if info_log is non-NULL.</span>
<span class="org-keyword">extern</span> <span class="org-type">void</span> <span class="org-function-name">Log</span>(<span class="org-type">Logger</span>* <span class="org-variable-name">info_log</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">format</span>, ...)
<span class="org-preprocessor">#   if</span> <span class="org-preprocessor">defined</span>(__GNUC__) || <span class="org-preprocessor">defined</span>(__clang__)
    <span class="org-keyword">__attribute__</span>((__format__ (__printf__, 2, 3)))
<span class="org-preprocessor">#   endif</span>
    ;
</pre>
</div>
</div></li>

<li><a id="orgheadline22"></a>RandomAccessFile<br  /><div class="outline-text-5" id="text-10-1-4-4">
<p>
RandomAccessFile所提供的语义就是能够随机从offset读取n个字节，存放在scratch里面。
然后将result里面的内容指向scratch.随机读取并且要求能够多线程安全。实现是PosixRandomAccessFile.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A file abstraction for randomly reading the contents of a file.</span>
<span class="org-keyword">class</span> <span class="org-type">RandomAccessFile</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">RandomAccessFile</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">RandomAccessFile</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Read up to "n" bytes from the file starting at "offset".</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"scratch[0..n-1]" may be written by this routine.  Sets "*result"</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to the data that was read (including if fewer than "n" bytes were</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">successfully read).  May set "*result" to point at data in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"scratch[0..n-1]", so "scratch[0..n-1]" must be live when</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"*result" is used.  If an error was encountered, returns a non-OK</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">status.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Safe for concurrent use by multiple threads.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Read</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">offset</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">Slice</span>* <span class="org-variable-name">result</span>,
                      <span class="org-type">char</span>* <span class="org-variable-name">scratch</span>) <span class="org-keyword">const</span> = 0;
};
</pre>
</div>
</div></li>

<li><a id="orgheadline23"></a>SequentialFile<br  /><div class="outline-text-5" id="text-10-1-4-5">
<p>
SequentialFile提供的语义包括顺序读取以及Skip字节。这些都是外部来保证同步的。实现是PosixSequentialFile.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A file abstraction for reading sequentially through a file</span>
<span class="org-keyword">class</span> <span class="org-type">SequentialFile</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">SequentialFile</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">SequentialFile</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Read up to "n" bytes from the file.  "scratch[0..n-1]" may be</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">written by this routine.  Sets "*result" to the data that was</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">read (including if fewer than "n" bytes were successfully read).</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">May set "*result" to point at data in "scratch[0..n-1]", so</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"scratch[0..n-1]" must be live when "*result" is used.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If an error was encountered, returns a non-OK status.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: External synchronization</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Read</span>(<span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">Slice</span>* <span class="org-variable-name">result</span>, <span class="org-type">char</span>* <span class="org-variable-name">scratch</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Skip "n" bytes from the file. This is guaranteed to be no</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">slower that reading the same data, but may be faster.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If end of file is reached, skipping will stop at the end of the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">file, and Skip will return OK.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: External synchronization</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Skip</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">n</span>) = 0;
};
</pre>
</div>
</div></li>

<li><a id="orgheadline24"></a>WritableFile<br  /><div class="outline-text-5" id="text-10-1-4-6">
<p>
WritableFile语义就是允许Append,Close,Flush,Sync.这里Flush的语义应该是将内部缓存数据完全写入，
而Sync表示让磁盘进行同步。因为可能外部会调用小对象的写入，所以这里需要进行缓存。实现是PosixMmapFile.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A file abstraction for sequential writing.  The implementation</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">must provide buffering since callers may append small fragments</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">at a time to the file.</span>
<span class="org-keyword">class</span> <span class="org-type">WritableFile</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">WritableFile</span>() { }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">WritableFile</span>();

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">data</span>) = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Close</span>() = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Flush</span>() = 0;
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Sync</span>() = 0;

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying allowed</span>
  <span class="org-function-name">WritableFile</span>(<span class="org-keyword">const</span> <span class="org-type">WritableFile</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">WritableFile</span>&amp;);
};
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26"><span class="section-number-4">10.1.5</span> filter_policy.h</h4>
<div class="outline-text-4" id="text-10-1-5">
<p>
通过阅读注释还是可以很容易地了解到filter_policy提供的语义的。另外还可以看到leveldb本身提供了bloomfilter的实现。#todo: 这里对于bits_per_key含义不是很了解。
</p>

<p>
#note: 所谓的bits_per_key就是希望为每个key分配多少个bits来进行检测。但是这个并不等于检测bits.在leveldb这个bloomfilter里面的话这个数值叫做probe.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">FilterPolicy</span> {
 <span class="org-keyword">public</span>:
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">FilterPolicy</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#29992;&#26469;&#20570;&#20860;&#23481;&#21028;&#26029;&#12290;&#22914;&#26524;&#26032;&#30340;filter policy&#21457;&#29983;&#25913;&#21464;&#30340;&#35805;&#65292;&#37027;&#20040;&#36825;&#20010;&#21517;&#23383;&#20063;&#24517;&#39035;&#21464;&#21270;&#12290;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the name of this policy.  Note that if the filter encoding</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">changes in an incompatible way, the name returned by this method</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">must be changed.  Otherwise, old incompatible filters may be</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">passed to methods of this type.</span>
  <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">Name</span>() <span class="org-keyword">const</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">keys&#37117;&#26159;&#25490;&#22909;&#24207;&#30340;&#65292;&#23558;&#36825;&#20123;keys&#21152;&#20837;filter.&#30456;&#24403;&#20110;&#21578;&#30693;&#36825;&#20123;keys&#24050;&#32463;&#23384;&#22312;&#12290;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">keys[0,n-1] contains a list of keys (potentially with duplicates)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">that are ordered according to the user supplied comparator.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Append a filter that summarizes keys[0,n-1] to *dst.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Warning: do not change the initial contents of *dst.  Instead,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">append the newly constructed filter to *dst.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">CreateFilter</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">keys</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>)
      <span class="org-keyword">const</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;key&#26159;&#21542;&#22312;filter&#37324;&#38754;&#12290;&#36825;&#20010;filter&#26159;&#22312;CreateFilter&#37324;&#38754;&#30340;dst&#21253;&#35013;&#20986;&#26469;&#30340;&#12290;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"filter" contains the data appended by a preceding call to</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">CreateFilter() on this class.  This method must return true if</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the key was in the list of keys passed to CreateFilter().</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">This method may return true or false if the key was not on the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">list, but it should aim to return false with a high probability.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">KeyMayMatch</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">filter</span>) <span class="org-keyword">const</span> = 0;
};

<span class="org-comment-delimiter">// </span><span class="org-comment">Return a new filter policy that uses a bloom filter with approximately</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the specified number of bits per key.  A good value for bits_per_key</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">is 10, which yields a filter with ~ 1% false positive rate.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Callers must delete the result after any database that is using the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">result has been closed.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Note: if you are using a custom comparator that ignores some parts</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">of the keys being compared, you must not use NewBloomFilterPolicy()</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and must provide your own FilterPolicy that also ignores the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">corresponding parts of the keys.  For example, if the comparator</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">ignores trailing spaces, it would be incorrect to use a</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">FilterPolicy (like NewBloomFilterPolicy) that does not ignore</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">trailing spaces in keys.</span>
<span class="org-keyword">extern</span> <span class="org-keyword">const</span> <span class="org-type">FilterPolicy</span>* <span class="org-function-name">NewBloomFilterPolicy</span>(<span class="org-type">int</span> <span class="org-variable-name">bits_per_key</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27"><span class="section-number-4">10.1.6</span> iterator.h</h4>
<div class="outline-text-4" id="text-10-1-6">
<p>
遍历器接口非常简单，支持前向和反向遍历。还支持seek到某一个key.支持注册cleanup函数.实现是DBIter.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Iterator</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Iterator</span>();
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">Iterator</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">An iterator is either positioned at a key/value pair, or</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">not valid.  This method returns true iff the iterator is valid.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">Valid</span>() <span class="org-keyword">const</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Position at the first key in the source.  The iterator is Valid()</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">after this call iff the source is not empty.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToFirst</span>() = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Position at the last key in the source.  The iterator is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Valid() after this call iff the source is not empty.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToLast</span>() = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Position at the first key in the source that at or past target</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The iterator is Valid() after this call iff the source contains</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">an entry that comes at or past target.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">target</span>) = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Moves to the next entry in the source.  After this call, Valid() is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">true iff the iterator was not positioned at the last entry in the source.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Valid()</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Next</span>() = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Moves to the previous entry in the source.  After this call, Valid() is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">true iff the iterator was not positioned at the first entry in source.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Valid()</span>
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Prev</span>() = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the key for the current entry.  The underlying storage for</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the returned slice is valid only until the next modification of</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the iterator.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Valid()</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Slice</span> <span class="org-function-name">key</span>() <span class="org-keyword">const</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the value for the current entry.  The underlying storage for</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the returned slice is valid only until the next modification of</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the iterator.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: !AtEnd() &amp;&amp; !AtStart()</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Slice</span> <span class="org-function-name">value</span>() <span class="org-keyword">const</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">If an error has occurred, return it.  Else return an ok status.</span>
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">status</span>() <span class="org-keyword">const</span> = 0;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Clients are allowed to register function/arg1/arg2 triples that</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">will be invoked when this iterator is destroyed.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note that unlike all of the preceding methods, this method is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">not abstract and therefore clients should not override it.</span>
  <span class="org-keyword">typedef</span> <span class="org-type">void</span> (*<span class="org-type">CleanupFunction</span>)(<span class="org-type">void</span>* <span class="org-variable-name">arg1</span>, <span class="org-type">void</span>* <span class="org-variable-name">arg2</span>);
  <span class="org-type">void</span> <span class="org-function-name">RegisterCleanup</span>(<span class="org-type">CleanupFunction</span> <span class="org-variable-name">function</span>, <span class="org-type">void</span>* <span class="org-variable-name">arg1</span>, <span class="org-type">void</span>* <span class="org-variable-name">arg2</span>);

 <span class="org-keyword">private</span>:
  <span class="org-keyword">struct</span> <span class="org-type">Cleanup</span> {
    <span class="org-type">CleanupFunction</span> <span class="org-variable-name">function</span>;
    <span class="org-type">void</span>* <span class="org-variable-name">arg1</span>;
    <span class="org-type">void</span>* <span class="org-variable-name">arg2</span>;
    <span class="org-type">Cleanup</span>* <span class="org-variable-name">next</span>;
  };
  <span class="org-type">Cleanup</span> <span class="org-variable-name">cleanup_</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying allowed</span>
  <span class="org-function-name">Iterator</span>(<span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Iterator</span>&amp;);
};
</pre>
</div>
<p>
这个里面部分实现在table/iterator.cc里面有.都非常简单.创建好cleanup对象然后组织称为链表,在析构函数时候调用.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">Iterator</span>::<span class="org-function-name">Iterator</span>() {
  cleanup_.function = <span class="org-constant">NULL</span>;
  cleanup_.next = <span class="org-constant">NULL</span>;
}

<span class="org-constant">Iterator</span>::~<span class="org-function-name">Iterator</span>() {
  <span class="org-keyword">if</span> (cleanup_.function != <span class="org-constant">NULL</span>) {
    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
    <span class="org-keyword">for</span> (<span class="org-type">Cleanup</span>* <span class="org-variable-name">c</span> = cleanup_.next; c != <span class="org-constant">NULL</span>; ) {
      (*c-&gt;function)(c-&gt;arg1, c-&gt;arg2);
      <span class="org-type">Cleanup</span>* <span class="org-variable-name">next</span> = c-&gt;next;
      <span class="org-keyword">delete</span> c;
      c = next;
    }
  }
}

<span class="org-type">void</span> <span class="org-constant">Iterator</span>::<span class="org-function-name">RegisterCleanup</span>(<span class="org-type">CleanupFunction</span> <span class="org-variable-name">func</span>, <span class="org-type">void</span>* <span class="org-variable-name">arg1</span>, <span class="org-type">void</span>* <span class="org-variable-name">arg2</span>) {
  assert(func != <span class="org-constant">NULL</span>);
  <span class="org-type">Cleanup</span>* <span class="org-variable-name">c</span>;
  <span class="org-keyword">if</span> (cleanup_.function == <span class="org-constant">NULL</span>) {
    c = &amp;cleanup_;
  } <span class="org-keyword">else</span> {
    c = <span class="org-keyword">new</span> <span class="org-type">Cleanup</span>;
    c-&gt;next = cleanup_.next;
    cleanup_.next = c;
  }
  c-&gt;function = func;
  c-&gt;arg1 = arg1;
  c-&gt;arg2 = arg2;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31"><span class="section-number-4">10.1.7</span> options.h</h4>
<div class="outline-text-4" id="text-10-1-7">
<p>
对于options来说存在3种
</p>
<ul class="org-ul">
<li>Options // 控制DB行为.</li>
<li>ReadOptions // 控制读取行为</li>
<li>WriteOptions // 控制写入行为</li>
</ul>
</div>

<ol class="org-ol"><li><a id="orgheadline28"></a>Options<br  /><div class="outline-text-5" id="text-10-1-7-1">
<p>
Options控制DB行为，在DB::Open时候就传入.我们需要针对这些字段仔细看看.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">DB contents are stored in a set of blocks, each of which holds a</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">sequence of key,value pairs.  Each block may be compressed before</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">being stored in a file.  The following enum describes which</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">compression method (if any) is used to compress a block.</span>
<span class="org-keyword">enum</span> <span class="org-type">CompressionType</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">NOTE: do not change the values of existing entries, as these are</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">part of the persistent format on disk.</span>
  <span class="org-variable-name">kNoCompression</span>     = 0x0,
  <span class="org-variable-name">kSnappyCompression</span> = 0x1
};

<span class="org-comment-delimiter">// </span><span class="org-comment">Options to control the behavior of a database (passed to DB::Open)</span>
<span class="org-keyword">struct</span> <span class="org-type">Options</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">-------------------</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Parameters that affect behavior</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Comparator used to define the order of keys in the table.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: a comparator that uses lexicographic byte-wise ordering</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: The client must ensure that the comparator supplied</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">here has the same name and orders keys *exactly* the same as the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">comparator provided to previous open calls on the same DB.</span>
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">comparator</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#20309;&#36827;&#34892;slice compare</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">If true, the database will be created if it is missing.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: false</span>
  <span class="org-type">bool</span> <span class="org-variable-name">create_if_missing</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">database&#19981;&#23384;&#22312;&#26159;&#21542;&#38656;&#35201;&#21019;&#24314;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">If true, an error is raised if the database already exists.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: false</span>
  <span class="org-type">bool</span> <span class="org-variable-name">error_if_exists</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25968;&#25454;&#24211;&#23384;&#22312;&#26159;&#21542;error</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">If true, the implementation will do aggressive checking of the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">data it is processing and will stop early if it detects any</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">errors.  This may have unforeseen ramifications: for example, a</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">corruption of one DB entry may cause a large number of entries to</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">become unreadable or for the entire DB to become unopenable.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: false</span>
  <span class="org-type">bool</span> <span class="org-variable-name">paranoid_checks</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20250;&#26356;&#22810;&#22320;&#26816;&#26597;&#25968;&#25454;&#27491;&#30830;&#24615;.&#36825;&#20010;&#22312;&#26085;&#24535;&#22238;&#25918;&#30340;&#26102;&#20505;&#26377;&#25928;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">MaybeIgnoreError&#37324;&#38754;&#20351;&#29992;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Use the specified object to interact with the environment,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">e.g. to read/write files, schedule background work, etc.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: Env::Default()</span>
  <span class="org-type">Env</span>* <span class="org-variable-name">env</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25805;&#20316;&#29615;&#22659;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Any internal progress/error information generated by the db will</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">be written to info_log if it is non-NULL, or to a file stored</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">in the same directory as the DB contents if info_log is NULL.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: NULL</span>
  <span class="org-type">Logger</span>* <span class="org-variable-name">info_log</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Logger.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">-------------------</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Parameters that affect performance</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Amount of data to build up in memory (backed by an unsorted log</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">on disk) before converting to a sorted on-disk file.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Larger values increase performance, especially during bulk loads.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Up to two write buffers may be held in memory at the same time,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">so you may wish to adjust this parameter to control memory usage.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Also, a larger write buffer will result in a longer recovery time</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the next time the database is opened.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: 4MB</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">write_buffer_size</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">memtable&#36229;&#36807;&#36825;&#20123;&#20869;&#23384;&#22823;&#23567;&#30340;&#35805;&#23601;&#20250;&#20889;table.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Number of open files that can be used by the DB.  You may need to</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">increase this if your database has a large working set (budget</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">one open file per 2MB of working set).</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: 1000</span>
  <span class="org-type">int</span> <span class="org-variable-name">max_open_files</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#22823;&#25991;&#20214;&#21477;&#26564;&#25968;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Control over blocks (user data is stored in a set of blocks, and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">a block is the unit of reading from disk).</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">If non-NULL, use the specified cache for blocks.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If NULL, leveldb will automatically create and use an 8MB internal cache.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: NULL</span>
  <span class="org-type">Cache</span>* <span class="org-variable-name">block_cache</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20869;&#37096;cahce.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Approximate size of user data packed per block.  Note that the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">block size specified here corresponds to uncompressed data.  The</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">actual size of the unit read from disk may be smaller if</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">compression is enabled.  This parameter can be changed dynamically.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: 4K</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">block_size</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">SSTable&#37324;&#38754;&#30340;Block&#22823;&#23567;.&#20855;&#20307;&#21487;&#20197;&#30475;BlockBuilder.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Number of keys between restart points for delta encoding of keys.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">This parameter can be changed dynamically.  Most clients should</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">leave this parameter alone.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: 16</span>
  <span class="org-type">int</span> <span class="org-variable-name">block_restart_interval</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">block&#37324;&#38754;&#30340;restart&#38388;&#38548;.&#20855;&#20307;&#21487;&#20197;&#30475;BlockBuilder.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Compress blocks using the specified compression algorithm.  This</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">parameter can be changed dynamically.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: kSnappyCompression, which gives lightweight but fast</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">compression.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">~200-500MB/s compression</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">~400-800MB/s decompression</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note that these speeds are significantly faster than most</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">persistent storage speeds, and therefore it is typically never</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">worth switching to kNoCompression.  Even if the input data is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">incompressible, the kSnappyCompression implementation will</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">efficiently detect that and will switch to uncompressed mode.</span>
  <span class="org-type">CompressionType</span> <span class="org-variable-name">compression</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21387;&#32553;&#31867;&#22411;.&#19981;&#21387;&#32553;&#21644;Snappy&#21387;&#32553;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create an Options object with default values for all fields.</span>
  <span class="org-function-name">Options</span>();
};
</pre>
</div>
</div></li>

<li><a id="orgheadline29"></a>ReadOptions<br  /><div class="outline-text-5" id="text-10-1-7-2">
<p>
和Options一样里面也都是控制字段.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Options that control read operations</span>
<span class="org-keyword">struct</span> <span class="org-type">ReadOptions</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">If true, all data read from underlying storage will be</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">verified against corresponding checksums.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: false</span>
  <span class="org-type">bool</span> <span class="org-variable-name">verify_checksums</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#26102;&#20505;&#36827;&#34892;checksum&#26657;&#39564;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Should the data read for this iteration be cached in memory?</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Callers may wish to set this field to false for bulk scans.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: true</span>
  <span class="org-type">bool</span> <span class="org-variable-name">fill_cache</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#38656;&#35201;&#20174;cache&#37324;&#38754;&#26597;&#25214;.&#22914;&#26524;&#26159;bulk scans&#30340;&#35805;&#37027;&#20040;&#35774;&#32622;false.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">If "snapshot" is non-NULL, read as of the supplied snapshot</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">(which must belong to the DB that is being read and which must</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">not have been released).  If "snapshot" is NULL, use an impliicit</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">snapshot of the state at the beginning of this read operation.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: NULL</span>
  <span class="org-keyword">const</span> <span class="org-type">Snapshot</span>* <span class="org-variable-name">snapshot</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23384;&#22312;Snapshot&#30340;&#35805;&#37027;&#20040;&#23601;&#22312;snapshot&#19978;&#38754;&#35835;&#21462;.</span>

  <span class="org-function-name">ReadOptions</span>()
      : verify_checksums(<span class="org-constant">false</span>),
        fill_cache(<span class="org-constant">true</span>),
        snapshot(<span class="org-constant">NULL</span>) {
  }
};
</pre>
</div>
</div></li>

<li><a id="orgheadline30"></a>WriteOptions<br  /><div class="outline-text-5" id="text-10-1-7-3">
<p>
和Options一样里面也都是控制字段.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Options that control write operations</span>
<span class="org-keyword">struct</span> <span class="org-type">WriteOptions</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">If true, the write will be flushed from the operating system</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">buffer cache (by calling WritableFile::Sync()) before the write</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">is considered complete.  If this flag is true, writes will be</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">slower.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If this flag is false, and the machine crashes, some recent</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">writes may be lost.  Note that if it is just the process that</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">crashes (i.e., the machine does not reboot), no writes will be</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">lost even if sync==false.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">In other words, a DB write with sync==false has similar</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">crash semantics as the "write()" system call.  A DB write</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">with sync==true has similar crash semantics to a "write()"</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">system call followed by "fsync()".</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Default: false</span>
  <span class="org-type">bool</span> <span class="org-variable-name">sync</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#27599;&#27425;&#20889;&#37117;&#38656;&#35201;fsync.</span>

  <span class="org-function-name">WriteOptions</span>()
      : sync(<span class="org-constant">false</span>) {
  }
};
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32"><span class="section-number-4">10.1.8</span> slice.h</h4>
<div class="outline-text-4" id="text-10-1-8">
<p>
leveldb里面的Slice对象是用来作为key使用的。内部实现非常简单，仅仅是存储二进制的指针和大小。
我们可能需要稍微注意一下slice对象的compare方法.首先按照最小长度比较，如果相等然后按照比较长度。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-constant">Slice</span>::<span class="org-function-name">compare</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">b</span>) <span class="org-keyword">const</span> {
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">min_len</span> = (size_ &lt; b.size_) ? size_ : b.size_;
  <span class="org-type">int</span> <span class="org-variable-name">r</span> = memcmp(data_, b.data_, min_len);
  <span class="org-keyword">if</span> (r == 0) {
    <span class="org-keyword">if</span> (size_ &lt; b.size_) r = -1;
    <span class="org-keyword">else</span> <span class="org-keyword">if</span> (size_ &gt; b.size_) r = +1;
  }
  <span class="org-keyword">return</span> r;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33"><span class="section-number-4">10.1.9</span> status.h</h4>
<div class="outline-text-4" id="text-10-1-9">
<p>
status就是一个非常简单的封装.内部持有一个char* status_;从注释里面可以看出如何安排的。
实现在util/status.cc里面，没有必要仔细阅读。不过我到觉得直接返回一个int就算了。
没有必要开辟char[].不过如果这个部分没有性能问题也就无所谓了。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Status</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a success status.</span>
  <span class="org-function-name">Status</span>() : state_(<span class="org-constant">NULL</span>) { }
  ~<span class="org-function-name">Status</span>() { <span class="org-keyword">delete</span>[] state_; }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Copy the specified status.</span>
  <span class="org-function-name">Status</span>(<span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">s</span>);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">s</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a success status.</span>
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">OK</span>() { <span class="org-keyword">return</span> Status(); }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return error status of an appropriate type.</span>
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">NotFound</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg2</span> = Slice()) {
    <span class="org-keyword">return</span> Status(kNotFound, msg, msg2);
  }
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">Corruption</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg2</span> = Slice()) {
    <span class="org-keyword">return</span> Status(kCorruption, msg, msg2);
  }
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">NotSupported</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg2</span> = Slice()) {
    <span class="org-keyword">return</span> Status(kNotSupported, msg, msg2);
  }
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">InvalidArgument</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg2</span> = Slice()) {
    <span class="org-keyword">return</span> Status(kInvalidArgument, msg, msg2);
  }
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">IOError</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg2</span> = Slice()) {
    <span class="org-keyword">return</span> Status(kIOError, msg, msg2);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true iff the status indicates success.</span>
  <span class="org-type">bool</span> <span class="org-function-name">ok</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> (state_ == <span class="org-constant">NULL</span>); }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true iff the status indicates a NotFound error.</span>
  <span class="org-type">bool</span> <span class="org-function-name">IsNotFound</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> code() == kNotFound; }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a string representation of this status suitable for printing.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns the string "OK" for success.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">ToString</span>() <span class="org-keyword">const</span>;

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">OK status has a NULL state_.  Otherwise, state_ is a new[] array</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">of the following form:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">state_[0..3] == length of message</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">state_[4]    == code</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">state_[5..]  == message</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">state_</span>;

  <span class="org-keyword">enum</span> <span class="org-type">Code</span> {
    <span class="org-variable-name">kOk</span> = 0,
    <span class="org-variable-name">kNotFound</span> = 1,
    <span class="org-variable-name">kCorruption</span> = 2,
    <span class="org-variable-name">kNotSupported</span> = 3,
    <span class="org-variable-name">kInvalidArgument</span> = 4,
    <span class="org-variable-name">kIOError</span> = 5
  };

  <span class="org-type">Code</span> <span class="org-function-name">code</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> (state_ == <span class="org-constant">NULL</span>) ? kOk : <span class="org-keyword">static_cast</span>&lt;Code&gt;(<span class="org-type">state_</span>[4]);
  }

  <span class="org-function-name">Status</span>(<span class="org-type">Code</span> <span class="org-variable-name">code</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">msg2</span>);
  <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">CopyState</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">s</span>);
};

<span class="org-keyword">inline</span> <span class="org-constant">Status</span>::<span class="org-function-name">Status</span>(<span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">s</span>) {
  state_ = (s.state_ == <span class="org-constant">NULL</span>) ? <span class="org-constant">NULL</span> : CopyState(s.state_);
}
<span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-constant">Status</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">s</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">The following condition catches both aliasing (when this == &amp;s),</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">and the common case where both s and *this are ok.</span>
  <span class="org-keyword">if</span> (state_ != s.state_) {
    <span class="org-keyword">delete</span>[] state_;
    state_ = (s.state_ == <span class="org-constant">NULL</span>) ? <span class="org-constant">NULL</span> : CopyState(s.state_);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-4">
<h4 id="orgheadline34"><span class="section-number-4">10.1.10</span> table_builder.h</h4>
<div class="outline-text-4" id="text-10-1-10">
<p>
TableBuilder用来帮助构建Table.而Table本身只是用来进行查询遍历等操作.用户在完成之后需要Finish或者是Abandon.
具体实现会在后面分析.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">TableBuilder</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a builder that will store the contents of the table it is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">building in *file.  Does not close the file.  It is up to the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">caller to close the file after calling Finish().</span>
  <span class="org-function-name">TableBuilder</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>, <span class="org-type">WritableFile</span>* <span class="org-variable-name">file</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20256;&#20837;options&#21644;&#21487;&#20889;&#25991;&#20214;(&#36861;&#21152;&#20889;&#27169;&#24335;)</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Either Finish() or Abandon() has been called.</span>
  ~<span class="org-function-name">TableBuilder</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Change the options used by this builder.  Note: only some of the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">option fields can be changed after construction.  If a field is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">not allowed to change dynamically and its value in the structure</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">passed to the constructor is different from its value in the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">structure passed to this method, this method will return an error</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">without changing any fields.</span>
  <span class="org-type">Status</span> <span class="org-function-name">ChangeOptions</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#26086;&#26500;&#24314;&#22909;&#20043;&#21518;&#21482;&#20801;&#35768;&#20462;&#25913;&#37096;&#20998;&#23383;&#27573;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add key,value to the table being constructed.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: key is after any previously added key according to comparator.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Finish(), Abandon() have not been called</span>
  <span class="org-type">void</span> <span class="org-function-name">Add</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28155;&#21152;kv</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Advanced operation: flush any buffered key/value pairs to file.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Can be used to ensure that two adjacent entries never live in</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the same data block.  Most clients should not need to use this method.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Finish(), Abandon() have not been called</span>
  <span class="org-type">void</span> <span class="org-function-name">Flush</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;buffered&#30340;kv&#21047;&#26032;&#21040;&#25991;&#20214;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return non-ok iff some error has been detected.</span>
  <span class="org-type">Status</span> <span class="org-function-name">status</span>() <span class="org-keyword">const</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Finish building the table.  Stops using the file passed to the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">constructor after this function returns.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Finish(), Abandon() have not been called</span>
  <span class="org-type">Status</span> <span class="org-function-name">Finish</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#24314;&#23436;&#25104;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Indicate that the contents of this builder should be abandoned.  Stops</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">using the file passed to the constructor after this function returns.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If the caller is not going to call Finish(), it must call Abandon()</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">before destroying this builder.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Finish(), Abandon() have not been called</span>
  <span class="org-type">void</span> <span class="org-function-name">Abandon</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25918;&#24323;&#26500;&#24314;&#30340;&#35805;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Number of calls to Add() so far.</span>
  <span class="org-type">uint64_t</span> <span class="org-function-name">NumEntries</span>() <span class="org-keyword">const</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#28155;&#21152;&#20102;&#22810;&#23569;&#27425;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Size of the file generated so far.  If invoked after a successful</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Finish() call, returns the size of the final generated file.</span>
  <span class="org-type">uint64_t</span> <span class="org-function-name">FileSize</span>() <span class="org-keyword">const</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#24050;&#32463;&#20889;&#20837;&#22810;&#23569;&#25991;&#20214;&#20102;.</span>

 <span class="org-keyword">private</span>:
  <span class="org-type">bool</span> <span class="org-function-name">ok</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> status().ok(); }
  <span class="org-type">void</span> <span class="org-function-name">WriteBlock</span>(<span class="org-type">BlockBuilder</span>* <span class="org-variable-name">block</span>, <span class="org-type">BlockHandle</span>* <span class="org-variable-name">handle</span>);

  <span class="org-keyword">struct</span> <span class="org-type">Rep</span>;
  <span class="org-type">Rep</span>* <span class="org-variable-name">rep_</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying allowed</span>
  <span class="org-function-name">TableBuilder</span>(<span class="org-keyword">const</span> <span class="org-type">TableBuilder</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">TableBuilder</span>&amp;);
};
</pre>
</div>
<p>
下面是一些比较重要的接口.
</p>
<ul class="org-ul">
<li>ChangeOptions // 修改选项</li>
<li>Add // 添加kv.k必须是有序</li>
<li>Flush // 刷新</li>
<li>Finish // 结束</li>
<li>Abandon // 放弃</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-4">
<h4 id="orgheadline35"><span class="section-number-4">10.1.11</span> table.h</h4>
<div class="outline-text-4" id="text-10-1-11">
<p>
Table就是持久化并且不可变的sortedtable.下面来看看接口.具体实现会在后面分析.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A Table is a sorted map from strings to strings.  Tables are</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">immutable and persistent.  A Table may be safely accessed from</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">multiple threads without external synchronization.</span>
<span class="org-keyword">class</span> <span class="org-type">Table</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to open the table that is stored in bytes [0..file_size)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">of "file", and read the metadata entries necessary to allow</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">retrieving data from the table.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If successful, returns ok and sets "*table" to the newly opened</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">table.  The client should delete "*table" when no longer needed.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If there was an error while initializing the table, sets "*table"</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to NULL and returns a non-ok status.  Does not take ownership of</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"*source", but the client must ensure that "source" remains live</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">for the duration of the returned table's lifetime.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">*file must remain live while this Table is in use.</span>
  <span class="org-keyword">static</span> <span class="org-type">Status</span> <span class="org-function-name">Open</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>,
                     <span class="org-type">RandomAccessFile</span>* <span class="org-variable-name">file</span>,
                     <span class="org-type">uint64_t</span> <span class="org-variable-name">file_size</span>,
                     <span class="org-type">Table</span>** <span class="org-variable-name">table</span>);

  ~<span class="org-function-name">Table</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns a new iterator over the table contents.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The result of NewIterator() is initially invalid (caller must</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">call one of the Seek methods on the iterator before using it).</span>
  Iterator* NewIterator(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp;) <span class="org-keyword">const</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Given a key, return an approximate byte offset in the file where</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the data for that key begins (or would begin if the key were</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">present in the file).  The returned value is in terms of file</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bytes, and so includes effects like compression of the underlying data.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">E.g., the approximate offset of the last key in the table will</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">be close to the file length.</span>
  <span class="org-type">uint64_t</span> <span class="org-function-name">ApproximateOffsetOf</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span>;

 <span class="org-keyword">private</span>:
  <span class="org-keyword">struct</span> <span class="org-type">Rep</span>;
  <span class="org-type">Rep</span>* <span class="org-variable-name">rep_</span>;

  <span class="org-keyword">explicit</span> <span class="org-function-name">Table</span>(<span class="org-type">Rep</span>* <span class="org-variable-name">rep</span>) { rep_ = rep; }
  <span class="org-keyword">static</span> <span class="org-type">Iterator</span>* <span class="org-function-name">BlockReader</span>(<span class="org-type">void</span>*, <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp;, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp;);

  <span class="org-comment-delimiter">// </span><span class="org-comment">No copying allowed</span>
  <span class="org-function-name">Table</span>(<span class="org-keyword">const</span> <span class="org-type">Table</span>&amp;);
  <span class="org-type">void</span> <span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">Table</span>&amp;);
};
</pre>
</div>
<p>
主要提供的接口如下
</p>
<ul class="org-ul">
<li>Open. // 这个接口可以看出访问的是随机文件.</li>
<li>NewIterator // 创建一个迭代器.</li>
<li>ApproximateOffsetOf // 可以通过key查找到大致位置然后后续可以发起读操作.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline36" class="outline-4">
<h4 id="orgheadline36"><span class="section-number-4">10.1.12</span> write_batch.h</h4>
<div class="outline-text-4" id="text-10-1-12">
<p>
WriteBatch用来持有批量写入的内容.注意底层实现有Handler是需要具体实现的。关于这个具体实现部分会在后面分析.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">WriteBatch</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">WriteBatch</span>();
  ~<span class="org-function-name">WriteBatch</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Store the mapping "key-&gt;value" in the database.</span>
  <span class="org-type">void</span> <span class="org-function-name">Put</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">If the database contains a mapping for "key", erase it.  Else do nothing.</span>
  <span class="org-type">void</span> <span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Clear all updates buffered in this batch.</span>
  <span class="org-type">void</span> <span class="org-function-name">Clear</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Support for iterating over the contents of a batch.</span>
  <span class="org-keyword">class</span> <span class="org-type">Handler</span> {
   <span class="org-keyword">public</span>:
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">Handler</span>();
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Put</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) = 0;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) = 0;
  };
  <span class="org-type">Status</span> <span class="org-function-name">Iterate</span>(<span class="org-type">Handler</span>* <span class="org-variable-name">handler</span>) <span class="org-keyword">const</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38405;&#35835;&#21518;&#38754;&#20250;&#21457;&#29616;&#65292;&#36825;&#20010;&#24847;&#24605;&#26159;&#36941;&#21382;&#25152;&#26377;&#30340;WriteBatch&#37324;&#38754;&#30340;item</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#25805;&#20316;handler.handler&#21487;&#33021;&#26159;&#19968;&#20010;memtable.&#36825;&#26679;&#21487;&#20197;&#23558;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23481;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20840;&#37096;&#23384;&#25918;&#21040;memtable&#37324;&#38754;&#21435;.</span>

 <span class="org-keyword">private</span>:
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">WriteBatchInternal</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24213;&#23618;&#23454;&#29616;&#26159;&#36825;&#20010;.</span>

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">rep_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">See comment in write_batch.cc for the format of rep_ // &#23558;&#25152;&#26377;&#30340;&#25805;&#20316;&#35831;&#27714;&#20570;&#25104;&#20108;&#36827;&#21046;&#23384;&#25918;&#22312;rep_</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Intentionally copyable</span>
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-3">
<h3 id="orgheadline38"><span class="section-number-3">10.2</span> Implementation</h3>
<div class="outline-text-3" id="text-10-2">
<p>
实现部分我按照功能划分了几个部分.
</p>
<ul class="org-ul">
<li>DB</li>
<li>Posix</li>
<li>Cache</li>
<li>Batch</li>
<li>Log</li>
<li>Table</li>
<li>Util</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline164" class="outline-3">
<h3 id="orgheadline164"><span class="section-number-3">10.3</span> DB</h3>
<div class="outline-text-3" id="text-10-3">
</div><div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39"><span class="section-number-4">10.3.1</span> FileName</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
db/filename.cc 这里面都是关于文件名称操作的方法.文件包括
</p>
<ul class="org-ul">
<li>db/CURRENT // 当前文件</li>
<li>db/LOCK // DB锁文件</li>
<li>db/LOG // info log.日志文件.</li>
<li>db/LOG.old // info log.日志文件.</li>
<li>db/MANIFEST-[0-9]+ // 描述文件</li>
<li>db/[0-9]+.log // db日志文件</li>
<li>db/[0-9]+.sst // dbtable文件</li>
<li>db/[0-9]+.dbtmp // db临时文件</li>
</ul>
<p>
这里[0-9]+都表示一个sequence number.这里还有另外一个不是操作FileName的函数.SetCurrentFile
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-function-name">SetCurrentFile</span>(<span class="org-type">Env</span>* <span class="org-variable-name">env</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>,
                      <span class="org-type">uint64_t</span> <span class="org-variable-name">descriptor_number</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Remove leading "dbname/" and add newline to manifest file name</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">manifest</span> = DescriptorFileName(dbname, descriptor_number);
  <span class="org-type">Slice</span> <span class="org-variable-name">contents</span> = manifest;
  assert(contents.starts_with(dbname + <span class="org-string">"/"</span>));
  contents.remove_prefix(dbname.size() + 1);
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">tmp</span> = TempFileName(dbname, descriptor_number);
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = WriteStringToFile(env, contents.ToString() + <span class="org-string">"\n"</span>, tmp);
  <span class="org-keyword">if</span> (s.ok()) {
    s = env-&gt;RenameFile(tmp, CurrentFileName(dbname));
  }
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
    env-&gt;DeleteFile(tmp);
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
<p>
就是将MANIFEST-%(descriptor_number)llu+"\n"写入到.dbtmp下面去然后rename成为CURRENT文件.
</p>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-4">
<h4 id="orgheadline40"><span class="section-number-4">10.3.2</span> Config</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
db/dbformat.h config下面是一些静态常数.这里可以仔细看看.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Grouping of constants.  We may want to make some of these</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">parameters set via options.</span>
<span class="org-keyword">namespace</span> <span class="org-constant">config</span> {
<span class="org-comment-delimiter">// </span><span class="org-comment">leveldb&#26368;&#22823;level&#22810;&#23569;.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kNumLevels</span> = 7;

<span class="org-comment-delimiter">// </span><span class="org-comment">Level-0 compaction is started when we hit this many files.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">level0&#25991;&#20214;&#36229;&#36807;&#22810;&#23569;&#20010;&#35302;&#21457;compaction.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kL0_CompactionTrigger</span> = 4;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#38754;&#20004;&#20010;&#21487;&#20197;&#22312;MakeRoomForWrite&#37324;&#38754;&#30475;&#21040;.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Soft limit on number of level-0 files.  We slow down writes at this point.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;level0&#25991;&#20214;&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#35805;&#37027;&#20040;&#21487;&#33021;&#20250;&#25918;&#32531;memtable&#20889;&#20026;level0&#30340;&#36895;&#24230;.&#27604;&#22914;delay 1s&#21861;&#30340;.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kL0_SlowdownWritesTrigger</span> = 8;

<span class="org-comment-delimiter">// </span><span class="org-comment">Maximum number of level-0 files.  We stop writes at this point.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;level0&#25991;&#20214;&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#35805;&#37027;&#19981;&#20250;memtable&#20889;&#20026;level0.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kL0_StopWritesTrigger</span> = 12;

<span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;memtable&#36827;&#34892;compaction&#30340;&#35805;&#36873;&#25321;&#30340;&#26368;&#39640;level.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#21487;&#20197;&#22312;PickLevelForMemtableOutput&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Maximum level to which a new compacted memtable is pushed if it</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">does not create overlap.  We try to push to level 2 to avoid the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">relatively expensive level 0=&gt;1 compactions and to avoid some</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">expensive manifest file operations.  We do not push all the way to</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the largest level since that can generate a lot of wasted disk</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">space if the same key space is being repeatedly overwritten.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kMaxMemCompactLevel</span> = 2;

}  <span class="org-comment-delimiter">// </span><span class="org-comment">namespace config</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline74" class="outline-4">
<h4 id="orgheadline74"><span class="section-number-4">10.3.3</span> DBImpl</h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
db/db_impl.cc DBImpl这个结构体挺大的。我们先过一个这个结构然后仔细看看每个字段是什么
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">DBImpl</span> : <span class="org-keyword">public</span> <span class="org-type">DB</span> {
 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Constant after construction</span>
  <span class="org-type">Env</span>* <span class="org-keyword">const</span> <span class="org-variable-name">env_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29615;&#22659;.</span>
  <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span> <span class="org-variable-name">internal_comparator_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20869;&#37096;&#27604;&#36739;&#22120;.</span>
  <span class="org-keyword">const</span> <span class="org-type">Options</span> <span class="org-variable-name">options_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">options_.comparator == &amp;internal_comparator_ // &#36873;&#39033;.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">owns_info_log_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#33258;&#24049;&#20998;&#37197;&#30340;log.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">owns_cache_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#33258;&#24049;&#20998;&#37197;&#30340;cache.</span>
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">dbname_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">db&#21517;&#31216;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">table_cache_ provides its own synchronization</span>
  <span class="org-type">TableCache</span>* <span class="org-variable-name">table_cache_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">TableCache.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Lock over the persistent DB state.  Non-NULL iff successfully acquired.</span>
  <span class="org-type">FileLock</span>* <span class="org-variable-name">db_lock_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">db FileLock. // &#23545;&#20110;&#22806;&#37096;&#36827;&#31243;&#26631;&#35760;DB&#23545;&#35937;&#20114;&#26021;&#38145;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">State below is protected by mutex_</span>
  <span class="org-constant">port</span>::<span class="org-type">Mutex</span> <span class="org-variable-name">mutex_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25972;&#20010;DB&#23545;&#35937;&#20114;&#26021;&#38145;.</span>
  <span class="org-constant">port</span>::<span class="org-type">AtomicPointer</span> <span class="org-variable-name">shutting_down_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26631;&#35760;&#36825;&#20010;DB&#23545;&#35937;&#27491;&#22312;&#36864;&#20986;&#12290;&#21518;&#21488;&#32447;&#31243;&#25110;&#30475;&#21040;&#20043;&#21518;&#19981;&#24212;&#35813;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;&#12290;</span>
  <span class="org-constant">port</span>::<span class="org-type">CondVar</span> <span class="org-variable-name">bg_cv_</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">Signalled when background work finishes</span>
  <span class="org-type">MemTable</span>* <span class="org-variable-name">mem_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27491;&#22312;&#25805;&#20316;&#30340;memtable.</span>
  <span class="org-type">MemTable</span>* <span class="org-variable-name">imm_</span>;                <span class="org-comment-delimiter">// </span><span class="org-comment">Memtable being compacted.&#27491;&#22312;&#34987;compacted&#30340;memtable</span>
  <span class="org-constant">port</span>::<span class="org-type">AtomicPointer</span> <span class="org-variable-name">has_imm_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">So bg thread can detect non-NULL imm_</span>
  <span class="org-type">WritableFile</span>* <span class="org-variable-name">logfile_</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">logfile_number_</span>;
  <span class="org-constant">log</span>::<span class="org-type">Writer</span>* <span class="org-variable-name">log_</span>;
  <span class="org-type">LoggerId</span>* <span class="org-variable-name">logger_</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">NULL, or the id of the current logging thread</span>
  <span class="org-constant">port</span>::<span class="org-type">CondVar</span> <span class="org-variable-name">logger_cv_</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">For threads waiting to log.&#21644;mutex_&#20851;&#32852;.</span>
  <span class="org-type">SnapshotList</span> <span class="org-variable-name">snapshots_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#25152;&#26377;&#30340;snapshot</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Set of table files to protect from deletion because they are</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">part of ongoing compactions.</span>
  <span class="org-constant">std</span>::<span class="org-type">set</span>&lt;<span class="org-type">uint64_t</span>&gt; <span class="org-variable-name">pending_outputs_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27491;&#22312;&#36755;&#20986;&#25110;&#32773;&#26159;&#36827;&#34892;compaction&#30340;file.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20445;&#23384;&#36825;&#20010;&#20449;&#24687;&#30340;&#35805;&#36825;&#26679;&#22312;delete&#25991;&#20214;&#30340;&#25918;&#32622;&#19981;&#34987;&#21024;&#38500;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Has a background compaction been scheduled or is running?</span>
  <span class="org-type">bool</span> <span class="org-variable-name">bg_compaction_scheduled_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#21488;&#32447;&#31243;&#26159;&#21542;&#22312;&#36816;&#34892;.&#36824;&#26159;&#21487;&#20197;&#36864;&#20986;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Information for a manual compaction</span>
  <span class="org-keyword">struct</span> <span class="org-type">ManualCompaction</span> {
    <span class="org-type">int</span> <span class="org-variable-name">level</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">done</span>;
    <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>* <span class="org-variable-name">begin</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">NULL means beginning of key range</span>
    <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>* <span class="org-variable-name">end</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">NULL means end of key range</span>
    <span class="org-type">InternalKey</span> <span class="org-variable-name">tmp_storage</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">Used to keep track of compaction progress</span>
  };
  <span class="org-type">ManualCompaction</span>* <span class="org-variable-name">manual_compaction_</span>;

  <span class="org-type">VersionSet</span>* <span class="org-variable-name">versions_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29256;&#26412;&#38598;&#21512;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Have we encountered a background error in paranoid mode?</span>
  <span class="org-type">Status</span> <span class="org-variable-name">bg_error_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#21488;&#32447;&#31243;&#36816;&#34892;&#29366;&#24577;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Per level compaction stats.  stats_[level] stores the stats for</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">compactions that produced data for the specified "level".</span>
  <span class="org-keyword">struct</span> <span class="org-type">CompactionStats</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21387;&#32553;&#29366;&#24577;&#20449;&#24687;.</span>
    <span class="org-type">int64_t</span> <span class="org-variable-name">micros</span>;
    <span class="org-type">int64_t</span> <span class="org-variable-name">bytes_read</span>;
    <span class="org-type">int64_t</span> <span class="org-variable-name">bytes_written</span>;

    <span class="org-function-name">CompactionStats</span>() : micros(0), bytes_read(0), bytes_written(0) { }

    <span class="org-type">void</span> <span class="org-function-name">Add</span>(<span class="org-keyword">const</span> <span class="org-type">CompactionStats</span>&amp; <span class="org-variable-name">c</span>) {
      <span class="org-keyword">this</span>-&gt;micros += c.micros;
      <span class="org-keyword">this</span>-&gt;bytes_read += c.bytes_read;
      <span class="org-keyword">this</span>-&gt;bytes_written += c.bytes_written;
    }
  };
  <span class="org-type">CompactionStats</span> <span class="org-variable-name">stats_</span>[<span class="org-constant">config</span>::kNumLevels]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21508;&#20010;&#32423;&#21035;&#30340;&#21387;&#32553;&#29366;&#24577;&#20449;&#24687;.</span>
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline41"></a>Open<br  /><div class="outline-text-5" id="text-10-3-3-1">
<p>
在Interface部分的db.h里面可以知道构造这个DB对象是通过DB::Open来构造的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DB</span>::<span class="org-function-name">Open</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>,
                <span class="org-type">DB</span>** <span class="org-variable-name">dbptr</span>) {
  *dbptr = <span class="org-constant">NULL</span>;

  <span class="org-type">DBImpl</span>* <span class="org-variable-name">impl</span> = <span class="org-keyword">new</span> <span class="org-type">DBImpl</span>(options, dbname); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;DBImpl&#23454;&#20363;.</span>
  impl-&gt;mutex_.Lock(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20284;&#20046;&#27809;&#26377;&#22826;&#22823;&#24517;&#35201;.&#36825;&#37324;&#24212;&#35813;&#27809;&#26377;&#31454;&#20105;.</span>
  <span class="org-type">VersionEdit</span> <span class="org-variable-name">edit</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22238;&#22797;&#33258;&#19978;&#27425;&#20381;&#36182;&#30340;edit&#25152;&#26377;&#20869;&#23481;.&#28982;&#21518;&#22312;&#21518;&#38754;&#30452;&#25509;log and apply&#36825;&#20010;edit&#23545;&#35937;.</span>
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = impl-&gt;Recover(&amp;edit); <span class="org-comment-delimiter">// </span><span class="org-comment">Handles create_if_missing, error_if_exists</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#38754;&#27599;&#20010;&#27493;&#39588;&#22823;&#33268;&#19978;&#37117;&#24456;&#28165;&#26970;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#21019;&#24314;&#26032;&#30340;log&#25991;&#20214;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">2.&#22238;&#25918;&#21407;&#26469;log&#20449;&#24687;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">3.&#21024;&#38500;&#19981;&#24517;&#35201;&#30340;&#25991;&#20214;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">4.&#36827;&#34892;compaction.</span>
  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-type">uint64_t</span> <span class="org-variable-name">new_log_number</span> = impl-&gt;versions_-&gt;NewFileNumber();
    <span class="org-type">WritableFile</span>* <span class="org-variable-name">lfile</span>;
    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),
                                     &amp;lfile);
    <span class="org-keyword">if</span> (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl-&gt;logfile_ = lfile;
      impl-&gt;logfile_number_ = new_log_number;
      impl-&gt;log_ = <span class="org-keyword">new</span> <span class="org-constant">log</span>::<span class="org-type">Writer</span>(lfile);
      s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);
    }
    <span class="org-keyword">if</span> (s.ok()) {
      impl-&gt;DeleteObsoleteFiles();
      impl-&gt;MaybeScheduleCompaction();
    }
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#20135;&#29983;&#30340;DB&#23545;&#35937;&#36820;&#22238;.</span>
  impl-&gt;mutex_.Unlock();
  <span class="org-keyword">if</span> (s.ok()) {
    *dbptr = impl;
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">delete</span> impl;
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline42"></a>DBImpl<br  /><div class="outline-text-5" id="text-10-3-3-2">
<p>
先看看构造函数
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">DBImpl</span>::<span class="org-function-name">DBImpl</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>)
    : env_(options.env),
      internal_comparator_(options.comparator),
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#30340;&#39034;&#24207;.&#24517;&#39035;&#20808;&#35843;&#29992;SanitizeOptions.</span>
      options_(SanitizeOptions(dbname, &amp;internal_comparator_, options)),
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#26159;&#21542;&#33258;&#24049;&#25345;&#26377;info log&#21644;block cache.</span>
      owns_info_log_(options_.info_log != options.info_log),
      owns_cache_(options_.block_cache != options.block_cache),
      dbname_(dbname),
      db_lock_(<span class="org-constant">NULL</span>),
      shutting_down_(<span class="org-constant">NULL</span>),
      bg_cv_(&amp;mutex_),
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#26032;&#30340;MemTable&#23545;&#35937;.</span>
      mem_(<span class="org-keyword">new</span> <span class="org-type">MemTable</span>(internal_comparator_)),
      imm_(<span class="org-constant">NULL</span>),
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;log&#37117;&#26159;&#25351;db&#30340;log&#32780;&#19981;&#26159;&#31243;&#24207;log.</span>
      logfile_(<span class="org-constant">NULL</span>),
      logfile_number_(0),
      log_(<span class="org-constant">NULL</span>),
      logger_(<span class="org-constant">NULL</span>),
      logger_cv_(&amp;mutex_),
      bg_compaction_scheduled_(<span class="org-constant">false</span>),
      manual_compaction_(<span class="org-constant">NULL</span>) {
  mem_-&gt;Ref();
  has_imm_.Release_Store(<span class="org-constant">NULL</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Reserve ten files or so for other uses and give the rest to TableCache.</span>
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">table_cache_size</span> = options.max_open_files - 10;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#25991;&#20214;&#25551;&#36848;&#31526;&#38480;&#21046;&#21487;&#20197;&#36890;&#36807;TableCache&#26469;&#23436;&#25104;.&#19981;&#38169;:).</span>
  table_cache_ = <span class="org-keyword">new</span> <span class="org-type">TableCache</span>(dbname_, &amp;options_, table_cache_size);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;VersionSet.</span>
  versions_ = <span class="org-keyword">new</span> <span class="org-type">VersionSet</span>(dbname_, &amp;options_, table_cache_,
                             &amp;internal_comparator_);
}
</pre>
</div>

<p>
然后看看析构函数
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">DBImpl</span>::~<span class="org-function-name">DBImpl</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Wait for background work to finish</span>
  mutex_.Lock();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;shuting down&#26631;&#35760;.&#21518;&#21488;&#32447;&#31243;&#31561;&#24453;&#26631;&#35760;&#36864;&#20986;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#24453;bg_compaction_scheduled_&#32622;&#20301;&#65292;&#36825;&#26679;bg&#32447;&#31243;&#23601;&#36864;&#20986;&#20102;&#12290;</span>
  shutting_down_.Release_Store(<span class="org-keyword">this</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">Any non-NULL value is ok</span>
  <span class="org-keyword">while</span> (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#37322;&#25918;db&#38145;&#25991;&#20214;.</span>
  <span class="org-keyword">if</span> (db_lock_ != <span class="org-constant">NULL</span>) {
    env_-&gt;UnlockFile(db_lock_);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;VersionSet.</span>
  <span class="org-keyword">delete</span> versions_;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#37322;&#25918;&#24341;&#29992;&#35745;&#25968;</span>
  <span class="org-keyword">if</span> (mem_ != <span class="org-constant">NULL</span>) mem_-&gt;Unref();
  <span class="org-keyword">if</span> (imm_ != <span class="org-constant">NULL</span>) imm_-&gt;Unref();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#21487;&#33021;&#20135;&#29983;&#30340;log,logfile&#20197;&#21450;table_cache.</span>
  <span class="org-keyword">delete</span> log_;
  <span class="org-keyword">delete</span> logfile_;
  <span class="org-keyword">delete</span> table_cache_;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#37322;&#25918;&#31243;&#24207;log&#20197;&#21450;cache.</span>
  <span class="org-keyword">if</span> (owns_info_log_) {
    <span class="org-keyword">delete</span> options_.info_log;
  }
  <span class="org-keyword">if</span> (owns_cache_) {
    <span class="org-keyword">delete</span> options_.block_cache;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline43"></a>NewDB<br  /><div class="outline-text-5" id="text-10-3-3-3">
<p>
但从名字上我们不知道里面做了哪些事情，所以还是来看看代码.
通过代码阅读会发现，完成的事情大致就是建立一个Manifest文件，然后将这个版本的Manifest文件
的文件名作为内容写入CURRENT文件。Manifest文件里面包含的就是VersionEdit信息。VersionEdit
可以认为就是这个数据库的元信息。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">NewDB</span>() {
  <span class="org-type">VersionEdit</span> <span class="org-variable-name">new_db</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#26032;&#30340;VersionEdit.&#35774;&#32622;&#22909;comparator&#30340;&#21517;&#23383;&#20197;&#21450;&#24517;&#35201;&#23383;&#27573;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20851;&#20110;VersionEdit&#30340;&#20449;&#24687;&#20250;&#22312;&#21518;&#38754;&#20180;&#32454;&#20998;&#26512;.</span>
  new_db.SetComparatorName(user_comparator()-&gt;Name());
  new_db.SetLogNumber(0); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;log number&#20174;0&#24320;&#22987;&#20998;&#37197;.</span>
  new_db.SetNextFile(2);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#19968;&#20010;number&#20174;2&#24320;&#22987;&#20998;&#37197;</span>
  new_db.SetLastSequence(0);

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#26032;&#30340;Manifest&#25991;&#20214;.&#28982;&#21518;&#20316;&#20026;writable&#25991;&#20214;&#25171;&#24320;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">1&#20998;&#37197;&#32473;manifest&#25991;&#20214;.</span>
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">manifest</span> = DescriptorFileName(dbname_, 1);
  <span class="org-type">WritableFile</span>* <span class="org-variable-name">file</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = env_-&gt;NewWritableFile(manifest, &amp;file);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
    <span class="org-keyword">return</span> s;
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25991;&#20214;&#20316;&#20026;log&#26684;&#24335;&#25171;&#24320;.&#23558;VersionEdit&#24207;&#21015;&#21270;&#20043;&#21518;&#20316;&#20026;log&#20889;&#20837;.</span>
  {
    <span class="org-constant">log</span>::<span class="org-type">Writer</span> <span class="org-variable-name">log</span>(file);
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">record</span>;
    new_db.EncodeTo(&amp;record);
    s = log.AddRecord(record);
    <span class="org-keyword">if</span> (s.ok()) {
      s = file-&gt;Close();
    }
  }
  <span class="org-keyword">delete</span> file;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;CURRENT&#37324;&#38754;&#30340;&#25991;&#20214;&#35774;&#32622;&#20026;&#29256;&#26412;1&#30340;manifest&#25991;&#20214;.</span>
  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Make "CURRENT" file that points to the new manifest file.</span>
    s = SetCurrentFile(env_, dbname_, 1);
  } <span class="org-keyword">else</span> {
    env_-&gt;DeleteFile(manifest);
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline44"></a>Recover<br  /><div class="outline-text-5" id="text-10-3-3-4">
<p>
恢复状态并且将恢复对于version日志操作.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">Recover</span>(<span class="org-type">VersionEdit</span>* <span class="org-variable-name">edit</span>) {
  mutex_.AssertHeld();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Ignore error from CreateDir since the creation of the DB is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">committed only when the descriptor is created, and this directory</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">may already exist from a previous failed creation attempt.</span>
  env_-&gt;CreateDir(dbname_);
  assert(db_lock_ == <span class="org-constant">NULL</span>);
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
    <span class="org-keyword">return</span> s;
  }

  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>env_-&gt;FileExists(CurrentFileName(dbname_))) {
    <span class="org-keyword">if</span> (options_.create_if_missing) {
      s = NewDB(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;DB.</span>
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
        <span class="org-keyword">return</span> s;
      }
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">return</span> <span class="org-constant">Status</span>::InvalidArgument(
          dbname_, <span class="org-string">"does not exist (create_if_missing is false)"</span>);
    }
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">if</span> (options_.error_if_exists) {
      <span class="org-keyword">return</span> <span class="org-constant">Status</span>::InvalidArgument(
          dbname_, <span class="org-string">"exists (error_if_exists is true)"</span>);
    }
  }

  s = versions_-&gt;Recover(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;VersionSet&#39318;&#20808;&#36827;&#34892;&#24674;&#22797;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24674;&#22797;&#20043;&#21518;,&#26681;&#25454;&#37324;&#38754;&#30340;&#20869;&#23481;&#28982;&#21518;&#35835;&#21462;&#37324;&#38754;&#23545;&#24212;&#30340;version edit&#20869;&#23481;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36807;&#20174;versionset&#30340;Recover&#26041;&#27861;&#26469;&#30475;&#30340;&#35805;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23481;&#24050;&#32463;&#20840;&#37096;&#24674;&#22797;&#20102;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#38754;edit&#30340;&#20869;&#23481;&#26159;&#22240;&#20026;&#22312;&#24674;&#22797;log&#37324;&#38754;&#30340;&#20869;&#23481;&#36896;&#25104;&#30340;.&#28982;&#21518;&#23558;&#36825;&#20010;&#37096;&#20998;&#36896;&#25104;&#30340;edit</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20043;&#21518;&#35843;&#29992;LogAndApply.</span>
  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-type">SequenceNumber</span> <span class="org-variable-name">max_sequence</span>(0);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Recover from all newer log files than the ones named in the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">descriptor (new log files may have been added by the previous</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">incarnation without registering them in the descriptor).</span>
    <span class="org-comment-delimiter">//</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note that PrevLogNumber() is no longer used, but we pay</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">attention to it in case we are recovering a database</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">produced by an older version of leveldb.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#27880;&#37322;&#36825;&#37324;&#30475;&#20197;&#30475;&#20986;prev_log&#24050;&#32463;&#19981;&#36866;&#29992;&#20102;.</span>
    <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">min_log</span> = versions_-&gt;LogNumber();
    <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">prev_log</span> = versions_-&gt;PrevLogNumber();
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::string&gt; <span class="org-variable-name">filenames</span>;
    s = env_-&gt;GetChildren(dbname_, &amp;filenames);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
      <span class="org-keyword">return</span> s;
    }
    <span class="org-type">uint64_t</span> <span class="org-variable-name">number</span>;
    <span class="org-type">FileType</span> <span class="org-variable-name">type</span>;
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">uint64_t</span>&gt; <span class="org-variable-name">logs</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#26512;logs&#25991;&#20214;&#28982;&#21518;&#21028;&#26029;&#21738;&#20123;log&#25991;&#20214;&#26159;&#21518;&#26469;&#36861;&#21152;&#25105;&#20204;&#38656;&#35201;&#37325;&#25918;&#30340;.</span>
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; filenames.size(); i++) {
      <span class="org-keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)
          &amp;&amp; type == kLogFile
          &amp;&amp; ((number &gt;= min_log) || (number == prev_log))) {
        logs.push_back(number);
      }
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Recover in the order in which the logs were generated</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#29031;&#39034;&#24207;&#36827;&#34892;&#37325;&#25918;.</span>
    <span class="org-constant">std</span>::sort(logs.begin(), logs.end());
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; logs.size(); i++) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#24674;&#22797;&#26576;&#20010;log&#25991;&#20214;.&#24182;&#19988;&#23558;&#37324;&#38754;&#30340;&#25805;&#20316;&#20462;&#25913;&#22635;&#20889;&#21040;edit</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#26102;&#30693;&#36947;&#24403;&#21069;&#26368;&#22823;&#30340;sequence&#26159;&#22810;&#23569;.</span>
      s = RecoverLogFile(logs[i], edit, &amp;max_sequence);

      <span class="org-comment-delimiter">// </span><span class="org-comment">The previous incarnation may not have written any MANIFEST</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">records after allocating this log number.  So we manually</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">update the file number allocation counter in VersionSet.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#26631;&#35760;file number&#24050;&#32463;&#34987;&#20351;&#29992;&#20102;.</span>
      versions_-&gt;MarkFileNumberUsed(logs[i]);
    }

    <span class="org-keyword">if</span> (s.ok()) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;&#19968;&#19979;sequence number.</span>
      <span class="org-keyword">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) {
        versions_-&gt;SetLastSequence(max_sequence);
      }
    }
  }

  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline45"></a>RecoverLogFile<br  /><div class="outline-text-5" id="text-10-3-3-5">
<p>
从单个log恢复写入的内容.并且根据log里面内容了解到对于version修改以及max_sequence.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">RecoverLogFile</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">log_number</span>,
                              <span class="org-type">VersionEdit</span>* <span class="org-variable-name">edit</span>,
                              <span class="org-type">SequenceNumber</span>* <span class="org-variable-name">max_sequence</span>) {
  <span class="org-keyword">struct</span> <span class="org-type">LogReporter</span> : <span class="org-keyword">public</span> <span class="org-constant">log</span>::<span class="org-constant">Reader</span>::<span class="org-type">Reporter</span> {
    <span class="org-type">Env</span>* <span class="org-variable-name">env</span>;
    <span class="org-type">Logger</span>* <span class="org-variable-name">info_log</span>;
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">fname</span>;
    <span class="org-type">Status</span>* <span class="org-variable-name">status</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">NULL if options_.paranoid_checks==false</span>
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Corruption</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>, <span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">s</span>) {
      Log(info_log, <span class="org-string">"%s%s: dropping %d bytes; %s"</span>,
          (<span class="org-keyword">this</span>-&gt;status == <span class="org-constant">NULL</span> ? <span class="org-string">"(ignoring error) "</span> : <span class="org-string">""</span>),
          fname, <span class="org-keyword">static_cast</span>&lt;<span class="org-type">int</span>&gt;(bytes), s.ToString().c_str());
      <span class="org-keyword">if</span> (<span class="org-keyword">this</span>-&gt;status != <span class="org-constant">NULL</span> &amp;&amp; <span class="org-keyword">this</span>-&gt;status-&gt;ok()) *<span class="org-keyword">this</span>-&gt;status = s;
    }
  };

  mutex_.AssertHeld();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#24320;&#26085;&#24535;&#25991;&#20214;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Open the log file</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">fname</span> = LogFileName(dbname_, log_number);
  <span class="org-type">SequentialFile</span>* <span class="org-variable-name">file</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">status</span> = env_-&gt;NewSequentialFile(fname, &amp;file);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>status.ok()) {
    MaybeIgnoreError(&amp;status);
    <span class="org-keyword">return</span> status;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896;reporter&#23545;&#35937;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create the log reader.</span>
  <span class="org-type">LogReporter</span> <span class="org-variable-name">reporter</span>;
  reporter.env = env_;
  reporter.info_log = options_.info_log;
  reporter.fname = fname.c_str();
  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="org-constant">NULL</span>);
  <span class="org-comment-delimiter">// </span><span class="org-comment">We intentially make log::Reader do checksumming even if</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">paranoid_checks==false so that corruptions cause entire commits</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to be skipped instead of propagating bad information (like overly</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">large sequence numbers).</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#26085;&#24535;&#25991;&#20214;.&#20570;&#26657;&#39564;&#24182;&#19988;&#20174;0&#20559;&#31227;&#24320;&#22987;&#35835;&#21462;.</span>
  <span class="org-constant">log</span>::<span class="org-type">Reader</span> <span class="org-variable-name">reader</span>(file, &amp;reporter, <span class="org-constant">true</span><span class="org-comment-delimiter">/*</span><span class="org-comment">checksum*/</span>,
                     0<span class="org-comment-delimiter">/*</span><span class="org-comment">initial_offset*/</span>);
  Log(options_.info_log, <span class="org-string">"Recovering log #%llu"</span>,
      (<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>) log_number);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Read all the records and add to a memtable</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">scratch</span>;
  <span class="org-type">Slice</span> <span class="org-variable-name">record</span>;
  <span class="org-type">WriteBatch</span> <span class="org-variable-name">batch</span>;
  <span class="org-type">MemTable</span>* <span class="org-variable-name">mem</span> = <span class="org-constant">NULL</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#26029;&#22320;&#35835;&#21462;</span>
  <span class="org-keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp;
         status.ok()) {
    <span class="org-keyword">if</span> (record.size() &lt; 12) {
      reporter.Corruption(
          record.size(), <span class="org-constant">Status</span>::Corruption(<span class="org-string">"log record too small"</span>));
      <span class="org-keyword">continue</span>;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">log&#37324;&#38754;&#37117;&#26159;write batch&#30340;&#20869;&#23481;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#20197;&#21487;&#20197;&#30452;&#25509;&#35774;&#32622;.</span>
    <span class="org-constant">WriteBatchInternal</span>::SetContents(&amp;batch, record);

    <span class="org-keyword">if</span> (mem == <span class="org-constant">NULL</span>) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;mem table.</span>
      mem = <span class="org-keyword">new</span> <span class="org-type">MemTable</span>(internal_comparator_);
      mem-&gt;Ref();
    }
    status = <span class="org-constant">WriteBatchInternal</span>::InsertInto(&amp;batch, mem);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#26085;&#24535;&#24674;&#22797;&#30340;&#35805;&#25105;&#20204;&#20063;&#21487;&#20197;&#36873;&#25321;&#24615;&#22320;&#36827;&#34892;status&#21028;&#26029;&#26816;&#26597;.</span>
    MaybeIgnoreError(&amp;status);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>status.ok()) {
      <span class="org-keyword">break</span>;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;sequence.</span>
    <span class="org-keyword">const</span> <span class="org-type">SequenceNumber</span> <span class="org-variable-name">last_seq</span> =
        <span class="org-constant">WriteBatchInternal</span>::Sequence(&amp;batch) +
        <span class="org-constant">WriteBatchInternal</span>::Count(&amp;batch) - 1;
    <span class="org-keyword">if</span> (last_seq &gt; *max_sequence) {
      *max_sequence = last_seq;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21344;&#29992;&#20869;&#23384;&#22823;&#20110;&#36825;&#20010;&#22823;&#23567;&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#20889;level0.</span>
    <span class="org-keyword">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) {
      status = WriteLevel0Table(mem, edit, <span class="org-constant">NULL</span>);
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>status.ok()) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Reflect errors immediately so that conditions like full</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">file-systems cause the DB::Open() to fail.</span>
        <span class="org-keyword">break</span>;
      }
      mem-&gt;Unref();
      mem = <span class="org-constant">NULL</span>;
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21097;&#19979;&#30340;&#20869;&#23384;&#25991;&#20214;&#20063;&#20250;&#20570;table.</span>
  <span class="org-keyword">if</span> (status.ok() &amp;&amp; mem != <span class="org-constant">NULL</span>) {
    status = WriteLevel0Table(mem, edit, <span class="org-constant">NULL</span>);
    <span class="org-comment-delimiter">// </span><span class="org-comment">Reflect errors immediately so that conditions like full</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">file-systems cause the DB::Open() to fail.</span>
  }

  <span class="org-keyword">if</span> (mem != <span class="org-constant">NULL</span>) mem-&gt;Unref();
  <span class="org-keyword">delete</span> file;
  <span class="org-keyword">return</span> status;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline46"></a>MaybeIgnoreError<br  /><div class="outline-text-5" id="text-10-3-3-6">
<p>
这个是在日志恢复部分是否进行错误恢复.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">MaybeIgnoreError</span>(<span class="org-type">Status</span>* <span class="org-variable-name">s</span>) <span class="org-keyword">const</span> {
  <span class="org-keyword">if</span> (s-&gt;ok() || options_.paranoid_checks) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">No change needed</span>
  } <span class="org-keyword">else</span> {
    Log(options_.info_log, <span class="org-string">"Ignoring error %s"</span>, s-&gt;ToString().c_str());
    *s = <span class="org-constant">Status</span>::OK();
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline47"></a>WriteLevel0Table<br  /><div class="outline-text-5" id="text-10-3-3-7">
<p>
将memtable写到level0.不过现在就实现来看的话不一定是写到level0.对于产生或者是删除的文件等
对于version的操作都会反映到edit里面
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">WriteLevel0Table</span>(<span class="org-type">MemTable</span>* <span class="org-variable-name">mem</span>, <span class="org-type">VersionEdit</span>* <span class="org-variable-name">edit</span>,
                                <span class="org-type">Version</span>* <span class="org-variable-name">base</span>) {
  mutex_.AssertHeld();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20250;&#38024;&#23545;&#36825;&#20010;&#25805;&#20316;&#36827;&#34892;&#35745;&#26102;.</span>
  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">start_micros</span> = env_-&gt;NowMicros();
  <span class="org-type">FileMetaData</span> <span class="org-variable-name">meta</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20135;&#29983;&#26032;&#30340;file number.</span>
  meta.number = versions_-&gt;NewFileNumber();
  <span class="org-comment-delimiter">//</span>
  pending_outputs_.insert(meta.number);
  <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span> = mem-&gt;NewIterator();
  Log(options_.info_log, <span class="org-string">"Level-0 table #%llu: started"</span>,
      (<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>) meta.number);

  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  {
    mutex_.Unlock();
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#20889;&#30913;&#30424;&#30340;&#26102;&#20505;&#27809;&#26377;&#24517;&#35201;&#21152;&#38145;.</span>
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);
    mutex_.Lock();
  }

  Log(options_.info_log, <span class="org-string">"Level-0 table #%llu: %lld bytes %s"</span>,
      (<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>) meta.number,
      (<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>) meta.file_size,
      s.ToString().c_str());
  <span class="org-keyword">delete</span> iter;
  pending_outputs_.erase(meta.number);


  <span class="org-comment-delimiter">// </span><span class="org-comment">Note that if file_size is zero, the file has been deleted and</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">should not be added to the manifest.</span>
  <span class="org-type">int</span> <span class="org-variable-name">level</span> = 0;
  <span class="org-keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; 0) {
    <span class="org-keyword">const</span> <span class="org-type">Slice</span> <span class="org-variable-name">min_user_key</span> = meta.smallest.user_key();
    <span class="org-keyword">const</span> <span class="org-type">Slice</span> <span class="org-variable-name">max_user_key</span> = meta.largest.user_key();
    <span class="org-keyword">if</span> (base != <span class="org-constant">NULL</span>) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23384;&#22312;base version&#30340;&#35805;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#20250;&#26681;&#25454;base version&#20197;&#21450;range&#26469;&#36873;&#25321;&#26032;&#30340;level&#36827;&#34892;&#24207;&#21015;&#21270;.</span>
      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);
    }
    edit-&gt;AddFile(level, meta.number, meta.file_size,
                  meta.smallest, meta.largest);
  }

  <span class="org-type">CompactionStats</span> <span class="org-variable-name">stats</span>;
  stats.micros = env_-&gt;NowMicros() - start_micros;
  stats.bytes_written = meta.file_size;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20462;&#25913;&#36825;&#20010;level&#30340;compaction&#25968;&#25454;.</span>
  stats_[level].Add(stats);
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline48"></a>Put<br  /><div class="outline-text-5" id="text-10-3-3-8">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">Put</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">o</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">val</span>) {
  <span class="org-keyword">return</span> <span class="org-constant">DB</span>::Put(o, key, val);
}
<span class="org-type">Status</span> <span class="org-constant">DB</span>::<span class="org-function-name">Put</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">opt</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) {
  <span class="org-type">WriteBatch</span> <span class="org-variable-name">batch</span>;
  batch.Put(key, value); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#20869;&#23481;&#20889;&#21040;WriteBatch&#37324;&#38754;.&#28982;&#21518;&#36890;&#36807;</span>
  <span class="org-keyword">return</span> Write(opt, &amp;batch); <span class="org-comment-delimiter">// </span><span class="org-comment">Write&#20889;&#20837;&#21040;db&#20869;&#37096;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline49"></a>Delete<br  /><div class="outline-text-5" id="text-10-3-3-9">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">options</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-keyword">return</span> <span class="org-constant">DB</span>::Delete(options, key);
}
<span class="org-type">Status</span> <span class="org-constant">DB</span>::<span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">opt</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-type">WriteBatch</span> <span class="org-variable-name">batch</span>;
  batch.Delete(key); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#21024;&#38500;&#20869;&#23481;&#20889;&#21040;WriteBatch&#37324;&#38754;&#65292;&#28982;&#21518;&#36890;&#36807;</span>
  <span class="org-keyword">return</span> Write(opt, &amp;batch); <span class="org-comment-delimiter">// </span><span class="org-comment">Write&#20889;&#20837;&#21040;db&#20869;&#37096;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline50"></a>LoggingResponsibility<br  /><div class="outline-text-5" id="text-10-3-3-10">
<p>
对于Log信息的打印的话确保每次只有一个实例在操作.这里logger_cv和mutex_关联起来的.可以看到
在调用AcquireLoggingResponsibility的地方之前都会加锁
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">There is at most one thread that is the current logger.  This call</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">waits until preceding logger(s) have finished and becomes the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">current logger.</span>
<span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">AcquireLoggingResponsibility</span>(<span class="org-type">LoggerId</span>* <span class="org-variable-name">self</span>) {
  <span class="org-keyword">while</span> (logger_ != <span class="org-constant">NULL</span>) {
    logger_cv_.Wait();
  }
  logger_ = self;
}
</pre>
</div>

<p>
而ReleaseLoggingResponsibility是释放logger的所有权.注意这里我们不会去主动操作解锁而是外部解锁。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">ReleaseLoggingResponsibility</span>(<span class="org-type">LoggerId</span>* <span class="org-variable-name">self</span>) {
  assert(logger_ == self);
  logger_ = <span class="org-constant">NULL</span>;
  logger_cv_.SignalAll();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline51"></a>MakeRoomForWrite<br  /><div class="outline-text-5" id="text-10-3-3-11">
<p>
仅仅从函数名称上面开不出到底是开辟什么空间.看看实现吧.代码里面可以分析出这个部分是存在compaction的.
我们这里稍微总结一下逻辑
</p>
<ul class="org-ul">
<li>如果允许delay的话并且level0文件数目超过slowdown的阈值的话，那么就会先尝试delay 1s.下次不会进行delay</li>
<li>如果不是force的话并且memtable空间允许的话那么直接返回</li>
<li>剩下的逻辑就是force出一个memtable了.那么这个时候必须进行compaction to level0.</li>
<li>先检查是否正在被memtable compaction.如果正在的话那么等待</li>
<li>然后查看level0文件数目是否过多.如果过多的话那么也等待</li>
<li>最后创建新的memtable以及logfile.将原来的memtable保存起来准备后台compaction</li>
<li>发起compaction.并且force=false.</li>
</ul>
<p>
按照性能角度出发的话，这种逻辑应该非常make sense.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: mutex_ is held</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: this thread is the current logger</span>
<span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">MakeRoomForWrite</span>(<span class="org-type">bool</span> <span class="org-variable-name">force</span>) {
  mutex_.AssertHeld();
  assert(logger_ != <span class="org-constant">NULL</span>);
  <span class="org-type">bool</span> <span class="org-variable-name">allow_delay</span> = <span class="org-negation-char">!</span>force; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#35774;&#32622;force&#30340;&#35805;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#31354;&#38388;&#19981;&#22815;&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#21457;&#36215;compaction&#25805;&#20316;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#31561;&#24453;compaction&#25805;&#20316;&#23436;&#25104;&#30475;&#31354;&#38388;&#26159;&#21542;&#36275;&#22815;.</span>
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21518;&#21488;&#23384;&#22312;&#38169;&#35823;&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;.</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>bg_error_.ok()) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">yield previous error</span>
      s = bg_error_;
      <span class="org-keyword">break</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (
        allow_delay &amp;&amp;
        versions_-&gt;NumLevelFiles(0) &gt;= <span class="org-constant">config</span>::kL0_SlowdownWritesTrigger) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">We are getting close to hitting a hard limit on the number of</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">L0 files.  Rather than delaying a single write by several</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">seconds when we hit the hard limit, start delaying each</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">individual write by 1ms to reduce latency variance.  Also,</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">this delay hands over some CPU to the compaction thread in</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">case it is sharing the same core as the writer.</span>
      mutex_.Unlock();
      env_-&gt;SleepForMicroseconds(1000); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24310;&#36831;1s&#26469;&#30475;level0&#25991;&#20214;&#20010;&#25968;.</span>
      allow_delay = <span class="org-constant">false</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Do not delay a single write more than once</span>
      mutex_.Lock();
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>force &amp;&amp;
               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;memtable&#20801;&#35768;&#20889;&#20837;&#30340;&#35805;&#37027;&#20040;&#27809;&#26377;&#20219;&#20309;&#38382;&#39064;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">There is room in current memtable</span>
      <span class="org-keyword">break</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (imm_ != <span class="org-constant">NULL</span>) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">We have filled up the current memtable, but the previous</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">one is still being compacted, so we wait.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">imm_&#24212;&#35813;&#26159;&#34920;&#31034;&#27491;&#22312;&#36827;&#34892;compact&#30340;memtable.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#25105;&#25285;&#24515;condition&#26159;&#36793;&#32536;&#35302;&#21457;&#32780;&#19981;&#26159;&#27700;&#24179;&#35302;&#21457;&#30340;&#35805;&#37027;&#20040;signal&#23601;&#20250;&#20002;&#22833;.</span>
      bg_cv_.Wait();
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (versions_-&gt;NumLevelFiles(0) &gt;= <span class="org-constant">config</span>::kL0_StopWritesTrigger) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">There are too many level-0 files.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">level0&#25991;&#20214;&#20010;&#25968;&#36807;&#22810;&#30340;&#35805;&#37027;&#20040;&#31561;&#24453;compaction&#30340;&#23436;&#25104;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">note:&#36825;&#20010;&#37096;&#20998;&#38750;&#24120;&#37325;&#35201;&#65292;&#36825;&#26679;&#21487;&#20197;&#38480;&#21046;&#20889;&#20837;&#36895;&#24230;&#20445;&#35777;&#31995;&#32479;balance.</span>
      Log(options_.info_log, <span class="org-string">"waiting...\n"</span>);
      bg_cv_.Wait();
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to switch to a new memtable and trigger compaction of old</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#35797;&#22270;&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;memtable&#29992;&#26469;&#20889;.&#21019;&#24314;memtable&#30340;&#35805;&#21516;&#26102;&#20063;&#21019;&#24314;&#19968;&#20010;log&#25991;&#20214;.</span>
      assert(versions_-&gt;PrevLogNumber() == 0);
      <span class="org-type">uint64_t</span> <span class="org-variable-name">new_log_number</span> = versions_-&gt;NewFileNumber();
      <span class="org-type">WritableFile</span>* <span class="org-variable-name">lfile</span> = <span class="org-constant">NULL</span>;
      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
        <span class="org-keyword">break</span>;
      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#38144;&#27585;&#21407;&#26469;&#30340;log&#25991;&#20214;b&#24182;&#19988;&#21019;&#24314;&#26032;&#30340;memtable.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;memtable&#23384;&#25918;&#22312;imm&#37324;&#38754;.&#21518;&#21488;&#24212;&#35813;&#26159;&#23558;imm&#36827;&#34892;compaction&#25110;&#32773;&#26159;level disk files&#20043;&#38388;&#36827;&#34892;compaction.</span>
      <span class="org-keyword">delete</span> log_;
      <span class="org-keyword">delete</span> logfile_;
      logfile_ = lfile;
      logfile_number_ = new_log_number;
      log_ = <span class="org-keyword">new</span> <span class="org-constant">log</span>::<span class="org-type">Writer</span>(lfile);
      imm_ = mem_; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#21407;&#26469;&#30340;mem_&#23384;&#25918;&#36215;&#26469;.</span>
      has_imm_.Release_Store(imm_); <span class="org-comment-delimiter">// </span><span class="org-comment">imm&#23384;&#22312;&#26631;&#35760;.</span>
      mem_ = <span class="org-keyword">new</span> <span class="org-type">MemTable</span>(internal_comparator_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26032;&#21019;&#24314;memtable.</span>
      mem_-&gt;Ref();
      force = <span class="org-constant">false</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Do not force another compaction if have room</span>
      MaybeScheduleCompaction(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23581;&#35797;&#36827;&#34892;compaction.&#36825;&#20010;&#20989;&#25968;&#25105;&#20204;&#21518;&#38754;&#20998;&#26512;.</span>
    }
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline52"></a>MaybeScheduleCompaction<br  /><div class="outline-text-5" id="text-10-3-3-12">
<p>
发起compaction调度.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">MaybeScheduleCompaction</span>() {
  mutex_.AssertHeld();
  <span class="org-keyword">if</span> (bg_compaction_scheduled_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24050;&#32463;&#34987;&#35843;&#24230;&#30340;&#35805;.&#37027;&#20040;&#27809;&#26377;&#24517;&#35201;&#20135;&#33021;&#37325;&#26032;&#21457;&#36215;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Already scheduled</span>
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (shutting_down_.Acquire_Load()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24050;&#32463;&#20851;&#38381;&#30340;&#35805;&#37027;&#20040;&#24573;&#30053;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">DB is being deleted; no more background compactions</span>
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (imm_ == <span class="org-constant">NULL</span> &amp;&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;memtable&#27809;&#26377;</span>
             manual_compaction_ == <span class="org-constant">NULL</span> &amp;&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#20154;&#24037;compaction</span>
             <span class="org-negation-char">!</span>versions_-&gt;NeedsCompaction()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;leveldb&#26412;&#36523;&#20063;&#27809;&#26377;&#24517;&#35201;&#35748;&#20026;compaction.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">No work to be done</span>
  } <span class="org-keyword">else</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">compaction&#20043;&#21069;&#26631;&#35760;</span>
    bg_compaction_scheduled_ = <span class="org-constant">true</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#36825;&#20010;&#26102;&#20505;&#21457;&#36215;compaction&#25805;&#20316;.&#36825;&#20010;&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;BGWork&#36825;&#20010;&#36807;&#31243;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">BGWork&#26159;pthread_create&#23553;&#35013;&#30340;&#25509;&#21475;&#65292;&#37324;&#38754;&#20165;&#20165;&#26159;&#35843;&#29992;&#20102;BackgroundCall&#36825;&#20010;&#20989;&#25968;.</span>
    env_-&gt;Schedule(&amp;<span class="org-constant">DBImpl</span>::BGWork, <span class="org-keyword">this</span>);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline53"></a>BackgroundCall<br  /><div class="outline-text-5" id="text-10-3-3-13">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">BackgroundCall</span>() {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  assert(bg_compaction_scheduled_);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>shutting_down_.Acquire_Load()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#20851;&#38381;&#30340;&#35805;.</span>
    BackgroundCompaction(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#20250;&#35843;&#29992;&#36825;&#20010;&#20989;&#25968;&#21457;&#36215;compaction.</span>
  }
  bg_compaction_scheduled_ = <span class="org-constant">false</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Previous compaction may have produced too many files in a level,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">so reschedule another compaction if needed.</span>
  MaybeScheduleCompaction(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#21487;&#33021;&#20250;&#37325;&#26032;&#21457;&#36215;compaction.</span>
  bg_cv_.SignalAll();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline54"></a>BackgroundCompaction<br  /><div class="outline-text-5" id="text-10-3-3-14">
<p>
这个部分是真正进行compaction的部分.我们仔细分析其中的行为.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">BackgroundCompaction</span>() {
  mutex_.AssertHeld();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#20195;&#30721;&#23454;&#29616;&#19978;&#26469;&#30475;&#30340;&#35805;&#65292;&#22914;&#26524;&#30495;&#23454;&#22320;&#36827;&#34892;compaction&#30340;&#35805;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;version&#36896;&#25104;&#30340;&#20462;&#25913;&#37117;&#20250;&#35760;&#24405;&#20026;edit,&#28982;&#21518;&#35843;&#29992;VersionSet::LogAndApply&#20445;&#23384;&#36215;&#26469;.</span>
  <span class="org-keyword">if</span> (imm_ != <span class="org-constant">NULL</span>) {
    CompactMemTable(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;imm!=NULL&#30340;&#35805;&#37027;&#20040;&#39318;&#20808;&#23545;imm&#36827;&#34892;compaction.</span>
    <span class="org-keyword">return</span>;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;imm_==NULL.</span>
  <span class="org-type">Compaction</span>* <span class="org-variable-name">c</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">is_manual</span> = (manual_compaction_ != <span class="org-constant">NULL</span>);
  <span class="org-type">InternalKey</span> <span class="org-variable-name">manual_end</span>;
  <span class="org-keyword">if</span> (is_manual) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;manual compaction&#30340;&#35805;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;compaction&#37324;&#38754;&#38656;&#35201;&#25552;&#20379;level&#20197;&#21450;range.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;&#25105;&#29468;&#24819;&#20165;&#20165;&#26159;&#23558;&#36825;&#20010;compaction&#25552;&#20379;&#19968;&#20010;&#21253;&#35013;&#20449;&#24687;&#20986;&#26469;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20855;&#20307;&#25805;&#20316;&#24310;&#36831;&#21040;&#21518;&#38754;&#36827;&#34892;.</span>
    <span class="org-type">ManualCompaction</span>* <span class="org-variable-name">m</span> = manual_compaction_;
    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);
    m-&gt;done = (c == <span class="org-constant">NULL</span>);
    <span class="org-keyword">if</span> (c != <span class="org-constant">NULL</span>) {
      manual_end = c-&gt;input(0, c-&gt;num_input_files(0) - 1)-&gt;largest;
    }
    Log(options_.info_log,
        <span class="org-string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,
        m-&gt;level,
        (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span class="org-string">"(begin)"</span>),
        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span class="org-string">"(end)"</span>),
        (m-&gt;done ? <span class="org-string">"(end)"</span> : manual_end.DebugString().c_str()));
  } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;manual compaction&#37027;&#20040;&#25361;&#36873;&#19968;&#20010;&#20986;&#26469;.</span>
    c = versions_-&gt;PickCompaction();
  }

  <span class="org-type">Status</span> <span class="org-variable-name">status</span>;
  <span class="org-keyword">if</span> (c == <span class="org-constant">NULL</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Nothing to do</span>
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>is_manual &amp;&amp; c-&gt;IsTrivialMove()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Move file to next level</span>
    assert(c-&gt;num_input_files(0) == 1);
    <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = c-&gt;input(0, 0);
    c-&gt;edit()-&gt;DeleteFile(c-&gt;level(), f-&gt;number);
    c-&gt;edit()-&gt;AddFile(c-&gt;level() + 1, f-&gt;number, f-&gt;file_size,
                       f-&gt;smallest, f-&gt;largest);
    status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);
    <span class="org-constant">VersionSet</span>::<span class="org-type">LevelSummaryStorage</span> <span class="org-variable-name">tmp</span>;
    Log(options_.info_log, <span class="org-string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,
        <span class="org-keyword">static_cast</span>&lt;<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>&gt;(f-&gt;number),
        c-&gt;level() + 1,
        <span class="org-keyword">static_cast</span>&lt;<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>&gt;(f-&gt;file_size),
        status.ToString().c_str(),
        versions_-&gt;LevelSummary(&amp;tmp));
  } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;compaction&#20449;&#24687;&#21253;&#35013;&#31216;&#20026;state&#36827;&#34892;&#25805;&#20316;.</span>
    <span class="org-type">CompactionState</span>* <span class="org-variable-name">compact</span> = <span class="org-keyword">new</span> <span class="org-type">CompactionState</span>(c);
    status = DoCompactionWork(compact);
    CleanupCompaction(compact);
  }
  <span class="org-keyword">delete</span> c;

  <span class="org-keyword">if</span> (status.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Done</span>
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (shutting_down_.Acquire_Load()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Ignore compaction errors found during shutting down</span>
  } <span class="org-keyword">else</span> {
    Log(options_.info_log,
        <span class="org-string">"Compaction error: %s"</span>, status.ToString().c_str());
    <span class="org-keyword">if</span> (options_.paranoid_checks &amp;&amp; bg_error_.ok()) {
      bg_error_ = status;
    }
  }

  <span class="org-keyword">if</span> (is_manual) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;manual_compaction&#30340;&#35805;&#37027;&#20040;&#25105;&#20204;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26377;&#26041;&#27861;&#21487;&#20197;&#30693;&#36947;&#36825;&#27425;manual compaction&#23454;&#38469;&#25805;&#20316;&#33539;&#22260;&#26377;&#22810;&#23569;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#38469;&#33539;&#22260;&#23601;&#26159;range&#25152;&#23545;&#24212;&#25991;&#20214;&#30340;largest key.:).&#36825;&#20010;&#20043;&#21069;&#21487;&#20197;&#30475;&#21040;.</span>
    <span class="org-type">ManualCompaction</span>* <span class="org-variable-name">m</span> = manual_compaction_;
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>m-&gt;done) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">We only compacted part of the requested range.  Update *m</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">to the range that is left to be compacted.</span>
      m-&gt;tmp_storage = manual_end;
      m-&gt;begin = &amp;m-&gt;tmp_storage;
    }
    manual_compaction_ = <span class="org-constant">NULL</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline55"></a>CompactMemTable<br  /><div class="outline-text-5" id="text-10-3-3-15">
<p>
对memtable进行compaction.注意这里针对的对象是imm_.mem对象是write操作的对象.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">CompactMemTable</span>() {
  mutex_.AssertHeld();
  assert(imm_ != <span class="org-constant">NULL</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Save the contents of the memtable as a new Table</span>
  <span class="org-type">VersionEdit</span> <span class="org-variable-name">edit</span>;
  <span class="org-type">Version</span>* <span class="org-variable-name">base</span> = versions_-&gt;current();
  base-&gt;Ref();
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = WriteLevel0Table(imm_, &amp;edit, base);
  base-&gt;Unref();

  <span class="org-keyword">if</span> (s.ok() &amp;&amp; shutting_down_.Acquire_Load()) {
    s = <span class="org-constant">Status</span>::IOError(<span class="org-string">"Deleting DB during memtable compaction"</span>);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Replace immutable memtable with the generated Table</span>
  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#26086;&#36825;&#20010;memtable&#36827;&#34892;compaction&#23436;&#25104;&#20043;&#21518;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#23601;&#21487;&#20197;&#35748;&#20026;&#36825;&#20010;log file number&#19981;&#38656;&#35201;&#20102;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20010;&#20449;&#24687;&#35760;&#24405;&#22312;version edit&#37324;&#38754;.</span>
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  <span class="org-comment-delimiter">// </span><span class="org-comment">Earlier logs no longer needed</span>
    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#37322;&#25918;imm&#36825;&#20010;&#20869;&#23384;&#24182;&#19988;&#21024;&#38500;&#22810;&#20313;&#25991;&#20214;.</span>
  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Commit to the new state</span>
    imm_-&gt;Unref();
    imm_ = <span class="org-constant">NULL</span>;
    has_imm_.Release_Store(<span class="org-constant">NULL</span>);
    DeleteObsoleteFiles();
  }

  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline56"></a>CompactRange<br  /><div class="outline-text-5" id="text-10-3-3-16">
<p>
这个语义应该是针对某个range来进行compaction的.
</p>
<ul class="org-ul">
<li>首先查看和这些range存在overlap的最大level是多少</li>
<li>首先对memtable进行compaction(不管是否存在overlap)(TEST_CompactMemTable)</li>
<li>然后遍历这些level,分别对每层进行compact range.(TEST_CompactRange)</li>
</ul>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">CompactRange</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">begin</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">end</span>) {
  <span class="org-type">int</span> <span class="org-variable-name">max_level_with_files</span> = 1;
  {
    MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
    <span class="org-type">Version</span>* <span class="org-variable-name">base</span> = versions_-&gt;current();
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 1; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
      <span class="org-keyword">if</span> (base-&gt;OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }
  TEST_CompactMemTable(); <span class="org-comment-delimiter">// </span><span class="org-comment">TODO(sanjay): Skip if memtable does not overlap</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; max_level_with_files; level++) {
    TEST_CompactRange(level, begin, end);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline57"></a>TEST_CompactMemTable<br  /><div class="outline-text-5" id="text-10-3-3-17">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">TEST_CompactMemTable</span>() {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-type">LoggerId</span> <span class="org-variable-name">self</span>;
  AcquireLoggingResponsibility(&amp;self);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#24212;&#35813;&#26159;&#35201;&#27714;imm==NULL&#20063;&#23601;&#26159;&#35828;&#27809;&#26377;memtable&#22312;&#36827;&#34892;compaction&#30340;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#36825;&#26679;&#30340;&#34892;&#20026;&#38750;&#24120;&#26126;&#26174;&#23601;&#26159;&#24076;&#26395;mem&#37325;&#26032;&#24320;&#36767;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#21407;&#26469;&#30340;mem&#36827;&#34892;compaction</span>
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = MakeRoomForWrite(<span class="org-constant">true</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">force compaction */</span>);
  ReleaseLoggingResponsibility(&amp;self);
  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Wait until the compaction completes</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#31561;&#24453;memtable compaction&#32467;&#26463;.</span>
    <span class="org-keyword">while</span> (imm_ != <span class="org-constant">NULL</span> &amp;&amp; bg_error_.ok()) {
      bg_cv_.Wait();
    }
    <span class="org-keyword">if</span> (imm_ != <span class="org-constant">NULL</span>) {
      s = bg_error_;
    }
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline58"></a>TEST_CompactRange<br  /><div class="outline-text-5" id="text-10-3-3-18">
<p>
针对某个Level来进行range compaction.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">TEST_CompactRange</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">begin</span>,<span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">end</span>) {
  assert(level &gt;= 0);
  assert(level + 1 &lt; <span class="org-constant">config</span>::kNumLevels);

  <span class="org-type">InternalKey</span> <span class="org-variable-name">begin_storage</span>, <span class="org-variable-name">end_storage</span>;

  <span class="org-type">ManualCompaction</span> <span class="org-variable-name">manual</span>;
  manual.level = level; <span class="org-comment-delimiter">// </span><span class="org-comment">level</span>
  manual.done = <span class="org-constant">false</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#24050;&#32463;&#23436;&#25104;.</span>
  <span class="org-keyword">if</span> (begin == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36873;&#25321;manual compaction range.</span>
    manual.begin = <span class="org-constant">NULL</span>;
  } <span class="org-keyword">else</span> {
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &amp;begin_storage;
  }
  <span class="org-keyword">if</span> (end == <span class="org-constant">NULL</span>) {
    manual.end = <span class="org-constant">NULL</span>;
  } <span class="org-keyword">else</span> {
    end_storage = InternalKey(*end, 0, <span class="org-keyword">static_cast</span>&lt;ValueType&gt;(0));
    manual.end = &amp;end_storage;
  }

  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>manual.done) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#23436;&#25104;&#30340;&#35805;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#24453;&#19978;&#19968;&#27425;&#23436;&#25104;</span>
    <span class="org-keyword">while</span> (manual_compaction_ != <span class="org-constant">NULL</span>) {
      bg_cv_.Wait();
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#31561;&#24453;&#26412;&#27425;&#23436;&#25104;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36824;&#26159;&#35843;&#29992;maybe schedule compaction</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#29031;&#20195;&#30721;&#26469;&#30475;&#30340;&#35805;&#36208;&#30340;&#20998;&#25903;&#20027;&#35201;&#26159;&#20851;&#27880;VersionSet::CompactRange&#36825;&#20010;&#37096;&#20998;.</span>
    manual_compaction_ = &amp;manual;
    MaybeScheduleCompaction();
    <span class="org-keyword">while</span> (manual_compaction_ == &amp;manual) {
      bg_cv_.Wait();
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline59"></a>DoCompactionWork<br  /><div class="outline-text-5" id="text-10-3-3-19">
<p>
完成的工作是实质性地Compaction.通过读取提交的CompactionState来完成.过程比较长可以逐段逐段地阅读代码.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">DoCompactionWork</span>(<span class="org-type">CompactionState</span>* <span class="org-variable-name">compact</span>) {
  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">start_micros</span> = env_-&gt;NowMicros();
  <span class="org-type">int64_t</span> <span class="org-variable-name">imm_micros</span> = 0;  <span class="org-comment-delimiter">// </span><span class="org-comment">Micros spent doing imm_ compactions</span>

  Log(options_.info_log,  <span class="org-string">"Compacting %d@%d + %d@%d files"</span>,
      compact-&gt;compaction-&gt;num_input_files(0),
      compact-&gt;compaction-&gt;level(),
      compact-&gt;compaction-&gt;num_input_files(1),
      compact-&gt;compaction-&gt;level() + 1);

  assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; 0);
  assert(compact-&gt;builder == <span class="org-constant">NULL</span>);
  assert(compact-&gt;outfile == <span class="org-constant">NULL</span>);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#26681;&#25454;&#24403;&#21069;&#25152;&#26377;&#25552;&#20132;&#30340;snapshot&#30693;&#36947;&#24403;&#21069;&#26368;&#23567;&#30340;sequence number&#26159;&#22810;&#23569;.</span>
  <span class="org-keyword">if</span> (snapshots_.empty()) {
    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();
  } <span class="org-keyword">else</span> {
    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;number_;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Release mutex while we're actually doing the compaction work</span>
  mutex_.Unlock();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;&#36825;&#20010;compaction&#21019;&#24314;&#20986;iterator.&#25105;&#20204;&#22312;&#21518;&#38754;&#30475;&#30475;&#36825;&#20010;iterator&#26159;&#22914;&#20309;&#24314;&#31435;&#30340;.</span>
  <span class="org-type">Iterator</span>* <span class="org-variable-name">input</span> = versions_-&gt;MakeInputIterator(compact-&gt;compaction);
  input-&gt;SeekToFirst();
  <span class="org-type">Status</span> <span class="org-variable-name">status</span>;
  <span class="org-type">ParsedInternalKey</span> <span class="org-variable-name">ikey</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">current_user_key</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">has_current_user_key</span> = <span class="org-constant">false</span>;
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">last_sequence_for_key</span> = kMaxSequenceNumber;
  <span class="org-keyword">for</span> (; input-&gt;Valid() &amp;&amp; <span class="org-negation-char">!</span>shutting_down_.Acquire_Load(); ) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Prioritize immutable compaction work</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20570;compaction&#20043;&#21069;&#20808;&#23558;immutable table compaction.</span>
    <span class="org-keyword">if</span> (has_imm_.NoBarrier_Load() != <span class="org-constant">NULL</span>) {
      <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">imm_start</span> = env_-&gt;NowMicros();
      mutex_.Lock();
      <span class="org-keyword">if</span> (imm_ != <span class="org-constant">NULL</span>) {
        CompactMemTable();
        bg_cv_.SignalAll();  <span class="org-comment-delimiter">// </span><span class="org-comment">Wakeup MakeRoomForWrite() if necessary</span>
      }
      mutex_.Unlock();
      imm_micros += (env_-&gt;NowMicros() - imm_start);
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#22312;&#36825;&#20010;key&#26159;&#21542;&#24212;&#35813;&#29420;&#31435;&#20135;&#29983;&#19968;&#20010;&#25991;&#20214;.</span>
    <span class="org-type">Slice</span> <span class="org-variable-name">key</span> = input-&gt;key();
    <span class="org-keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;
        compact-&gt;builder != <span class="org-constant">NULL</span>) {
      status = FinishCompactionOutputFile(compact, input);
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>status.ok()) {
        <span class="org-keyword">break</span>;
      }
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Handle key/value, add to state, etc.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">drop&#34920;&#31034;&#36825;&#20010;key&#26159;&#21542;&#24212;&#35813;&#30452;&#25509;&#20002;&#24323;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#22320;&#26041;&#22987;&#32456;&#24863;&#35273;&#26377;&#28857;&#38382;&#39064;.&#20026;&#20160;&#20040;&#35745;&#31639;last seuqnce number&#21602;?.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36807;&#22823;&#33268;&#24605;&#24819;&#26159;&#20102;&#35299;&#30340;.</span>
    <span class="org-type">bool</span> <span class="org-variable-name">drop</span> = <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ParseInternalKey(key, &amp;ikey)) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Do not hide error keys</span>
      current_user_key.clear();
      has_current_user_key = <span class="org-constant">false</span>;
      last_sequence_for_key = kMaxSequenceNumber;
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>has_current_user_key ||
          user_comparator()-&gt;Compare(ikey.user_key,
                                     Slice(current_user_key)) != 0) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">First occurrence of this user key</span>
        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
        has_current_user_key = <span class="org-constant">true</span>;
        last_sequence_for_key = kMaxSequenceNumber;
      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#27573;&#36923;&#36753;&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;&#20002;&#24323;.</span>
      <span class="org-keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Hidden by an newer entry for same user key</span>
        drop = <span class="org-constant">true</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">(A)</span>
      } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&#21024;&#38500;&#24182;&#19988;&#36825;&#20010;key &lt; snapshot.</span>
                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;
                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">For this user key:</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">(1) there is no data in higher levels</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">(2) data in lower levels will have larger sequence numbers</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">(3) data in layers that are being compacted here and have</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">smaller sequence numbers will be dropped in the next</span>
        <span class="org-comment-delimiter">//     </span><span class="org-comment">few iterations of this loop (by rule (A) above).</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Therefore this deletion marker is obsolete and can be dropped.</span>
        drop = <span class="org-constant">true</span>;
      }

      last_sequence_for_key = ikey.sequence;
    }
<span class="org-preprocessor">#if</span> 0
    Log(options_.info_log,
        <span class="org-string">"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, "</span>
        <span class="org-string">"%d smallest_snapshot: %d"</span>,
        ikey.user_key.ToString().c_str(),
        (<span class="org-type">int</span>)ikey.sequence, ikey.type, kTypeValue, drop,
        compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key),
        (<span class="org-type">int</span>)last_sequence_for_key, (<span class="org-type">int</span>)compact-&gt;smallest_snapshot);
<span class="org-preprocessor">#endif</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#31649;&#21069;&#38754;&#32454;&#33410;&#22914;&#20309;&#21040;&#36825;&#20010;&#27493;&#39588;&#34920;&#26126;&#36825;&#20010;kv&#27809;&#26377;&#34987;drop&#25481;.</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>drop) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Open output file if necessary</span>
      <span class="org-keyword">if</span> (compact-&gt;builder == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#25454;compaction&#29366;&#24577;&#20135;&#29983;&#26032;&#36755;&#20986;&#25991;&#20214;.</span>
        status = OpenCompactionOutputFile(compact);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>status.ok()) {
          <span class="org-keyword">break</span>;
        }
      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">==0&#30340;&#26102;&#20505;&#35760;&#24405;&#26368;&#23567;key.</span>
      <span class="org-keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == 0) {
        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);
      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20043;&#21518;&#27599;&#27425;&#26356;&#26032;&#26368;&#22823;key</span>
      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#35760;&#24405;&#36825;&#20010;kv.</span>
      compact-&gt;builder-&gt;Add(key, input-&gt;value());

      <span class="org-comment-delimiter">// </span><span class="org-comment">Close output file if it is big enough</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25991;&#20214;&#36229;&#36807;&#22823;&#23567;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#20999;&#25442;&#25991;&#20214;.</span>
      <span class="org-keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=
          compact-&gt;compaction-&gt;MaxOutputFileSize()) {
        status = FinishCompactionOutputFile(compact, input);
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>status.ok()) {
          <span class="org-keyword">break</span>;
        }
      }
    }

    input-&gt;Next();
  }

  <span class="org-keyword">if</span> (status.ok() &amp;&amp; shutting_down_.Acquire_Load()) {
    status = <span class="org-constant">Status</span>::IOError(<span class="org-string">"Deleting DB during compaction"</span>);
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#21518;&#21487;&#33021;&#38656;&#35201;&#20851;&#38381;compaction&#30340;&#25991;&#20214;.</span>
  <span class="org-keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="org-constant">NULL</span>) {
    status = FinishCompactionOutputFile(compact, input);
  }
  <span class="org-keyword">if</span> (status.ok()) {
    status = input-&gt;status();
  }
  <span class="org-keyword">delete</span> input; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#36825;&#20010;iterator.</span>
  input = <span class="org-constant">NULL</span>;

  <span class="org-type">CompactionStats</span> <span class="org-variable-name">stats</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">compaction&#37096;&#20998;&#30340;&#26102;&#38388;&#36824;&#38656;&#35201;&#20986;&#21435;&#20869;&#23384;memtable compaction&#26159;&#26102;&#38388;.</span>
  stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#32479;&#35745;&#36825;&#27425;&#25805;&#20316;&#35835;&#21462;&#30340;&#22823;&#23567;.</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">which</span> = 0; which &lt; 2; which++) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) {
      stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;
    }
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#32479;&#35745;&#36825;&#27425;&#25805;&#20316;&#20889;&#30913;&#30424;&#22823;&#23567;.</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
    stats.bytes_written += compact-&gt;outputs[i].file_size;
  }

  mutex_.Lock();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20010;&#29366;&#24577;&#21512;&#24182;&#19978;&#26469;.</span>
  stats_[compact-&gt;compaction-&gt;level() + 1].Add(stats);

  <span class="org-keyword">if</span> (status.ok()) {
    status = InstallCompactionResults(compact);
  }
  <span class="org-constant">VersionSet</span>::<span class="org-type">LevelSummaryStorage</span> <span class="org-variable-name">tmp</span>;
  Log(options_.info_log,
      <span class="org-string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));
  <span class="org-keyword">return</span> status;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline60"></a>CleanupCompaction<br  /><div class="outline-text-5" id="text-10-3-3-20">
<p>
完成compaction之后的工作.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">CleanupCompaction</span>(<span class="org-type">CompactionState</span>* <span class="org-variable-name">compact</span>) {
  mutex_.AssertHeld();
  <span class="org-keyword">if</span> (compact-&gt;builder != <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36825;&#20010;builder&#27809;&#26377;&#38144;&#27585;&#30340;&#35805;&#37027;&#20040;&#35748;&#20026;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20013;&#36884;&#26159;shutdown&#20102;.&#37027;&#20040;&#25105;&#20204;&#36825;&#37324;&#30452;&#25509;abandon&#25481;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">May happen if we get a shutdown call in the middle of compaction</span>
    compact-&gt;builder-&gt;Abandon();
    <span class="org-keyword">delete</span> compact-&gt;builder;
  } <span class="org-keyword">else</span> {
    assert(compact-&gt;outfile == <span class="org-constant">NULL</span>);
  }
  <span class="org-keyword">delete</span> compact-&gt;outfile;
  <span class="org-comment-delimiter">// </span><span class="org-comment">compaction&#36807;&#31243;&#20013;&#30340;&#35805;&#26032;&#36755;&#20986;&#30340;output&#25991;&#20214;&#24212;&#35813;&#37117;&#21152;&#20837;&#20102;pengding_outputs</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38450;&#27490;&#36825;&#20010;&#25991;&#20214;&#37096;&#20998;&#34987;&#21024;&#38500;.&#23436;&#25104;compaction&#20043;&#21518;&#30340;&#35805;&#21487;&#20197;&#31227;&#38500;&#20102;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#32771;&#34385;&#36825;&#37324;&#22806;&#37096;&#24212;&#35813;&#26377;&#26631;&#35760;&#36890;&#30693;&#36825;&#20123;&#25991;&#20214;&#36824;&#26159;&#38656;&#35201;&#30340;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#20197;&#38024;&#23545;&#36825;&#20123;&#25991;&#20214;&#21487;&#33021;&#24050;&#32463;&#21019;&#24314;&#20102;&#21478;&#22806;&#19968;&#20010;version&#23545;&#35937;&#23384;&#25918;&#22312;version_set&#20869;&#37096;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;&#21861;&#26102;&#20505;&#37322;&#25918;version&#36825;&#20010;&#23545;&#35937;&#21602;???.</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
    <span class="org-keyword">const</span> <span class="org-constant">CompactionState</span>::<span class="org-type">Output</span>&amp; <span class="org-variable-name">out</span> = compact-&gt;outputs[i];
    pending_outputs_.erase(out.number);
  }
  <span class="org-keyword">delete</span> compact;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline61"></a>InstallCompactionResults<br  /><div class="outline-text-5" id="text-10-3-3-21">
<p>
这个函数调用过程是在DoCompactionWork里面.大致工作就是将这次compaction工作内容作为日志保存起来.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">InstallCompactionResults</span>(<span class="org-type">CompactionState</span>* <span class="org-variable-name">compact</span>) {
  mutex_.AssertHeld();
  Log(options_.info_log,  <span class="org-string">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,
      compact-&gt;compaction-&gt;num_input_files(0),
      compact-&gt;compaction-&gt;level(),
      compact-&gt;compaction-&gt;num_input_files(1),
      compact-&gt;compaction-&gt;level() + 1,
      <span class="org-keyword">static_cast</span>&lt;<span class="org-type">long</span> <span class="org-type">long</span>&gt;(compact-&gt;total_bytes));

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add compaction outputs</span>
  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;compaction&#36825;&#27425;&#25805;&#20316;&#21024;&#38500;&#21644;&#22686;&#21152;&#25991;&#20214;&#21152;&#20837;version_edit.</span>
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">level</span> = compact-&gt;compaction-&gt;level();
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
    <span class="org-keyword">const</span> <span class="org-constant">CompactionState</span>::<span class="org-type">Output</span>&amp; <span class="org-variable-name">out</span> = compact-&gt;outputs[i];
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#26412;&#22320;&#25805;&#20316;&#25918;&#22312;version_edit&#37324;&#38754;.</span>
    compact-&gt;compaction-&gt;edit()-&gt;AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
    pending_outputs_.erase(out.number); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;pending output&#37324;&#38754;&#21024;&#38500;.</span>
  }
  compact-&gt;outputs.clear();

  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#30693;version set&#26412;&#27425;&#20462;&#25913;&#20869;&#23481;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#23558;&#36825;&#27425;compaction&#30340;&#20869;&#23481;&#20316;&#20026;version&#20889;&#20837;log&#37324;&#38754;&#21435;.</span>
  <span class="org-keyword">if</span> (s.ok()) {
    compact-&gt;compaction-&gt;ReleaseInputs();
    DeleteObsoleteFiles();
  } <span class="org-keyword">else</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Discard any files we may have created during this failed compaction</span>
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; compact-&gt;outputs.size(); i++) {
      env_-&gt;DeleteFile(TableFileName(dbname_, compact-&gt;outputs[i].number));
    }
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline62"></a>OpenCompactionOutputFile<br  /><div class="outline-text-5" id="text-10-3-3-22">
<p>
打开用于compaction输出的文件.倒不是非常麻烦.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">OpenCompactionOutputFile</span>(<span class="org-type">CompactionState</span>* <span class="org-variable-name">compact</span>) {
  assert(compact != <span class="org-constant">NULL</span>);
  assert(compact-&gt;builder == <span class="org-constant">NULL</span>);
  <span class="org-type">uint64_t</span> <span class="org-variable-name">file_number</span>;
  {
    mutex_.Lock();
    file_number = versions_-&gt;NewFileNumber();
    pending_outputs_.insert(file_number); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25918;&#22312;pending output&#37324;&#38754;.</span>
    <span class="org-constant">CompactionState</span>::<span class="org-type">Output</span> <span class="org-variable-name">out</span>;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact-&gt;outputs.push_back(out);
    mutex_.Unlock();
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Make the output file</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#36755;&#20986;&#25991;&#20214;&#20197;&#21450;&#23545;&#24212;&#30340;table builder.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">fname</span> = TableFileName(dbname_, file_number);
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = env_-&gt;NewWritableFile(fname, &amp;compact-&gt;outfile);
  <span class="org-keyword">if</span> (s.ok()) {
    compact-&gt;builder = <span class="org-keyword">new</span> <span class="org-type">TableBuilder</span>(options_, compact-&gt;outfile);
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline63"></a>FinishCompactionOutputFile<br  /><div class="outline-text-5" id="text-10-3-3-23">
<p>
对于输出了文件之后我们需要finish的操作.倒不是非常麻烦.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">FinishCompactionOutputFile</span>(<span class="org-type">CompactionState</span>* <span class="org-variable-name">compact</span>,
                                          <span class="org-type">Iterator</span>* <span class="org-variable-name">input</span>) {
  assert(compact != <span class="org-constant">NULL</span>);
  assert(compact-&gt;outfile != <span class="org-constant">NULL</span>);
  assert(compact-&gt;builder != <span class="org-constant">NULL</span>);

  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">output_number</span> = compact-&gt;current_output()-&gt;number;
  assert(output_number != 0);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Check for iterator errors</span>
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = input-&gt;status();
  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">current_entries</span> = compact-&gt;builder-&gt;NumEntries();
  <span class="org-keyword">if</span> (s.ok()) {
    s = compact-&gt;builder-&gt;Finish(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#30693;&#23545;&#24212;&#30340;builder&#23545;&#35937;finish.</span>
  } <span class="org-keyword">else</span> {
    compact-&gt;builder-&gt;Abandon();
  }
  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">current_bytes</span> = compact-&gt;builder-&gt;FileSize();
  compact-&gt;current_output()-&gt;file_size = current_bytes;
  compact-&gt;total_bytes += current_bytes;
  <span class="org-keyword">delete</span> compact-&gt;builder; <span class="org-comment-delimiter">// </span><span class="org-comment">&#37322;&#25918;&#21407;&#26469;builder.</span>
  compact-&gt;builder = <span class="org-constant">NULL</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Finish and check for file errors</span>
  <span class="org-keyword">if</span> (s.ok()) {
    s = compact-&gt;outfile-&gt;Sync();
  }
  <span class="org-keyword">if</span> (s.ok()) {
    s = compact-&gt;outfile-&gt;Close();
  }
  <span class="org-keyword">delete</span> compact-&gt;outfile; <span class="org-comment-delimiter">// </span><span class="org-comment">&#37322;&#25918;&#21407;&#26469;&#30340;file&#23545;&#35937;.</span>
  compact-&gt;outfile = <span class="org-constant">NULL</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#39564;&#35777;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;OK.</span>
  <span class="org-keyword">if</span> (s.ok() &amp;&amp; current_entries &gt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Verify that the table is usable</span>
    <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span> = table_cache_-&gt;NewIterator(ReadOptions(),
                                               output_number,
                                               current_bytes);
    s = iter-&gt;status();
    <span class="org-keyword">delete</span> iter;
    <span class="org-keyword">if</span> (s.ok()) {
      Log(options_.info_log,
          <span class="org-string">"Generated table #%llu: %lld keys, %lld bytes"</span>,
          (<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>) output_number,
          (<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>) current_entries,
          (<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>) current_bytes);
    }
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline64"></a>Write<br  /><div class="outline-text-5" id="text-10-3-3-24">
<p>
这个是Put/Delete底层的最终实现.仔细看看吧
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">Write</span>(<span class="org-keyword">const</span> <span class="org-type">WriteOptions</span>&amp; <span class="org-variable-name">options</span>, <span class="org-type">WriteBatch</span>* <span class="org-variable-name">updates</span>) {
  <span class="org-type">Status</span> <span class="org-variable-name">status</span>;
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-type">LoggerId</span> <span class="org-variable-name">self</span>;
  AcquireLoggingResponsibility(&amp;self);
  status = MakeRoomForWrite(<span class="org-constant">false</span>);  <span class="org-comment-delimiter">// </span><span class="org-comment">May temporarily release lock and wait</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">last_sequence</span> = versions_-&gt;LastSequence(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#37197;sequence.</span>
  <span class="org-keyword">if</span> (status.ok()) {
    <span class="org-constant">WriteBatchInternal</span>::SetSequence(updates, last_sequence + 1); <span class="org-comment-delimiter">// </span><span class="org-comment">WriteBatch&#30340;sequence&#20174;+1&#24320;&#22987;.</span>
    last_sequence += <span class="org-constant">WriteBatchInternal</span>::Count(updates); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;&#19978;&#27425;sequence.</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">Add to log and apply to memtable.  We can release the lock during</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">this phase since the "logger_" flag protects against concurrent</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">loggers and concurrent writes into mem_.</span>
    {
      assert(logger_ == &amp;self);
      mutex_.Unlock();
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#37096;&#20998;&#26159;&#32943;&#23450;&#38656;&#35201;&#20889;&#20837;log&#30340;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#37322;&#25918;&#38145;&#26159;&#27809;&#26377;&#38382;&#39064;&#65292;&#22240;&#20026;&#36825;&#20010;&#22320;&#26041;logger&#21487;&#20197;&#20316;&#20026;&#38145;&#23384;&#22312;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#35299;&#24320;mutex&#20284;&#20046;&#21487;&#20197;&#20351;&#24471;Get&#36827;&#34892;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#25105;&#35273;&#24471;&#31532;&#19968;&#36941;&#30475;leveldb&#20195;&#30721;&#30340;&#26102;&#20505;&#21487;&#20197;&#25735;&#24320;&#24182;&#21457;&#36825;&#20010;&#37096;&#20998;.</span>
      status = log_-&gt;AddRecord(<span class="org-constant">WriteBatchInternal</span>::Contents(updates)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;updates&#30340;&#20869;&#23481;&#20316;&#20026;contents&#24471;&#21040;&#20889;&#20837;log.</span>
      <span class="org-keyword">if</span> (status.ok() &amp;&amp; options.sync) {
        status = logfile_-&gt;Sync();
      }
      <span class="org-keyword">if</span> (status.ok()) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;updates&#20889;&#20837;memtable.</span>
        status = <span class="org-constant">WriteBatchInternal</span>::InsertInto(updates, mem_);
      }
      mutex_.Lock();
      assert(logger_ == &amp;self);
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;&#20837;&#25104;&#21151;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#23558;&#36825;&#20010;sequence&#37325;&#26032;&#20889;&#22238;.</span>
    versions_-&gt;SetLastSequence(last_sequence); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#26032;&#30340;sequence.</span>
  }
  ReleaseLoggingResponsibility(&amp;self);
  <span class="org-keyword">return</span> status;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline65"></a>SanitizeOptions<br  /><div class="outline-text-5" id="text-10-3-3-25">
<p>
这个函数应该就是规范一下options这个结构.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Fix user-supplied options to be reasonable</span>
<span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">T</span>,<span class="org-keyword">class</span> <span class="org-type">V</span>&gt;
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">ClipToRange</span>(<span class="org-type">T</span>* <span class="org-variable-name">ptr</span>, <span class="org-type">V</span> <span class="org-variable-name">minvalue</span>, <span class="org-type">V</span> <span class="org-variable-name">maxvalue</span>) {
  <span class="org-keyword">if</span> (<span class="org-keyword">static_cast</span>&lt;V&gt;(*ptr) &gt; maxvalue) *ptr = maxvalue;
  <span class="org-keyword">if</span> (<span class="org-keyword">static_cast</span>&lt;V&gt;(*ptr) &lt; minvalue) *ptr = minvalue;
}
<span class="org-type">Options</span> <span class="org-function-name">SanitizeOptions</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>,
                        <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>* <span class="org-variable-name">icmp</span>,
                        <span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">src</span>) {
  <span class="org-type">Options</span> <span class="org-variable-name">result</span> = src;
  result.comparator = icmp;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35268;&#33539;&#21462;&#20540;&#33539;&#22260;.</span>
  ClipToRange(&amp;result.max_open_files,           20,     50000); <span class="org-comment-delimiter">// </span><span class="org-comment">20 , 50000</span>
  ClipToRange(&amp;result.write_buffer_size,        64&lt;&lt;10, 1&lt;&lt;30); <span class="org-comment-delimiter">// </span><span class="org-comment">64K , 1G</span>
  ClipToRange(&amp;result.block_size,               1&lt;&lt;10,  4&lt;&lt;20); <span class="org-comment-delimiter">// </span><span class="org-comment">1K, 4M.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#29992;&#25143;&#27809;&#26377;&#22635;&#20889;logger&#23545;&#35937;&#30340;&#35805;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#20135;&#29983;&#19968;&#20010;logger&#23545;&#35937;.</span>
  <span class="org-keyword">if</span> (result.info_log == <span class="org-constant">NULL</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Open a log file in the same directory as the db</span>
    src.env-&gt;CreateDir(dbname);  <span class="org-comment-delimiter">// </span><span class="org-comment">In case it does not exist</span>
    src.env-&gt;RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    <span class="org-type">Status</span> <span class="org-variable-name">s</span> = src.env-&gt;NewLogger(InfoLogFileName(dbname), &amp;result.info_log);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">No place suitable for logging</span>
      result.info_log = <span class="org-constant">NULL</span>;
    }
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;block cache&#20063;&#26159;.&#24320;&#36767;&#30340;block cache&#22823;&#23567;8MB.</span>
  <span class="org-keyword">if</span> (result.block_cache == <span class="org-constant">NULL</span>) {
    result.block_cache = NewLRUCache(8 &lt;&lt; 20);
  }
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline66"></a>GetProperty<br  /><div class="outline-text-5" id="text-10-3-3-26">
<p>
关于db的属性信息.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">GetProperty</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">property</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>) {
  value-&gt;clear();

  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-type">Slice</span> <span class="org-variable-name">in</span> = property;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23646;&#24615;&#30340;key&#24517;&#39035;&#26159;&#20197;leveldb.&#24320;&#22836;&#30340;.</span>
  <span class="org-type">Slice</span> <span class="org-variable-name">prefix</span>(<span class="org-string">"leveldb."</span>);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>in.starts_with(prefix)) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  in.remove_prefix(prefix.size());

  <span class="org-keyword">if</span> (in.starts_with(<span class="org-string">"num-files-at-level"</span>)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;level&#30340;&#25991;&#20214;&#25968;&#30446;.</span>
    in.remove_prefix(strlen(<span class="org-string">"num-files-at-level"</span>));
    <span class="org-type">uint64_t</span> <span class="org-variable-name">level</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">ok</span> = ConsumeDecimalNumber(&amp;in, &amp;level) &amp;&amp; in.empty();
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ok || level &gt;= <span class="org-constant">config</span>::kNumLevels) {
      <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    } <span class="org-keyword">else</span> {
      <span class="org-type">char</span> <span class="org-variable-name">buf</span>[100];
      snprintf(buf, <span class="org-keyword">sizeof</span>(buf), <span class="org-string">"%d"</span>,
               versions_-&gt;NumLevelFiles(<span class="org-keyword">static_cast</span>&lt;<span class="org-type">int</span>&gt;(level)));
      *value = buf;
      <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (in == <span class="org-string">"stats"</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25972;&#20010;db&#30340;&#29366;&#24577;.</span>
    <span class="org-type">char</span> <span class="org-variable-name">buf</span>[200];
    snprintf(buf, <span class="org-keyword">sizeof</span>(buf),
             <span class="org-string">"                               Compactions\n"</span>
             <span class="org-string">"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n"</span>
             <span class="org-string">"--------------------------------------------------\n"</span>
             );
    value-&gt;append(buf);
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
      <span class="org-type">int</span> <span class="org-variable-name">files</span> = versions_-&gt;NumLevelFiles(level);
      <span class="org-keyword">if</span> (stats_[level].micros &gt; 0 || files &gt; 0) {
        snprintf(
            buf, <span class="org-keyword">sizeof</span>(buf),
            <span class="org-string">"%3d %8d %8.0f %9.0f %8.0f %9.0f\n"</span>,
            level,
            files,
            versions_-&gt;NumLevelBytes(level) / 1048576.0,
            stats_[level].micros / 1e6, <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#36825;&#20010;level&#19978;&#38754;&#25805;&#20316;&#30340;&#26102;&#38388;.</span>
            stats_[level].bytes_read / 1048576.0, <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#36825;&#20010;level&#19978;&#38754;&#35835;&#21462;&#30340;&#23383;&#33410;&#25968;&#30446;.</span>
            stats_[level].bytes_written / 1048576.0); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#36825;&#20010;level&#19978;&#38754;&#20889;&#20837;&#30340;&#23383;&#33410;&#25968;&#30446;.</span>
        value-&gt;append(buf);
      }
    }
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (in == <span class="org-string">"sstables"</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;sstables&#30340;&#29366;&#24577;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26159;Version&#25171;&#21360;&#20986;&#30340;&#23383;&#31526;&#20018;.</span>
    *value = versions_-&gt;current()-&gt;DebugString();
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }

  <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline67"></a>GetApproximateSizes<br  /><div class="outline-text-5" id="text-10-3-3-27">
<p>
得到某个Range占用的大小.底层依赖于VersionSet
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">GetApproximateSizes</span>(
    <span class="org-keyword">const</span> <span class="org-type">Range</span>* <span class="org-variable-name">range</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>,
    <span class="org-type">uint64_t</span>* <span class="org-variable-name">sizes</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">TODO(opt): better implementation</span>
  <span class="org-type">Version</span>* <span class="org-variable-name">v</span>;
  {
    MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#26159;&#20840;&#23616;&#21152;&#38145;&#30340;.</span>
    versions_-&gt;current()-&gt;Ref(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#24403;&#21069;version&#21152;&#19978;&#24341;&#29992;&#35745;&#25968;.</span>
    v = versions_-&gt;current();
  }

  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Convert user_key into a corresponding internal key.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;sequence number&#26159;&#21542;&#27491;&#30830;&#21602;?</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36807;&#22823;&#33268;&#19978;&#21344;&#29992;&#30340;&#31354;&#38388;&#24046;&#19981;&#22810;&#23601;&#26159;&#36825;&#20040;&#22823;.</span>
    <span class="org-type">InternalKey</span> <span class="org-variable-name">k1</span>(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    <span class="org-type">InternalKey</span> <span class="org-variable-name">k2</span>(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20855;&#20307;&#23454;&#29616;&#21487;&#20197;&#26597;&#30475;VersionSet&#26041;&#27861;.&#26681;&#25454;&#26576;&#20010;key&#21028;&#26029;&#36825;&#20010;key&#22312;&#25991;&#20214;&#20013;&#30340;&#20559;&#31227;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#33021;&#20250;&#26377;&#19968;&#37096;&#20998;&#20559;&#24046;&#21543;&#20294;&#26159;&#22823;&#33268;&#27491;&#30830;.</span>
    <span class="org-type">uint64_t</span> <span class="org-variable-name">start</span> = versions_-&gt;ApproximateOffsetOf(v, k1);
    <span class="org-type">uint64_t</span> <span class="org-variable-name">limit</span> = versions_-&gt;ApproximateOffsetOf(v, k2);
    sizes[i] = (limit &gt;= start ? limit - start : 0);
  }

  {
    MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
    v-&gt;Unref();
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline68"></a>GetSnapshot<br  /><div class="outline-text-5" id="text-10-3-3-28">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">Snapshot</span>* <span class="org-constant">DBImpl</span>::<span class="org-function-name">GetSnapshot</span>() {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#26368;&#26032;&#30340;sequence number&#21019;&#24314;&#19968;&#20010;Snapshot&#23454;&#20363;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#28155;&#21152;&#21040;snapshot list&#37324;&#38754;.</span>
  <span class="org-keyword">return</span> snapshots_.New(versions_-&gt;LastSequence());
}
</pre>
</div>
</div></li>

<li><a id="orgheadline69"></a>ReleaseSnapshot<br  /><div class="outline-text-5" id="text-10-3-3-29">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">ReleaseSnapshot</span>(<span class="org-keyword">const</span> <span class="org-type">Snapshot</span>* <span class="org-variable-name">s</span>) {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;snapshot list&#37324;&#38754;&#21024;&#38500;.</span>
  snapshots_.Delete(<span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> SnapshotImpl*&gt;(s));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline70"></a>DeleteObsoleteFiles<br  /><div class="outline-text-5" id="text-10-3-3-30">
<p>
根据当前所有version所持有的file来决定哪些文件是不再需要的.version里面会持有file meta信息.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">DeleteObsoleteFiles</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Make a set of all of the live files</span>
  <span class="org-constant">std</span>::<span class="org-type">set</span>&lt;<span class="org-type">uint64_t</span>&gt; <span class="org-variable-name">live</span> = pending_outputs_;
  versions_-&gt;AddLiveFiles(&amp;live); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25345;&#26377;pending outputs&#37324;&#38754;&#27491;&#22312;&#36755;&#20986;&#30340;&#25991;&#20214;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#23558;verisons&#37324;&#38754;&#25152;&#26377;version&#25345;&#26377;&#30340;&#25991;&#20214;&#24471;&#21040;.</span>

  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::string&gt; <span class="org-variable-name">filenames</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;&#24403;&#21069;&#30446;&#24405;&#19979;&#38754;&#30340;&#25991;&#20214;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#25991;&#20214;&#25968;&#30446;&#19981;&#20250;&#36807;&#22810;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;&#36890;&#24120;&#26469;&#35828;&#27599;&#20010;level&#25991;&#20214;&#37117;&#20250;&#26377;&#19968;&#20010;&#19979;&#38480;&#22823;&#23567;&#25968;&#30446;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#32780;&#27599;&#20010;level&#30340;bytes&#26377;&#19968;&#20010;&#38480;&#21046;.&#23545;&#20110;&#26368;&#39640;&#23618;&#30340;level&#30340;&#35805;&#37027;&#20040;&#25991;&#20214;&#24050;&#32463;&#38750;&#24120;&#22823;&#20102;:)</span>
  env_-&gt;GetChildren(dbname_, &amp;filenames); <span class="org-comment-delimiter">// </span><span class="org-comment">Ignoring errors on purpose</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">number</span>;
  <span class="org-type">FileType</span> <span class="org-variable-name">type</span>;
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; filenames.size(); i++) {
    <span class="org-keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) {
      <span class="org-type">bool</span> <span class="org-variable-name">keep</span> = <span class="org-constant">true</span>;
      <span class="org-keyword">switch</span> (type) {
        <span class="org-keyword">case</span> kLogFile:
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;log&#25991;&#20214;&#30340;number&#26159;&#25353;&#29031;&#39034;&#24207;&#20998;&#37197;&#30340;.</span>
          keep = ((number &gt;= versions_-&gt;LogNumber()) || <span class="org-comment-delimiter">//</span>
                  (number == versions_-&gt;PrevLogNumber())); <span class="org-comment-delimiter">// </span><span class="org-comment">prev log number&#24050;&#32463;&#27809;&#26377;&#24517;&#35201;&#20102;.</span>
          <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> kDescriptorFile:
          <span class="org-comment-delimiter">// </span><span class="org-comment">Keep my manifest file, and any newer incarnations'</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">(in case there is a race that allows other incarnations)</span>
          keep = (number &gt;= versions_-&gt;ManifestFileNumber());
          <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> kTableFile:
          keep = (live.find(number) != live.end()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;&#38656;&#35201;&#21024;&#38500;.</span>
          <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> kTempFile:
          <span class="org-comment-delimiter">// </span><span class="org-comment">Any temp files that are currently being written to must</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">be recorded in pending_outputs_, which is inserted into "live"</span>
          keep = (live.find(number) != live.end()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#25991;&#20214;&#26159;&#21542;&#38656;&#35201;&#21024;&#38500;.</span>
          <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> kCurrentFile:
        <span class="org-keyword">case</span> kDBLockFile:
        <span class="org-keyword">case</span> kInfoLogFile:
          keep = <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#20854;&#20182;&#25991;&#20214;&#30340;&#35805;&#30452;&#25509;keep&#20303;&#23601;&#22909;&#20102;.</span>
          <span class="org-keyword">break</span>;
      }

      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>keep) {
        <span class="org-keyword">if</span> (type == kTableFile) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;table&#25991;&#20214;&#30340;&#35805;&#36824;&#38656;&#35201;&#20174;cache&#37324;&#38754;&#21435;&#25481;.</span>
          table_cache_-&gt;Evict(number);
        }
        Log(options_.info_log, <span class="org-string">"Delete type=%d #%lld\n"</span>,
            <span class="org-type">int</span>(<span class="org-variable-name">type</span>),
            <span class="org-keyword">static_cast</span>&lt;<span class="org-type">unsigned</span> <span class="org-type">long</span> <span class="org-type">long</span>&gt;(number));
        env_-&gt;DeleteFile(dbname_ + <span class="org-string">"/"</span> + filenames[i]); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#21024;&#38500;&#25991;&#20214;.</span>
      }
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline71"></a>Get<br  /><div class="outline-text-5" id="text-10-3-3-31">
<p>
Get的过程非常简单.因为实际Get的过程已经托管为Version::Get这个方法了.这里面我们只需要
构造出正确的seuqnce number,和user key拼接成为internal key即可.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">DBImpl</span>::<span class="org-function-name">Get</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                   <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>,
                   <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>) {
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">snapshot</span>;
  <span class="org-keyword">if</span> (options.snapshot != <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#24403;&#21069;&#35835;&#21462;&#26159;&#21542;&#38656;&#35201;snapshot.</span>
    snapshot = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;number_;
  } <span class="org-keyword">else</span> {
    snapshot = versions_-&gt;LastSequence();
  }

  <span class="org-type">MemTable</span>* <span class="org-variable-name">mem</span> = mem_;
  <span class="org-type">MemTable</span>* <span class="org-variable-name">imm</span> = imm_;
  <span class="org-type">Version</span>* <span class="org-variable-name">current</span> = versions_-&gt;current();
  mem-&gt;Ref();
  <span class="org-keyword">if</span> (imm != <span class="org-constant">NULL</span>) imm-&gt;Ref();
  current-&gt;Ref();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26597;&#35810;&#26159;&#21542;&#20250;&#36896;&#25104;compaction&#35302;&#21457;.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">have_stat_update</span> = <span class="org-constant">false</span>;
  <span class="org-constant">Version</span>::<span class="org-type">GetStats</span> <span class="org-variable-name">stats</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Unlock while reading from files and memtables</span>
  {
    mutex_.Unlock();
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20197;&#36825;&#20010;key&#21435;&#36827;&#34892;&#26597;&#35810;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">1.&#39318;&#20808;&#26597;&#35810;memtable 2.&#28982;&#21518;&#26597;&#35810;&#27491;&#22312;dump&#30340;memtable 3.&#26597;&#35810;&#30913;&#30424;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">First look in the memtable, then in the immutable memtable (if any).</span>
    <span class="org-type">LookupKey</span> <span class="org-variable-name">lkey</span>(key, snapshot);
    <span class="org-keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Done</span>
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (imm != <span class="org-constant">NULL</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Done</span>
    } <span class="org-keyword">else</span> {
      s = current-&gt;Get(options, lkey, value, &amp;stats);
      have_stat_update = <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#35810;&#30913;&#30424;&#30340;&#35805;&#20250;&#36827;&#34892;&#26631;&#35760;.</span>
    }
    mutex_.Lock();
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24471;&#21040;&#30340;&#20869;&#23481;&#20250;&#21453;&#39304;&#21040;&#24403;&#21069;&#30340;version&#37324;&#38754;&#28982;&#21518;&#23581;&#35797;&#35302;&#21457;compaction.</span>
  <span class="org-keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) {
    MaybeScheduleCompaction();
  }
  mem-&gt;Unref();
  <span class="org-keyword">if</span> (imm != <span class="org-constant">NULL</span>) imm-&gt;Unref();
  current-&gt;Unref();
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline72"></a>NewInternalIterator<br  /><div class="outline-text-5" id="text-10-3-3-32">
<p>
开辟内部的迭代器.但是功能上来说基本上以及完成了db::iterator所需要完成的工作.但是需要
注意这里面merge iterator接口是针对internal key的，所以外部的话还是需要保证user key
并且配合sequence number的行为.另外还需要考虑存在deletion情况.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">IterState</span> {
  <span class="org-constant">port</span>::<span class="org-type">Mutex</span>* <span class="org-variable-name">mu</span>;
  <span class="org-type">Version</span>* <span class="org-variable-name">version</span>;
  <span class="org-type">MemTable</span>* <span class="org-variable-name">mem</span>;
  <span class="org-type">MemTable</span>* <span class="org-variable-name">imm</span>;
};

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">CleanupIteratorState</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg1</span>, <span class="org-type">void</span>* <span class="org-variable-name">arg2</span>) {
  <span class="org-type">IterState</span>* <span class="org-variable-name">state</span> = <span class="org-keyword">reinterpret_cast</span>&lt;IterState*&gt;(arg1);
  state-&gt;mu-&gt;Lock();
  state-&gt;mem-&gt;Unref();
  <span class="org-keyword">if</span> (state-&gt;imm != <span class="org-constant">NULL</span>) state-&gt;imm-&gt;Unref();
  state-&gt;version-&gt;Unref();
  state-&gt;mu-&gt;Unlock();
  <span class="org-keyword">delete</span> state;
}

<span class="org-type">Iterator</span>* <span class="org-constant">DBImpl</span>::<span class="org-function-name">NewInternalIterator</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                                      <span class="org-type">SequenceNumber</span>* <span class="org-variable-name">latest_snapshot</span>) {
  <span class="org-type">IterState</span>* <span class="org-variable-name">cleanup</span> = <span class="org-keyword">new</span> <span class="org-type">IterState</span>;
  mutex_.Lock();
  *latest_snapshot = versions_-&gt;LastSequence();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#21487;&#33021;&#23384;&#22312;&#30340;iterator&#25918;&#22312;&#19968;&#20010;list&#37324;&#38754;&#20570;&#25104;&#19968;&#20010;merge list&#20869;&#23481;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Collect together all needed child iterators</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">Iterator</span>*&gt; <span class="org-variable-name">list</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;memtable&#19979;&#38754;&#38656;&#35201;&#36941;&#21382;.</span>
  list.push_back(mem_-&gt;NewIterator());
  mem_-&gt;Ref();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20854;&#27425;imm memtable&#38656;&#35201;&#36941;&#21382;</span>
  <span class="org-keyword">if</span> (imm_ != <span class="org-constant">NULL</span>) {
    list.push_back(imm_-&gt;NewIterator());
    imm_-&gt;Ref();
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;version&#26469;&#35828;&#21487;&#33021;&#23384;&#22312;&#24456;&#22810;&#25991;&#20214;&#38656;&#35201;&#36941;&#21382;.</span>
  versions_-&gt;current()-&gt;AddIterators(options, &amp;list);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20123;&#20869;&#23481;&#26500;&#36896;&#31216;&#20026;&#19968;&#20010;merge iterator.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#30340;&#20869;&#23481;&#37117;&#21152;&#20102;&#24341;&#29992;&#35745;&#25968;.</span>
  <span class="org-type">Iterator</span>* <span class="org-variable-name">internal_iter</span> =
      NewMergingIterator(&amp;internal_comparator_, &amp;list[0], list.size());
  versions_-&gt;current()-&gt;Ref();

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;&#36825;&#20123;&#37322;&#25918;&#20869;&#23481;&#23384;&#25918;&#22312;internal iter&#38144;&#27585;&#22238;&#35843;&#37324;&#38754;.</span>
  cleanup-&gt;mu = &amp;mutex_;
  cleanup-&gt;mem = mem_;
  cleanup-&gt;imm = imm_;
  cleanup-&gt;version = versions_-&gt;current();
  internal_iter-&gt;RegisterCleanup(CleanupIteratorState, cleanup, <span class="org-constant">NULL</span>);

  mutex_.Unlock();
  <span class="org-keyword">return</span> internal_iter;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline73"></a>NewInterator<br  /><div class="outline-text-5" id="text-10-3-3-33">
<p>
实现在DBIter里面.工厂方式进行创建.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Iterator</span>* <span class="org-constant">DBImpl</span>::<span class="org-function-name">NewIterator</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20102;&#35299;&#24403;&#21069;&#26368;&#36817;&#30340;snapshot sequence number.</span>
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">latest_snapshot</span>;
  <span class="org-type">Iterator</span>* <span class="org-variable-name">internal_iter</span> = NewInternalIterator(options, &amp;latest_snapshot);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;NewDBIterator&#26469;&#36827;&#34892;&#21019;&#24314;.&#20855;&#20307;&#21487;&#20197;&#26597;&#30475;DBIter&#23454;&#29616;.</span>
  <span class="org-keyword">return</span> NewDBIterator(
      &amp;dbname_, env_, user_comparator(), internal_iter,
      (options.snapshot != <span class="org-constant">NULL</span>
       ? <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;number_
       : latest_snapshot));
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline87" class="outline-4">
<h4 id="orgheadline87"><span class="section-number-4">10.3.4</span> DBIter</h4>
<div class="outline-text-4" id="text-10-3-4">
<p>
db/db_iter.cc DBIter通过工厂方法创建.然后就DBIter结构以及里面的接口看看.
关于这个iterator的具体细节的话可以不用了解非常清楚，稍微了解工作原理即可。
实际上里面FindNextUserEntry和FindPrevUserEntry没有仔细阅读.:(.
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline75"></a>NewDBIterator<br  /><div class="outline-text-5" id="text-10-3-4-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Iterator</span>* <span class="org-function-name">NewDBIterator</span>(
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dbname</span>,
    <span class="org-type">Env</span>* <span class="org-variable-name">env</span>,
    <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">user_key_comparator</span>,
    <span class="org-type">Iterator</span>* <span class="org-variable-name">internal_iter</span>,
    <span class="org-keyword">const</span> <span class="org-type">SequenceNumber</span>&amp; <span class="org-variable-name">sequence</span>) {
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">DBIter</span>(dbname, env, user_key_comparator, internal_iter, sequence);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline76"></a>DBIter<br  /><div class="outline-text-5" id="text-10-3-4-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Memtables and sstables that make the DB representation contain</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">(userkey,seq,type) =&gt; uservalue entries.  DBIter</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">combines multiple entries for the same userkey found in the DB</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">representation into a single entry while accounting for sequence</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">numbers, deletion markers, overwrites, etc.</span>
<span class="org-keyword">class</span> <span class="org-type">DBIter</span>: <span class="org-keyword">public</span> <span class="org-type">Iterator</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Which direction is the iterator currently moving?</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">(1) When moving forward, the internal iterator is positioned at</span>
  <span class="org-comment-delimiter">//     </span><span class="org-comment">the exact entry that yields this-&gt;key(), this-&gt;value()</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">(2) When moving backwards, the internal iterator is positioned</span>
  <span class="org-comment-delimiter">//     </span><span class="org-comment">just before all entries whose user key == this-&gt;key().</span>
  <span class="org-keyword">enum</span> <span class="org-type">Direction</span> {
    <span class="org-variable-name">kForward</span>,
    <span class="org-variable-name">kReverse</span>
  };

  <span class="org-function-name">DBIter</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dbname</span>, <span class="org-type">Env</span>* <span class="org-variable-name">env</span>,
         <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">cmp</span>, <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span>, <span class="org-type">SequenceNumber</span> <span class="org-variable-name">s</span>)
      : dbname_(dbname),
        env_(env),
        user_comparator_(cmp),
        iter_(iter),
        sequence_(s),
        direction_(kForward), <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#26159;&#21521;&#21069;&#26597;&#25214;.</span>
        valid_(<span class="org-constant">false</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#27809;&#26377;&#20219;&#20309;kv.</span>
  }
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">DBIter</span>() {
    <span class="org-keyword">delete</span> iter_;
  }
 <span class="org-keyword">private</span>:
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-keyword">const</span> <span class="org-variable-name">dbname_</span>;
  <span class="org-type">Env</span>* <span class="org-keyword">const</span> <span class="org-variable-name">env_</span>;
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-keyword">const</span> <span class="org-variable-name">user_comparator_</span>;
  <span class="org-type">Iterator</span>* <span class="org-keyword">const</span> <span class="org-variable-name">iter_</span>;
  SequenceNumber <span class="org-keyword">const</span> <span class="org-variable-name">sequence_</span>;

  <span class="org-type">Status</span> <span class="org-variable-name">status_</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;kReverse&#26041;&#21521;&#30340;&#35805;,&#37027;&#20040;&#20174;&#36825;&#37324;&#36820;&#22238;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#30452;&#25509;&#35843;&#29992;iter&#36820;&#22238;.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">saved_key_</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">== current key when direction_==kReverse</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">saved_value_</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">== current raw value when direction_==kReverse</span>
  <span class="org-type">Direction</span> <span class="org-variable-name">direction_</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">valid_</span>;
};
</pre>
</div>
</div></li>

<li><a id="orgheadline77"></a>ClearSavedValue<br  /><div class="outline-text-5" id="text-10-3-4-3">
<p>
清除saved_value这个字段.好像有点技巧.可以看看代码啥的测试一下.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">ClearSavedValue</span>() {
  <span class="org-keyword">if</span> (saved_value_.capacity() &gt; 1048576) { <span class="org-comment-delimiter">// </span><span class="org-comment">&gt;1M&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;swap.</span>
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">empty</span>;
    swap(empty, saved_value_);
  } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#20351;&#29992;clear.</span>
    saved_value_.clear();
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline78"></a>ParseKey<br  /><div class="outline-text-5" id="text-10-3-4-4">
<p>
工作非常简单就是从iter得到对应的key.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">ParseKey</span>(<span class="org-type">ParsedInternalKey</span>* <span class="org-variable-name">ikey</span>) {
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ParseInternalKey(iter_-&gt;key(), ikey)) {
    status_ = <span class="org-constant">Status</span>::Corruption(<span class="org-string">"corrupted internal key in DBIter"</span>);
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline79"></a>SaveKey<br  /><div class="outline-text-5" id="text-10-3-4-5">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">SaveKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">k</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>) {
  dst-&gt;assign(k.data(), k.size());
}
</pre>
</div>
</div></li>

<li><a id="orgheadline80"></a>Seek<br  /><div class="outline-text-5" id="text-10-3-4-6">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">target</span>) {
  direction_ = kForward;
  ClearSavedValue(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;saved_value_&#28165;&#31354;.</span>
  saved_key_.clear(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;saved_key_&#28165;&#31354;.</span>
  AppendInternalKey( <span class="org-comment-delimiter">// </span><span class="org-comment">&#37325;&#26032;&#35774;&#32622;&#26597;&#35810;key.&#20445;&#23384;&#21040;saved_key_.</span>
      &amp;saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));
  iter_-&gt;Seek(saved_key_);
  <span class="org-keyword">if</span> (iter_-&gt;Valid()) {
    FindNextUserEntry(<span class="org-constant">false</span>, &amp;saved_key_ <span class="org-comment-delimiter">/* </span><span class="org-comment">temporary storage */</span>);
  } <span class="org-keyword">else</span> {
    valid_ = <span class="org-constant">false</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline81"></a>Next<br  /><div class="outline-text-5" id="text-10-3-4-7">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">Next</span>() {
  assert(valid_);

  <span class="org-keyword">if</span> (direction_ == kReverse) {  <span class="org-comment-delimiter">// </span><span class="org-comment">Switch directions?</span>
    direction_ = kForward;
    <span class="org-comment-delimiter">// </span><span class="org-comment">iter_ is pointing just before the entries for this-&gt;key(),</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">so advance into the range of entries for this-&gt;key() and then</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">use the normal skipping code below.</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>iter_-&gt;Valid()) {
      iter_-&gt;SeekToFirst();
    } <span class="org-keyword">else</span> {
      iter_-&gt;Next();
    }
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>iter_-&gt;Valid()) {
      valid_ = <span class="org-constant">false</span>;
      saved_key_.clear();
      <span class="org-keyword">return</span>;
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Temporarily use saved_key_ as storage for key to skip.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">skip</span> = &amp;saved_key_;
  SaveKey(ExtractUserKey(iter_-&gt;key()), skip);
  FindNextUserEntry(<span class="org-constant">true</span>, skip);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline82"></a>Prev<br  /><div class="outline-text-5" id="text-10-3-4-8">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">Prev</span>() {
  assert(valid_);

  <span class="org-keyword">if</span> (direction_ == kForward) {  <span class="org-comment-delimiter">// </span><span class="org-comment">Switch directions?</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">iter_ is pointing at the current entry.  Scan backwards until</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">the key changes so we can use the normal reverse scanning code.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#21521;&#21069;&#19968;&#30452;&#25214;&#21040;&#30053;&#36807;&#24403;&#21069;saved_key&#30340;&#20869;&#23481;.</span>
    assert(iter_-&gt;Valid());  <span class="org-comment-delimiter">// </span><span class="org-comment">Otherwise valid_ would have been false</span>
    SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);
    <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
      iter_-&gt;Prev();
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>iter_-&gt;Valid()) {
        valid_ = <span class="org-constant">false</span>;
        saved_key_.clear();
        ClearSavedValue();
        <span class="org-keyword">return</span>;
      }
      <span class="org-keyword">if</span> (user_comparator_-&gt;Compare(ExtractUserKey(iter_-&gt;key()),
                                    saved_key_) &lt; 0) {
        <span class="org-keyword">break</span>;
      }
    }
    direction_ = kReverse;
  }

  FindPrevUserEntry();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline83"></a>FindNextUserEntry<br  /><div class="outline-text-5" id="text-10-3-4-9">
<p>
我们需要考虑到在DBIter里面处理的是mergeiterator.多路的话可能会存在很多.
</p>

<p>
:现在才发现原来在find的时候并没有将sequence number放在里面而仅仅是比较user key
的内容，然后将所有的user key内容放在一起然后来处理sequence.不过对于memtable等
在插入的时候还是按照user key+sequence来进行存放.按照这个理解的话很多事情就比较好懂了.
</p>

<p>
总感觉这个地方可能存在问题，没有考虑到delete k然后add k的情况.不过撇开这个问题就好理解多了，
我们这里得到skip之后的话就可以在next的时候需要越过skip这个key.因为上次已经得到这个key的内容了.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">FindNextUserEntry</span>(<span class="org-type">bool</span> <span class="org-variable-name">skipping</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">skip</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Loop until we hit an acceptable entry to yield</span>
  assert(iter_-&gt;Valid());
  assert(direction_ == kForward);
  <span class="org-keyword">do</span> {
    <span class="org-type">ParsedInternalKey</span> <span class="org-variable-name">ikey</span>;
    <span class="org-keyword">if</span> (ParseKey(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#38656;&#35201;&#28385;&#36275;sequence.</span>
      <span class="org-keyword">switch</span> (ikey.type) {
        <span class="org-keyword">case</span> kTypeDeletion: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;deletion&#30340;&#35805;,&#37027;&#20040;&#20445;&#23384;&#36825;&#20010;skip&#30340;&#20869;&#23481;.</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">Arrange to skip all upcoming entries for this key since</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">they are hidden by this deletion.</span>
          SaveKey(ikey.user_key, skip);
          skipping = <span class="org-constant">true</span>;
          <span class="org-keyword">break</span>;
        <span class="org-keyword">case</span> kTypeValue:
          <span class="org-keyword">if</span> (skipping &amp;&amp;
              user_comparator_-&gt;Compare(ikey.user_key, *skip) &lt;= 0) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">Entry hidden</span>
          } <span class="org-keyword">else</span> {
            valid_ = <span class="org-constant">true</span>;
            saved_key_.clear();
            <span class="org-keyword">return</span>;
          }
          <span class="org-keyword">break</span>;
      }
    }
    iter_-&gt;Next();
  } <span class="org-keyword">while</span> (iter_-&gt;Valid());
  saved_key_.clear();
  valid_ = <span class="org-constant">false</span>;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline84"></a>FindPrevUserEntry<br  /><div class="outline-text-5" id="text-10-3-4-10">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">FindPrevUserEntry</span>() {
  assert(direction_ == kReverse);

  <span class="org-type">ValueType</span> <span class="org-variable-name">value_type</span> = kTypeDeletion;
  <span class="org-keyword">if</span> (iter_-&gt;Valid()) {
    <span class="org-keyword">do</span> {
      <span class="org-type">ParsedInternalKey</span> <span class="org-variable-name">ikey</span>;
      <span class="org-keyword">if</span> (ParseKey(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) {
        <span class="org-keyword">if</span> ((value_type != kTypeDeletion) &amp;&amp;
            user_comparator_-&gt;Compare(ikey.user_key, saved_key_) &lt; 0) {
          <span class="org-comment-delimiter">// </span><span class="org-comment">We encountered a non-deleted value in entries for previous keys,</span>
          <span class="org-keyword">break</span>;
        }
        value_type = ikey.type;
        <span class="org-keyword">if</span> (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } <span class="org-keyword">else</span> {
          <span class="org-type">Slice</span> <span class="org-variable-name">raw_value</span> = iter_-&gt;value();
          <span class="org-keyword">if</span> (saved_value_.capacity() &gt; raw_value.size() + 1048576) {
            <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">empty</span>;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_-&gt;Prev();
    } <span class="org-keyword">while</span> (iter_-&gt;Valid());
  }

  <span class="org-keyword">if</span> (value_type == kTypeDeletion) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">End</span>
    valid_ = <span class="org-constant">false</span>;
    saved_key_.clear();
    ClearSavedValue();
    direction_ = kForward;
  } <span class="org-keyword">else</span> {
    valid_ = <span class="org-constant">true</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline85"></a>SeekToFirst<br  /><div class="outline-text-5" id="text-10-3-4-11">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">SeekToFirst</span>() {
  direction_ = kForward;
  ClearSavedValue();
  iter_-&gt;SeekToFirst();
  <span class="org-keyword">if</span> (iter_-&gt;Valid()) {
    FindNextUserEntry(<span class="org-constant">false</span>, &amp;saved_key_ <span class="org-comment-delimiter">/* </span><span class="org-comment">temporary storage */</span>);
  } <span class="org-keyword">else</span> {
    valid_ = <span class="org-constant">false</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline86"></a>SeekToLast<br  /><div class="outline-text-5" id="text-10-3-4-12">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">DBIter</span>::<span class="org-function-name">SeekToLast</span>() {
  direction_ = kReverse;
  ClearSavedValue();
  iter_-&gt;SeekToLast();
  FindPrevUserEntry();
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline88" class="outline-4">
<h4 id="orgheadline88"><span class="section-number-4">10.3.5</span> LookupKey</h4>
<div class="outline-text-4" id="text-10-3-5">
<p>
db/dbformat.h LookupKey是为了方便对不同的结构进行查询的key结构.抽象出来的话会使得操作更加方便.
我们只需要传入我们的user_key之后的话，那么就可以构造出对应查询结构的key.首先我们看看结构
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A helper class useful for DBImpl::Get()</span>
<span class="org-keyword">class</span> <span class="org-type">LookupKey</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Initialize *this for looking up user_key at a snapshot with</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the specified sequence number.</span>
  <span class="org-function-name">LookupKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">user_key</span>, <span class="org-type">SequenceNumber</span> <span class="org-variable-name">sequence</span>);

  ~<span class="org-function-name">LookupKey</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a key suitable for lookup in a MemTable.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;&#33021;&#22815;&#20026;memtable&#26597;&#35810;&#30340;key.</span>
  <span class="org-type">Slice</span> <span class="org-function-name">memtable_key</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> Slice(start_, end_ - start_); }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return an internal key (suitable for passing to an internal iterator)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;internal key.&#36825;&#20010;&#24212;&#35813;&#26159;&#20316;&#20026;sstable&#26597;&#35810;&#30340;key.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#38754;&#25105;&#20204;&#30475;&#30475;InternalKey&#30340;&#32467;&#26500;.</span>
  <span class="org-type">Slice</span> <span class="org-function-name">internal_key</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> Slice(kstart_, end_ - kstart_); }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;user_key&#26412;&#36523;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the user key</span>
  <span class="org-type">Slice</span> <span class="org-function-name">user_key</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> Slice(kstart_, end_ - kstart_ - 8); }

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#38754;&#32473;&#20986;&#20102;&#20256;&#20837;user_key&#20043;&#21518;&#26500;&#36896;&#20986;key&#30340;&#26684;&#24335;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">We construct a char array of the form:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">klength  varint32               &lt;-- start_</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">userkey  char[klength]          &lt;-- kstart_</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">tag      uint64</span>
  <span class="org-comment-delimiter">//                                    </span><span class="org-comment">&lt;-- end_</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The array is a suitable MemTable key.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The suffix starting with "userkey" can be used as an InternalKey.</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">start_</span>;
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">kstart_</span>;
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">end_</span>;
  <span class="org-type">char</span> <span class="org-variable-name">space_</span>[200];      <span class="org-comment-delimiter">// </span><span class="org-comment">Avoid allocation for short keys</span>
};
</pre>
</div>
<p>
结构非常好理解，在看看构造函数和析构函数即可
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-constant">LookupKey</span>::~<span class="org-function-name">LookupKey</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;space_&#26159;&#20026;&#20102;&#23545;&#20110;short keys&#19981;&#36827;&#34892;&#20998;&#37197;.</span>
  <span class="org-keyword">if</span> (start_ != space_) <span class="org-keyword">delete</span>[] start_;
}

<span class="org-constant">LookupKey</span>::<span class="org-function-name">LookupKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">user_key</span>, <span class="org-type">SequenceNumber</span> <span class="org-variable-name">s</span>) {
  <span class="org-type">size_t</span> <span class="org-variable-name">usize</span> = user_key.size();
  <span class="org-comment-delimiter">// </span><span class="org-comment">klength&#21344;&#29992;5&#20010;&#23383;&#33410;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">tag&#21344;&#29992;8&#20010;&#23383;&#33410;.</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">needed</span> = usize + 13;  <span class="org-comment-delimiter">// </span><span class="org-comment">A conservative estimate</span>
  <span class="org-type">char</span>* <span class="org-variable-name">dst</span>;
  <span class="org-keyword">if</span> (needed &lt;= <span class="org-keyword">sizeof</span>(space_)) {
    dst = space_;
  } <span class="org-keyword">else</span> {
    dst = <span class="org-keyword">new</span> <span class="org-type">char</span>[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);
  kstart_ = dst;
  memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline89" class="outline-4">
<h4 id="orgheadline89"><span class="section-number-4">10.3.6</span> ValueType</h4>
<div class="outline-text-4" id="text-10-3-6">
<p>
db/dbformat.h ValueType是存在于internal key内部的key类型.有普通类型和删除类型.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Value types encoded as the last component of internal keys.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">data structures.</span>
<span class="org-keyword">enum</span> <span class="org-type">ValueType</span> {
  <span class="org-variable-name">kTypeDeletion</span> = 0x0,
  <span class="org-variable-name">kTypeValue</span> = 0x1
};
<span class="org-comment-delimiter">// </span><span class="org-comment">kValueTypeForSeek defines the ValueType that should be passed when</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">constructing a ParsedInternalKey object for seeking to a particular</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">sequence number (since we sort sequence numbers in decreasing order</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and the value type is embedded as the low 8 bits in the sequence</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">number in internal keys, we need to use the highest-numbered</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">ValueType, not the lowest).</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">ValueType</span> <span class="org-variable-name">kValueTypeForSeek</span> = kTypeValue;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline90" class="outline-4">
<h4 id="orgheadline90"><span class="section-number-4">10.3.7</span> SequenceNumber</h4>
<div class="outline-text-4" id="text-10-3-7">
<p>
db/dbfotmat.h SequenceNumber也存在于internal key内部，表示这个key的序号。现在就我自己的理解，
能想到这个序号的用户就是用来完成snapshot.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-type">uint64_t</span> <span class="org-type">SequenceNumber</span>;

<span class="org-comment-delimiter">// </span><span class="org-comment">We leave eight bits empty at the bottom so a type and sequence#</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">can be packed together into 64-bits.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">SequenceNumber</span> <span class="org-variable-name">kMaxSequenceNumber</span> =
    ((0x1ull &lt;&lt; 56) - 1);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline98" class="outline-4">
<h4 id="orgheadline98"><span class="section-number-4">10.3.8</span> InternalKey</h4>
<div class="outline-text-4" id="text-10-3-8">
<p>
db/dbformat.h InternalKey的实现一份还存在于MemTable里面.因为从WriteBatch是首先写入MemTable的.
这个部分MemTable并没有复用而是重新实现.InternalKey应该也存在于SSTable里面.内部非常简单就是std::string
存储打包之后的格式。里面的方法比较多但是都相对非常简单。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Modules in this directory should keep internal keys wrapped inside</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the following class instead of plain strings so that we do not</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">incorrectly use string comparisons instead of an InternalKeyComparator.</span>
<span class="org-keyword">class</span> <span class="org-type">InternalKey</span> {
 <span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">rep_</span>;
 <span class="org-keyword">public</span>:
  <span class="org-function-name">InternalKey</span>() { }   <span class="org-comment-delimiter">// </span><span class="org-comment">Leave rep_ as empty to indicate it is invalid</span>
  <span class="org-function-name">InternalKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">user_key</span>, <span class="org-type">SequenceNumber</span> <span class="org-variable-name">s</span>, <span class="org-type">ValueType</span> <span class="org-variable-name">t</span>) {
    AppendInternalKey(&amp;rep_, ParsedInternalKey(user_key, s, t));
  }

  <span class="org-type">void</span> <span class="org-function-name">DecodeFrom</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">s</span>) { rep_.assign(s.data(), s.size()); }
  <span class="org-type">Slice</span> <span class="org-function-name">Encode</span>() <span class="org-keyword">const</span> {
    assert(<span class="org-negation-char">!</span>rep_.empty());
    <span class="org-keyword">return</span> rep_;
  }

  <span class="org-type">Slice</span> <span class="org-function-name">user_key</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> ExtractUserKey(rep_); }

  <span class="org-type">void</span> <span class="org-function-name">SetFrom</span>(<span class="org-keyword">const</span> <span class="org-type">ParsedInternalKey</span>&amp; <span class="org-variable-name">p</span>) {
    rep_.clear();
    AppendInternalKey(&amp;rep_, p);
  }

  <span class="org-type">void</span> <span class="org-function-name">Clear</span>() { rep_.clear(); }

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">DebugString</span>() <span class="org-keyword">const</span>;
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline91"></a>ExtracrUserKey<br  /><div class="outline-text-5" id="text-10-3-8-1">
<p>
之前我们知道user key是如何分布的了.后面8个字节有附加信息.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">Slice</span> <span class="org-function-name">ExtractUserKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">internal_key</span>) {
  assert(internal_key.size() &gt;= 8);
  <span class="org-keyword">return</span> Slice(internal_key.data(), internal_key.size() - 8);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline92"></a>ExtractValueType<br  /><div class="outline-text-5" id="text-10-3-8-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">ValueType</span> <span class="org-function-name">ExtractValueType</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">internal_key</span>) {
  assert(internal_key.size() &gt;= 8);
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = internal_key.size();
  <span class="org-type">uint64_t</span> <span class="org-variable-name">num</span> = DecodeFixed64(internal_key.data() + n - 8);
  <span class="org-type">unsigned</span> <span class="org-type">char</span> <span class="org-variable-name">c</span> = num &amp; 0xff;
  <span class="org-keyword">return</span> <span class="org-keyword">static_cast</span>&lt;ValueType&gt;(c);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline93"></a>ParsedInternalKey<br  /><div class="outline-text-5" id="text-10-3-8-3">
<p>
ParsedInternalKey是从InternalKey解析之后的表示.非常简单.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">ParsedInternalKey</span> {
  <span class="org-type">Slice</span> <span class="org-variable-name">user_key</span>;
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">sequence</span>;
  <span class="org-type">ValueType</span> <span class="org-variable-name">type</span>;

  <span class="org-function-name">ParsedInternalKey</span>() { }  <span class="org-comment-delimiter">// </span><span class="org-comment">Intentionally left uninitialized (for speed)</span>
  <span class="org-function-name">ParsedInternalKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">u</span>, <span class="org-keyword">const</span> <span class="org-type">SequenceNumber</span>&amp; <span class="org-variable-name">seq</span>, <span class="org-type">ValueType</span> <span class="org-variable-name">t</span>)
      : user_key(u), <span class="org-type">sequence</span>(<span class="org-variable-name">seq</span>), type(t) { }
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-function-name">DebugString</span>() <span class="org-keyword">const</span>;
};
</pre>
</div>
</div></li>

<li><a id="orgheadline94"></a>InternalKeyEncodingLength<br  /><div class="outline-text-5" id="text-10-3-8-4">
<p>
如果ParsedInternalKey打包称为InternalKey的长度.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Return the length of the encoding of "key".</span>
<span class="org-keyword">inline</span> <span class="org-type">size_t</span> <span class="org-function-name">InternalKeyEncodingLength</span>(<span class="org-keyword">const</span> <span class="org-type">ParsedInternalKey</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-keyword">return</span> key.user_key.size() + 8;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline95"></a>AppendInternalKey<br  /><div class="outline-text-5" id="text-10-3-8-5">
<p>
将ParsedInternalKey直接序列化到二进制格式.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">AppendInternalKey</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">result</span>, <span class="org-keyword">const</span> <span class="org-type">ParsedInternalKey</span>&amp; <span class="org-variable-name">key</span>) {
  result-&gt;append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline96"></a>PackSequenceAndType<br  /><div class="outline-text-5" id="text-10-3-8-6">
<p>
sequence number占据高56bits,type占据低8bits
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">uint64_t</span> <span class="org-function-name">PackSequenceAndType</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">seq</span>, <span class="org-type">ValueType</span> <span class="org-variable-name">t</span>) {
  assert(seq &lt;= kMaxSequenceNumber);
  assert(t &lt;= kValueTypeForSeek);
  <span class="org-keyword">return</span> (seq &lt;&lt; 8) | t;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline97"></a>ParseInternalKey<br  /><div class="outline-text-5" id="text-10-3-8-7">
<p>
根据InternalKey解析出ParsedInternalKey
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-function-name">ParseInternalKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">internal_key</span>,
                             <span class="org-type">ParsedInternalKey</span>* <span class="org-variable-name">result</span>) {
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = internal_key.size();
  <span class="org-keyword">if</span> (n &lt; 8) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">num</span> = DecodeFixed64(internal_key.data() + n - 8);
  <span class="org-type">unsigned</span> <span class="org-type">char</span> <span class="org-variable-name">c</span> = num &amp; 0xff;
  result-&gt;sequence = num &gt;&gt; 8;
  result-&gt;type = <span class="org-keyword">static_cast</span>&lt;ValueType&gt;(c);
  result-&gt;user_key = Slice(internal_key.data(), n - 8);
  <span class="org-keyword">return</span> (c &lt;= <span class="org-keyword">static_cast</span>&lt;<span class="org-type">unsigned</span> <span class="org-type">char</span>&gt;(kTypeValue));
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline102" class="outline-4">
<h4 id="orgheadline102"><span class="section-number-4">10.3.9</span> InternalKeyComparator</h4>
<div class="outline-text-4" id="text-10-3-9">
<p>
db/dbformat.cc 我们在MemTable::KeyComparator::operator()里面看到了调用InternalKeyComparator的Compare方法.
Compare接收两个Slice对象。对象是这样encode的,key_size + key_data + (seq &lt;&lt; 8) | type(8 bytes).
其中key_size包括了后面附加的8个字节.我们来看看InternalKeyComparator是怎么实现的.底层的Comparator是用来直接比较UserKey的，
没有考虑sequence number.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A comparator for internal keys that uses a specified comparator for</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the user key portion and breaks ties by decreasing sequence number.</span>
<span class="org-keyword">class</span> <span class="org-type">InternalKeyComparator</span> : <span class="org-keyword">public</span> <span class="org-type">Comparator</span> {
 <span class="org-keyword">private</span>:
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">user_comparator_</span>;
 <span class="org-keyword">public</span>:
  <span class="org-keyword">explicit</span> <span class="org-function-name">InternalKeyComparator</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">c</span>) : user_comparator_(c) { }
  <span class="org-keyword">virtual</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">Name</span>() <span class="org-keyword">const</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">"leveldb.InternalKeyComparator"</span>
  <span class="org-keyword">virtual</span> <span class="org-type">int</span> <span class="org-function-name">Compare</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">b</span>) <span class="org-keyword">const</span>;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">FindShortestSeparator</span>(
      <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">start</span>,
      <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">limit</span>) <span class="org-keyword">const</span>;
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">FindShortSuccessor</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">key</span>) <span class="org-keyword">const</span>;

  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-function-name">user_comparator</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> user_comparator_; }

  <span class="org-type">int</span> <span class="org-function-name">Compare</span>(<span class="org-keyword">const</span> <span class="org-type">InternalKey</span>&amp; <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>&amp; <span class="org-variable-name">b</span>) <span class="org-keyword">const</span>;
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline99"></a>Compare<br  /><div class="outline-text-5" id="text-10-3-9-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">InternalKeyComparator</span>::<span class="org-function-name">Compare</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">akey</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">bkey</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Order by:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">increasing user key (according to user-supplied comparator)</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">decreasing sequence number</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">decreasing type (though sequence# should be enough to disambiguate)</span>
  <span class="org-type">int</span> <span class="org-variable-name">r</span> = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  <span class="org-keyword">if</span> (r == 0) {
    <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">anum</span> = DecodeFixed64(akey.data() + akey.size() - 8);
    <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">bnum</span> = DecodeFixed64(bkey.data() + bkey.size() - 8);
    <span class="org-keyword">if</span> (anum &gt; bnum) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#29031;sequence number&#27604;&#36739;.</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">&#20043;&#21069;&#25105;&#20204;&#22312;MemTableInserter&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;sequence number&#26159;&#19981;&#26029;&#22686;&#21152;&#30340;.</span>
      r = -1;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (anum &lt; bnum) {
      r = +1;
    }
  }
  <span class="org-keyword">return</span> r;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline100"></a>FindShortestSeparator<br  /><div class="outline-text-5" id="text-10-3-9-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">InternalKeyComparator</span>::<span class="org-function-name">FindShortestSeparator</span>(
      <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">start</span>,
      <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">limit</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Attempt to shorten the user portion of the key</span>
  <span class="org-type">Slice</span> <span class="org-variable-name">user_start</span> = ExtractUserKey(*start);
  <span class="org-type">Slice</span> <span class="org-variable-name">user_limit</span> = ExtractUserKey(limit);
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">tmp</span>(user_start.data(), user_start.size());
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#20351;&#29992;user_comparator&#25214;&#21040;&#26356;&#30701;&#30340;</span>
  user_comparator_-&gt;FindShortestSeparator(&amp;tmp, user_limit);
  <span class="org-keyword">if</span> (tmp.size() &lt; user_start.size() &amp;&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#27604;&#36739;&#26159;&#21542;&#30495;&#30340;&#26356;&#30701;.</span>
      user_comparator_-&gt;Compare(user_start, tmp) &lt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26356;&#30701;&#30340;&#35805;&#65292;&#37027;&#20040;&#20250;&#23558;&#21518;&#38754;&#30340;8&#20010;&#23383;&#33410;&#34917;&#40784;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#30340;8&#20010;&#23383;&#33410;&#20351;&#29992;kMaxSequenceNumber&#20197;&#21450;kValueTypeForSeek</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20854;&#20013;kMaxSequenceNumber == (1 &lt;&lt; 56)-1</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#32780;kValueTypeForSeek == KValueType.(&#23601;&#26159;&#26222;&#36890;&#30340;kv&#31867;&#22411;)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">User key has become shorter physically, but larger logically.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Tack on the earliest possible number to the shortened user key.</span>
    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(<span class="org-keyword">this</span>-&gt;Compare(*start, tmp) &lt; 0);
    assert(<span class="org-keyword">this</span>-&gt;Compare(tmp, limit) &lt; 0);
    start-&gt;swap(tmp);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline101"></a>FindShortSuccessor<br  /><div class="outline-text-5" id="text-10-3-9-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">InternalKeyComparator</span>::<span class="org-function-name">FindShortSuccessor</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> {
  <span class="org-type">Slice</span> <span class="org-variable-name">user_key</span> = ExtractUserKey(*key);
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">tmp</span>(user_key.data(), user_key.size());
  user_comparator_-&gt;FindShortSuccessor(&amp;tmp); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#36890;&#36807;user_comparator_&#25214;&#21040;&#19979;&#19968;&#20010;</span>
  <span class="org-keyword">if</span> (tmp.size() &lt; user_key.size() &amp;&amp;
      user_comparator_-&gt;Compare(user_key, tmp) &lt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#30830;&#23454;&#26356;&#30701;&#30340;&#35805;&#37027;&#20040;&#20250;&#21152;&#19978;&#29305;&#23450;&#30340;8&#23383;&#33410;&#38468;&#21152;&#20449;&#24687;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20851;&#20110;&#38468;&#21152;&#20449;&#24687;&#22312;&#19978;&#38754;&#37027;&#20010;&#20989;&#25968;&#24050;&#32463;&#35299;&#37322;&#36807;&#20102;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">User key has become shorter physically, but larger logically.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Tack on the earliest possible number to the shortened user key.</span>
    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(<span class="org-keyword">this</span>-&gt;Compare(*key, tmp) &lt; 0);
    key-&gt;swap(tmp);
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline103" class="outline-4">
<h4 id="orgheadline103"><span class="section-number-4">10.3.10</span> FileMetaData</h4>
<div class="outline-text-4" id="text-10-3-10">
<p>
db/version_edit.h 对于一个sstable的元信息表示.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">FileMetaData</span> {
  <span class="org-type">int</span> <span class="org-variable-name">refs</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#20250;&#35774;&#32622;&#19968;&#20010;&#21021;&#20540;</span>
  <span class="org-type">int</span> <span class="org-variable-name">allowed_seeks</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">Seeks allowed until compaction</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">number</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">file_number.&#27604;&#22914;1.sst.&#36825;&#20010;&#32467;&#21512;BuildTable&#21644;TableCache&#21487;&#20197;&#29702;&#35299;&#24847;&#24605;.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">file_size</span>;         <span class="org-comment-delimiter">// </span><span class="org-comment">File size in bytes</span>
  <span class="org-type">InternalKey</span> <span class="org-variable-name">smallest</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">Smallest internal key served by table</span>
  <span class="org-type">InternalKey</span> <span class="org-variable-name">largest</span>;        <span class="org-comment-delimiter">// </span><span class="org-comment">Largest internal key served by table</span>

  <span class="org-function-name">FileMetaData</span>() : refs(0), allowed_seeks(1 &lt;&lt; 30), file_size(0) { }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline121" class="outline-4">
<h4 id="orgheadline121"><span class="section-number-4">10.3.11</span> Version</h4>
<div class="outline-text-4" id="text-10-3-11">
<p>
db/version_set.h 对于Version可以理解为每个Snapshot对应的内容。因为每个snapshot可能需要持有不同的文件，
这样Version里面可以带上所需要管理的文件。如果释放Snapshot的话并且也可以释放Version的话，那么就可以认为这些文件
没有被任何Snapshot所引用就可以被回收。首先看看Version结构题里面的字段。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Version</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">private:</span>
 <span class="org-keyword">public</span>:
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">Compaction</span>;
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">VersionSet</span>;

  <span class="org-keyword">class</span> <span class="org-type">LevelFileNumIterator</span>;
  Iterator* NewConcatenatingIterator(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp;, <span class="org-type">int</span> <span class="org-variable-name">level</span>) <span class="org-keyword">const</span>;

  <span class="org-type">VersionSet</span>* <span class="org-variable-name">vset_</span>;            <span class="org-comment-delimiter">// </span><span class="org-comment">VersionSet to which this Version belongs</span>
  <span class="org-type">Version</span>* <span class="org-variable-name">next_</span>;               <span class="org-comment-delimiter">// </span><span class="org-comment">Next version in linked list</span>
  <span class="org-type">Version</span>* <span class="org-variable-name">prev_</span>;               <span class="org-comment-delimiter">// </span><span class="org-comment">Previous version in linked list</span>
  <span class="org-type">int</span> <span class="org-variable-name">refs_</span>;                    <span class="org-comment-delimiter">// </span><span class="org-comment">Number of live refs to this version</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">List of files per level</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;level&#30340;files_&#37117;&#26159;&#32463;&#36807;&#25490;&#24207;&#30340;&#12290;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;level0&#21487;&#33021;&#23384;&#22312;overlap,&#23545;&#20110;level-x&#19981;&#23384;&#22312;overlap.</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">files_</span>[<span class="org-constant">config</span>::kNumLevels]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;version&#22312;&#21508;&#20010;level&#20445;&#25345;&#30340;&#25991;&#20214;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Next file to compact based on seek stats.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#25454;seek&#30340;&#32479;&#35745;&#19979;&#27425;&#38656;&#35201;&#36827;&#34892;compact&#30340;&#25991;&#20214;.</span>
  <span class="org-type">FileMetaData</span>* <span class="org-variable-name">file_to_compact_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#27425;&#36827;&#34892;compact&#25991;&#20214;</span>
  <span class="org-type">int</span> <span class="org-variable-name">file_to_compact_level_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#25991;&#20214;&#25152;&#22312;&#30340;level.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Level that should be compacted next and its compaction score.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Score &lt; 1 means compaction is not strictly needed.  These fields</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">are initialized by Finalize().</span>
  <span class="org-type">double</span> <span class="org-variable-name">compaction_score_</span>;
  <span class="org-type">int</span> <span class="org-variable-name">compaction_level_</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26500;&#36896;&#20989;&#25968;&#38750;&#24120;&#31616;&#21333;.</span>
  <span class="org-keyword">explicit</span> <span class="org-function-name">Version</span>(<span class="org-type">VersionSet</span>* <span class="org-variable-name">vset</span>)
      : vset_(vset), next_(<span class="org-keyword">this</span>), prev_(<span class="org-keyword">this</span>), refs_(0),
        file_to_compact_(<span class="org-constant">NULL</span>),
        file_to_compact_level_(-1),
        compaction_score_(-1),
        compaction_level_(-1) {
  }

  ~<span class="org-function-name">Version</span>();
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline104"></a>AddIterators<br  /><div class="outline-text-5" id="text-10-3-11-1">
<p>
将所持有的所有的level文件打开并且返回iterator.从注释上来看的话得到这些iterators的话是为了进行merge.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Version</span>::<span class="org-function-name">AddIterators</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                           <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">Iterator</span>*&gt;* <span class="org-variable-name">iters</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Merge all level zero files together since they may overlap</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#24320;&#25152;&#26377;&#30340;level0&#25991;&#20214;.</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files_[0].size(); i++) {
    iters-&gt;push_back(
        vset_-&gt;table_cache_-&gt;NewIterator(
            options, files_[0][i]-&gt;number, files_[0][i]-&gt;file_size));
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#24320;&#20854;&#20182;level&#30340;&#25991;&#20214;.&#20851;&#20110;&#36825;&#20010;concatenating&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">For levels &gt; 0, we can use a concatenating iterator that sequentially</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">walks through the non-overlapping files in the level, opening them</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">lazily.</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 1; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>files_[level].empty()) {
      iters-&gt;push_back(NewConcatenatingIterator(options, level));
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline105"></a>NewConcatenatingIterator<br  /><div class="outline-text-5" id="text-10-3-11-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Iterator</span>* <span class="org-constant">Version</span>::<span class="org-function-name">NewConcatenatingIterator</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                                            <span class="org-type">int</span> <span class="org-variable-name">level</span>) <span class="org-keyword">const</span> {
  <span class="org-keyword">return</span> NewTwoLevelIterator(
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#30340;level&gt;1.&#27599;&#20010;&#25991;&#20214;&#20043;&#38388;&#26159;&#27809;&#26377;overlap&#30340;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#36825;&#37324;&#25105;&#20204;&#20063;&#21487;&#20197;&#30693;&#36947;files_&#23545;&#20110;meta&#20043;&#38388;&#37117;&#26159;&#36827;&#34892;&#20102;&#25490;&#24207;&#30340;&#12290;</span>
      <span class="org-keyword">new</span> <span class="org-type">LevelFileNumIterator</span>(vset_-&gt;icmp_, &amp;files_[level]), <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#32423;&#36941;&#21382;&#22120;&#37319;&#29992;LevelFileNumberIterator.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#26144;&#23556;&#21040;&#20108;&#32423;&#36941;&#21382;&#22120;&#30340;&#35805;&#20351;&#29992;GetFileIterator&#26469;&#33719;&#24471;.</span>
      &amp;GetFileIterator, vset_-&gt;table_cache_, options);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline106"></a>LevelFileNumIterator<br  /><div class="outline-text-5" id="text-10-3-11-3">
<p>
结构应该非常简单，我们大致看看即可。主要是关心一下二级映射函数GetFileIterator.对于
key的话采用这个filemetadata里面的最大的key,而value采用filenumber+filesize表示.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-constant">Version</span>::<span class="org-type">LevelFileNumIterator</span> : <span class="org-keyword">public</span> Iterator {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">LevelFileNumIterator</span>(<span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>&amp; <span class="org-variable-name">icmp</span>,
                       <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;* <span class="org-variable-name">flist</span>)
      : icmp_(icmp),
        flist_(flist),
        index_(flist-&gt;size()) {        <span class="org-comment-delimiter">// </span><span class="org-comment">Marks as invalid</span>
  }
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">Valid</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> index_ &lt; flist_-&gt;size();
  }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">target</span>) {
    index_ = FindFile(icmp_, *flist_, target); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#36825;&#20010;target&#25152;&#23384;&#22312;&#30340;&#26368;&#23567;&#30340;index.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#21518;&#38754;&#20250;&#20855;&#20307;&#20998;&#26512;.&#20043;&#21069;&#30475;&#21040;&#20102;&#36825;&#23618;level&#37117;&#26159;disjoint&#30340;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#20197;&#22312;FindFile&#37324;&#38754;&#21487;&#20197;&#26681;&#25454;smallest&#20063;&#21487;&#20197;&#26681;&#25454;largest&#26469;&#36827;&#34892;&#26597;&#25214;.</span>
  }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToFirst</span>() { index_ = 0; }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToLast</span>() {
    index_ = flist_-&gt;empty() ? 0 : flist_-&gt;size() - 1;
  }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Next</span>() {
    assert(Valid());
    index_++;
  }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Prev</span>() {
    assert(Valid());
    <span class="org-keyword">if</span> (index_ == 0) {
      index_ = flist_-&gt;size();  <span class="org-comment-delimiter">// </span><span class="org-comment">Marks as invalid</span>
    } <span class="org-keyword">else</span> {
      index_--;
    }
  }
  <span class="org-type">Slice</span> <span class="org-function-name">key</span>() <span class="org-keyword">const</span> {
    assert(Valid());
    <span class="org-keyword">return</span> (*flist_)[index_]-&gt;largest.Encode();
  }
  <span class="org-type">Slice</span> <span class="org-function-name">value</span>() <span class="org-keyword">const</span> {
    assert(Valid()); <span class="org-comment-delimiter">// </span><span class="org-comment">file_number + file_size.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20851;&#20110;&#22914;&#20309;&#20351;&#29992;&#36825;&#20010;value.&#24212;&#35813;&#26159;&#26681;&#25454;&#36825;&#20010;value&#23545;&#24212;&#21040;&#36825;&#20010;&#20855;&#20307;&#25991;&#20214;&#30340;iterator.</span>
    EncodeFixed64(value_buf_, (*flist_)[index_]-&gt;number);
    EncodeFixed64(value_buf_+8, (*flist_)[index_]-&gt;file_size);
    <span class="org-keyword">return</span> Slice(value_buf_, <span class="org-keyword">sizeof</span>(value_buf_));
  }
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">status</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK(); }
 <span class="org-keyword">private</span>:
  <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span> <span class="org-variable-name">icmp_</span>;
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;* <span class="org-keyword">const</span> <span class="org-variable-name">flist_</span>;
  <span class="org-type">uint32_t</span> <span class="org-variable-name">index_</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Backing store for value().  Holds the file number and size.</span>
  <span class="org-keyword">mutable</span> <span class="org-type">char</span> <span class="org-variable-name">value_buf_</span>[16];
};
</pre>
</div>
</div></li>

<li><a id="orgheadline107"></a>GetFileIterator<br  /><div class="outline-text-5" id="text-10-3-11-4">
<p>
根据上面的分析file_value就是file_number + file_size.这里我们可以知道file_number应该是全局唯一的，
而不是在level上面唯一的。关于TableCache后面会分析。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">Iterator</span>* <span class="org-function-name">GetFileIterator</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>,
                                 <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                                 <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">file_value</span>) {
  <span class="org-type">TableCache</span>* <span class="org-variable-name">cache</span> = <span class="org-keyword">reinterpret_cast</span>&lt;TableCache*&gt;(arg);
  <span class="org-keyword">if</span> (file_value.size() != 16) {
    <span class="org-keyword">return</span> NewErrorIterator(
        <span class="org-constant">Status</span>::Corruption(<span class="org-string">"FileReader invoked with unexpected value"</span>));
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> cache-&gt;NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline108"></a>FindFile<br  /><div class="outline-text-5" id="text-10-3-11-5">
<p>
db/version_set.h 语义直接阅读注释即可.注意这里files都是排好序并且是不重叠的。按照二分法搜索largest key即可.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Return the smallest index i such that files[i]-&gt;largest &gt;= key.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Return files.size() if there is no such file.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: "files" contains a sorted list of non-overlapping files.</span>
<span class="org-type">int</span> <span class="org-function-name">FindFile</span>(<span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>&amp; <span class="org-variable-name">icmp</span>,
             <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span>,
             <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-type">uint32_t</span> <span class="org-variable-name">left</span> = 0;
  <span class="org-type">uint32_t</span> <span class="org-variable-name">right</span> = files.size();
  <span class="org-keyword">while</span> (left &lt; right) {
    <span class="org-type">uint32_t</span> <span class="org-variable-name">mid</span> = (left + right) / 2;
    <span class="org-keyword">const</span> <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = files[mid];
    <span class="org-keyword">if</span> (icmp.<span class="org-constant">InternalKeyComparator</span>::Compare(f-&gt;largest.Encode(), key) &lt; 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Key at "mid.largest" is &lt; "target".  Therefore all</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">files at or before "mid" are uninteresting.</span>
      left = mid + 1;
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Key at "mid.largest" is &gt;= "target".  Therefore all files</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">after "mid" are uninteresting.</span>
      right = mid;
    }
  }
  <span class="org-keyword">return</span> right;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline109"></a>SomeFileOverlapsRange<br  /><div class="outline-text-5" id="text-10-3-11-6">
<p>
db/version_set.h 判断是否有文件和某个范围[smallest,largest]相交.注意这里这里files也是按照key排序的.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Returns true iff some file in "files" overlaps the user key range</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">[*smallest,*largest].</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">smallest==NULL represents a key smaller than all keys in the DB.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">largest==NULL represents a key largest than all keys in the DB.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: If disjoint_sorted_files, files[] contains disjoint ranges</span>
<span class="org-comment-delimiter">//           </span><span class="org-comment">in sorted order.</span>
<span class="org-type">bool</span> <span class="org-function-name">SomeFileOverlapsRange</span>(
    <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>&amp; <span class="org-variable-name">icmp</span>,
    <span class="org-type">bool</span> <span class="org-variable-name">disjoint_sorted_files</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;files</span>
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span>,
    <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">smallest_user_key</span>,
    <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">largest_user_key</span>) {
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">ucmp</span> = icmp.user_comparator();
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>disjoint_sorted_files) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25991;&#20214;&#20043;&#38388;&#21487;&#33021;&#23384;&#22312;overlap&#30340;&#35805;.&#37027;&#20040;&#24517;&#39035;&#39034;&#24207;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#38656;&#35201;&#36941;&#21382;&#27599;&#20010;&#25991;&#20214;.&#21028;&#26029;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;&#21644;[small,large]&#30456;&#20132;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26377;&#30456;&#20132;&#65292;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;.:).</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Need to check against all files</span>
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; files.size(); i++) {
      <span class="org-keyword">const</span> <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = files[i];
      <span class="org-comment-delimiter">// </span><span class="org-comment">AfterFile&#21644;BeforeFile&#31245;&#21518;&#20998;&#26512;.</span>
      <span class="org-keyword">if</span> (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">No overlap</span>
      } <span class="org-keyword">else</span> {
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Overlap</span>
      }
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25991;&#20214;&#26412;&#36523;&#20043;&#38388;&#27809;&#26377;overlap&#30340;&#35805;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#25105;&#20204;&#21482;&#38656;&#35201;&#39318;&#20808;&#25353;&#29031;&#20108;&#20998;&#26041;&#27861;&#25214;&#21040;&#30456;&#20132;&#25991;&#20214;index.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#38024;&#23545;&#36825;&#20010;index&#20998;&#26512;&#21363;&#21487;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Binary search over file list</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">index</span> = 0;
  <span class="org-keyword">if</span> (smallest_user_key != <span class="org-constant">NULL</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Find the earliest possible internal key for smallest_user_key</span>
    <span class="org-type">InternalKey</span> <span class="org-variable-name">small</span>(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
    index = FindFile(icmp, files, small.Encode());
  }

  <span class="org-keyword">if</span> (index &gt;= files.size()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">beginning of range is after all files, so no overlap.</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }

  <span class="org-keyword">return</span> <span class="org-negation-char">!</span>BeforeFile(ucmp, largest_user_key, files[index]);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline110"></a>AfterFile<br  /><div class="outline-text-5" id="text-10-3-11-7">
<p>
判断user_key是否在这个file之后.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">AfterFile</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">ucmp</span>,
                      <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">user_key</span>, <span class="org-keyword">const</span> <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">NULL user_key occurs before all keys and is therefore never after *f</span>
  <span class="org-keyword">return</span> (user_key != <span class="org-constant">NULL</span> &amp;&amp;
          ucmp-&gt;Compare(*user_key, f-&gt;largest.user_key()) &gt; 0);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline111"></a>BeforeFile<br  /><div class="outline-text-5" id="text-10-3-11-8">
<p>
判断user_key是否在这个file之前.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">BeforeFile</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">ucmp</span>,
                       <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">user_key</span>, <span class="org-keyword">const</span> <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">NULL user_key occurs after all keys and is therefore never before *f</span>
  <span class="org-keyword">return</span> (user_key != <span class="org-constant">NULL</span> &amp;&amp;
          ucmp-&gt;Compare(*user_key, f-&gt;smallest.user_key()) &lt; 0);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline112"></a>GetStats<br  /><div class="outline-text-5" id="text-10-3-11-9">
<p>
这个结构反应的是查询到的一些附加结果可以用来指导compaction.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">GetStats</span> {
  <span class="org-type">FileMetaData</span>* <span class="org-variable-name">seek_file</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#34987;seek&#21040;&#30340;&#25991;&#20214;</span>
  <span class="org-type">int</span> <span class="org-variable-name">seek_file_level</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20197;&#21450;&#36825;&#20010;&#25991;&#20214;&#25152;&#22788;level.</span>
};
</pre>
</div>
</div></li>

<li><a id="orgheadline113"></a>NewestFirst<br  /><div class="outline-text-5" id="text-10-3-11-10">
<p>
按照file_number进行排序.逆序.越迟生成的file那么是最新的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">NewestFirst</span>(<span class="org-type">FileMetaData</span>* <span class="org-variable-name">a</span>, <span class="org-type">FileMetaData</span>* <span class="org-variable-name">b</span>) {
  <span class="org-keyword">return</span> a-&gt;number &gt; b-&gt;number;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline114"></a>Get<br  /><div class="outline-text-5" id="text-10-3-11-11">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">Version</span>::<span class="org-function-name">Get</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                    <span class="org-keyword">const</span> <span class="org-type">LookupKey</span>&amp; <span class="org-variable-name">k</span>,
                    <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>,
                    <span class="org-type">GetStats</span>* <span class="org-variable-name">stats</span>) {
  <span class="org-type">Slice</span> <span class="org-variable-name">ikey</span> = k.internal_key();
  <span class="org-type">Slice</span> <span class="org-variable-name">user_key</span> = k.user_key();
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">ucmp</span> = vset_-&gt;icmp_.user_comparator();
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;

  stats-&gt;seek_file = <span class="org-constant">NULL</span>;
  stats-&gt;seek_file_level = -1;
  <span class="org-type">FileMetaData</span>* <span class="org-variable-name">last_file_read</span> = <span class="org-constant">NULL</span>;
  <span class="org-type">int</span> <span class="org-variable-name">last_file_read_level</span> = -1;

  <span class="org-comment-delimiter">// </span><span class="org-comment">We can search level-by-level since entries never hop across</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">levels.  Therefore we are guaranteed that if we find data</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">in an smaller level, later levels are irrelevant.</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">tmp</span>;
  <span class="org-type">FileMetaData</span>* <span class="org-variable-name">tmp2</span>;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-type">size_t</span> <span class="org-variable-name">num_files</span> = files_[level].size();
    <span class="org-keyword">if</span> (num_files == 0) <span class="org-keyword">continue</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Get the list of files to search in this level</span>
    <span class="org-type">FileMetaData</span>* <span class="org-keyword">const</span>* <span class="org-variable-name">files</span> = &amp;files_[level][0];
    <span class="org-keyword">if</span> (level == 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Level-0 files may overlap each other.  Find all files that</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">overlap user_key and process them in order from newest to oldest.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;level0&#23384;&#22312;&#37325;&#21472;&#65292;&#25152;&#20197;&#38656;&#35201;&#37117;&#36827;&#34892;&#25628;&#32034;.</span>
      tmp.reserve(num_files);
      <span class="org-keyword">for</span> (<span class="org-type">uint32_t</span> <span class="org-variable-name">i</span> = 0; i &lt; num_files; i++) {
        <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = files[i];
        <span class="org-keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= 0 &amp;&amp;
            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= 0) {
          tmp.push_back(f);
        }
      }
      <span class="org-keyword">if</span> (tmp.empty()) <span class="org-keyword">continue</span>;
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#25353;&#29031;&#36827;&#34892;&#25490;&#24207;.&#26368;&#26032;&#29983;&#25104;&#30340;file&#25918;&#22312;&#26368;&#21069;&#38754;.</span>
      <span class="org-constant">std</span>::sort(tmp.begin(), tmp.end(), NewestFirst);
      files = &amp;tmp[0];
      num_files = tmp.size();
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#20854;&#20182;level&#30340;&#35805;&#36234;&#20302;level&#36234;&#26032;.&#24182;&#19988;level&#20869;&#37096;&#27809;&#26377;overlap</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#21487;&#20197;&#36890;&#36807;&#31616;&#21333;&#30340;&#20108;&#20998;&#27861;&#26469;&#21028;&#26029;&#21738;&#20010;&#25991;&#20214;.&#21482;&#20250;&#23384;&#22312;&#19968;&#20010;&#25991;&#20214;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Binary search to find earliest index whose largest key &gt;= ikey.</span>
      <span class="org-type">uint32_t</span> <span class="org-variable-name">index</span> = FindFile(vset_-&gt;icmp_, files_[level], ikey);
      <span class="org-keyword">if</span> (index &gt;= num_files) {
        files = <span class="org-constant">NULL</span>;
        num_files = 0;
      } <span class="org-keyword">else</span> {
        tmp2 = files[index];
        <span class="org-keyword">if</span> (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; 0) {
          <span class="org-comment-delimiter">// </span><span class="org-comment">All of "tmp2" is past any data for user_key</span>
          files = <span class="org-constant">NULL</span>;
          num_files = 0;
        } <span class="org-keyword">else</span> {
          files = &amp;tmp2;
          num_files = 1;
        }
      }
    }

    <span class="org-keyword">for</span> (<span class="org-type">uint32_t</span> <span class="org-variable-name">i</span> = 0; i &lt; num_files; ++i) {
      <span class="org-keyword">if</span> (last_file_read != <span class="org-constant">NULL</span> &amp;&amp; stats-&gt;seek_file == <span class="org-constant">NULL</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">We have had more than one seek for this read.  Charge the 1st file.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">stats&#36825;&#37324;&#21482;&#20445;&#30041;&#31532;&#19968;&#27425;&#35835;&#21462;&#30340;&#25991;&#20214;.</span>
        stats-&gt;seek_file = last_file_read;
        stats-&gt;seek_file_level = last_file_read_level;
      }

      <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = files[i];
      last_file_read = f;
      last_file_read_level = level;

      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36890;&#36807;iterator&#30340;seek&#26041;&#24335;&#26469;&#36827;&#34892;&#26597;&#25214;.</span>
      <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span> = vset_-&gt;table_cache_-&gt;NewIterator(
          options,
          f-&gt;number,
          f-&gt;file_size);
      iter-&gt;Seek(ikey);
      <span class="org-comment-delimiter">// </span><span class="org-comment">seek&#21482;&#26159;&#19968;&#20010;&#22823;&#27010;&#20301;&#32622;&#36825;&#37324;&#38656;&#35201;&#31934;&#30830;&#27604;&#36739;&#36820;&#22238;&#20540;.&#21518;&#38754;&#25105;&#20204;&#20180;&#32454;&#20998;&#26512;GetValue.</span>
      <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-variable-name">done</span> = GetValue(ucmp, iter, user_key, value, &amp;s);
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>iter-&gt;status().ok()) {
        s = iter-&gt;status();
        <span class="org-keyword">delete</span> iter;
        <span class="org-keyword">return</span> s;
      } <span class="org-keyword">else</span> {
        <span class="org-keyword">delete</span> iter;
        <span class="org-keyword">if</span> (done) {
          <span class="org-keyword">return</span> s;
        }
      }
    }
  }

  <span class="org-keyword">return</span> <span class="org-constant">Status</span>::NotFound(Slice());  <span class="org-comment-delimiter">// </span><span class="org-comment">Use an empty error message for speed</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline115"></a>GetValue<br  /><div class="outline-text-5" id="text-10-3-11-12">
<p>
GetValue根据某个iter和key判断这个key是否为想查询的key.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">If "*iter" points at a value or deletion for user_key, store</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">either the value, or a NotFound error and return true.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Else return false.</span>
<span class="org-keyword">static</span> <span class="org-type">bool</span> <span class="org-function-name">GetValue</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">cmp</span>,
                     <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">user_key</span>,
                     <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>,
                     <span class="org-type">Status</span>* <span class="org-variable-name">s</span>) {
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>iter-&gt;Valid()) {
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
  <span class="org-type">ParsedInternalKey</span> <span class="org-variable-name">parsed_key</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;iterator&#37324;&#38754;&#26159;internal key.&#35299;&#26512;&#20986;parsed internal key&#20986;&#26469;.</span>
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ParseInternalKey(iter-&gt;key(), &amp;parsed_key)) {
    *s = <span class="org-constant">Status</span>::Corruption(<span class="org-string">"corrupted key for "</span>, user_key);
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27604;&#36739;user key&#20869;&#23481;&#26159;&#21542;&#19968;&#33268;.&#36825;&#37324;&#27809;&#26377;&#32771;&#34385;sequence number.</span>
  <span class="org-keyword">if</span> (cmp-&gt;Compare(parsed_key.user_key, user_key) != 0) {
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#21028;&#26029;&#36825;&#20010;key&#26159;&#21542;&#26631;&#35760;&#21024;&#38500;.</span>
  <span class="org-keyword">switch</span> (parsed_key.type) {
    <span class="org-keyword">case</span> kTypeDeletion:
      *s = <span class="org-constant">Status</span>::NotFound(Slice());  <span class="org-comment-delimiter">// </span><span class="org-comment">Use an empty error message for speed</span>
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> kTypeValue: {
      <span class="org-type">Slice</span> <span class="org-variable-name">v</span> = iter-&gt;value();
      value-&gt;assign(v.data(), v.size());
      <span class="org-keyword">break</span>;
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline116"></a>UpdateStats<br  /><div class="outline-text-5" id="text-10-3-11-13">
<p>
根据stats来更新version内部状态.设置将要compaction文件以及对应的level是什么.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">Version</span>::<span class="org-function-name">UpdateStats</span>(<span class="org-keyword">const</span> <span class="org-type">GetStats</span>&amp; <span class="org-variable-name">stats</span>) {
  <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = stats.seek_file; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;stats&#37324;&#38754;&#26631;&#35760;&#20102;&#25968;&#25454;&#30340;&#35805;.</span>
  <span class="org-keyword">if</span> (f != <span class="org-constant">NULL</span>) {
    f-&gt;allowed_seeks--; <span class="org-comment-delimiter">//</span>
    <span class="org-keyword">if</span> (f-&gt;allowed_seeks &lt;= 0 &amp;&amp; file_to_compact_ == <span class="org-constant">NULL</span>) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline117"></a>GetOverlappingInputs<br  /><div class="outline-text-5" id="text-10-3-11-14">
<p>
得到某个level下面所有和[begin,end]有overlap的文件.语义不知道是否理解正确.因为代码里面有个地方没有太看懂.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Store in "*inputs" all files in "level" that overlap [begin,end]</span>
<span class="org-type">void</span> <span class="org-constant">Version</span>::<span class="org-function-name">GetOverlappingInputs</span>(
    <span class="org-type">int</span> <span class="org-variable-name">level</span>,
    <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>* <span class="org-variable-name">begin</span>,
    <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>* <span class="org-variable-name">end</span>,
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;* <span class="org-variable-name">inputs</span>) {
  inputs-&gt;clear();
  <span class="org-type">Slice</span> <span class="org-variable-name">user_begin</span>, <span class="org-variable-name">user_end</span>;
  <span class="org-keyword">if</span> (begin != <span class="org-constant">NULL</span>) {
    user_begin = begin-&gt;user_key();
  }
  <span class="org-keyword">if</span> (end != <span class="org-constant">NULL</span>) {
    user_end = end-&gt;user_key();
  }
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">user_cmp</span> = vset_-&gt;icmp_.user_comparator();
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files_[level].size(); ) {
    <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = files_[level][i++];
    <span class="org-keyword">const</span> <span class="org-type">Slice</span> <span class="org-variable-name">file_start</span> = f-&gt;smallest.user_key();
    <span class="org-keyword">const</span> <span class="org-type">Slice</span> <span class="org-variable-name">file_limit</span> = f-&gt;largest.user_key();
    <span class="org-keyword">if</span> (begin != <span class="org-constant">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">"f" is completely before specified range; skip it</span>
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (end != <span class="org-constant">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">"f" is completely after specified range; skip it</span>
    } <span class="org-keyword">else</span> {
      inputs-&gt;push_back(f);
      <span class="org-keyword">if</span> (level == 0) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">todo:&#23454;&#29616;&#19978;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;&#21543;.&#30475;&#19978;&#21435;&#23545;&#20110;level0&#30340;&#35805;&#20284;&#20046;&#22312;&#19981;&#26029;&#22320;&#36807;&#22823;&#33539;&#22260;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Level-0 files may overlap each other.  So check if the newly</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">added file has expanded the range.  If so, restart search.</span>
        <span class="org-keyword">if</span> (begin != <span class="org-constant">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; 0) {
          user_begin = file_start;
          inputs-&gt;clear();
          i = 0;
        } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (end != <span class="org-constant">NULL</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_end) &gt; 0) {
          user_end = file_limit;
          inputs-&gt;clear();
          i = 0;
        }
      }
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline118"></a>OverlapInLevel<br  /><div class="outline-text-5" id="text-10-3-11-15">
<p>
判断某个level里面是否有文件和[small,large]这个范围内容的key重叠
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">Version</span>::<span class="org-function-name">OverlapInLevel</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>,
                             <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">smallest_user_key</span>,
                             <span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">largest_user_key</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">(level&gt;0)&#30340;&#35805;&#34920;&#31034;&#27599;&#20010;&#25991;&#20214;&#27809;&#26377;&#37325;&#21472;&#30340;&#37096;&#20998;.</span>
  <span class="org-keyword">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; 0), files_[level],
                               smallest_user_key, largest_user_key);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline119"></a>PickLevelForMemTableOutput<br  /><div class="outline-text-5" id="text-10-3-11-16">
<p>
根据[small,large]这个范畴选择某个level来作为memtable的output.这个range应该就是memtable的range.
这个策略比较精巧。这个策略在常数部分定义注释里面给出来了。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">db/dbformat.h</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;level0&#36807;&#20302;&#30340;&#35805;&#37027;&#20040;&#20250;&#36896;&#25104;&#36807;&#22810;compaction</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;level0&#22810;&#39640;&#30340;&#35805;&#37027;&#20040;&#20250;&#28010;&#36153;&#30913;&#30424;&#31354;&#38388;&#22240;&#20026;key&#30340;&#37325;&#22797;.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Maximum level to which a new compacted memtable is pushed if it</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">does not create overlap.  We try to push to level 2 to avoid the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">relatively expensive level 0=&gt;1 compactions and to avoid some</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">expensive manifest file operations.  We do not push all the way to</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">the largest level since that can generate a lot of wasted disk</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">space if the same key space is being repeatedly overwritten.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kMaxMemCompactLevel</span> = 2;

<span class="org-comment-delimiter">// </span><span class="org-comment">db/version_set.cc</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kTargetFileSize</span> = 2 * 1048576;

<span class="org-comment-delimiter">// </span><span class="org-comment">Maximum bytes of overlaps in grandparent (i.e., level+2) before we</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">stop building a single file in a level-&gt;level+1 compaction.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int64_t</span> <span class="org-variable-name">kMaxGrandParentOverlapBytes</span> = 10 * kTargetFileSize;
</pre>
</div>

<p>
#=BEGIN_SRC C++
int Version::PickLevelForMemTableOutput(
    const Slice&amp; smallest_user_key,
    const Slice&amp; largest_user_key) {
  int level = 0;
  // 首先判断和level0是否有overlap.如果有overlapd的话那么选择level0.
  if (!OverlapInLevel(0, &amp;smallest_user_key, &amp;largest_user_key)) {
    <i>/ Push to next level if there is no overlap in next level,
    /</i> and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));
    std::vector&lt;FileMetaData*&gt; overlaps;
    while (level &lt; config::kMaxMemCompactLevel) {
      <i>/ 判断和其他level是否有overlap.如果存在overlap的那么也选择.
      /</i> &gt;0的level是不允许overlap的.
      if (OverlapInLevel(level + 1, &amp;smallest_user_key, &amp;largest_user_key)) {
        break;
      }
      <i>/ 如果没有overlap的话那么判断和grandparent level重叠文件.判断重叠文件大小.
      /</i> 这个策略没有太明白.
      <i>/ 关于这个策略估计可以从Compaction::IsTrivialMove的注释里面看到.这里应该是担心grand parent本身就存在很多overlap
      /</i> 如果放在level+1做compaction的话，会造成grand parent这个部分合并时间过长.
      <i>/ 从值上来看意思应该是存在overlap的文件数目不应该超过10个(假设每个overlap文件都是MaxSizeForLevel的).
  /</i> Avoid a move if there is lots of overlapping grandparent data.
   <i>/ Otherwise, the move could create a parent file that will require
  /</i> a very expensive merge later on.
      GetOverlappingInputs(level + 2, &amp;start, &amp;limit, &amp;overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum &gt; kMaxGrandParentOverlapBytes) {
        break;
      }
      level++;
    }
  }
  return level;
}
#+END_SRC
</p>
</div></li>

<li><a id="orgheadline120"></a>DebugString<br  /><div class="outline-text-5" id="text-10-3-11-17">
<p>
DebugString作为Version的调试信息打印出来.我们可以稍微得到一点启发吧.尤其如果是自己调试的话.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-constant">Version</span>::<span class="org-function-name">DebugString</span>() <span class="org-keyword">const</span> {
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">r</span>;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">E.g.,</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">--- level 1 ---</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">17:123['a' .. 'd']</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">20:43['e' .. 'g']</span>
    r.append(<span class="org-string">"--- level "</span>);
    AppendNumberTo(&amp;r, level);
    r.append(<span class="org-string">" ---\n"</span>);
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span> = files_[level];
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files.size(); i++) {
      r.push_back(<span class="org-string">' '</span>);
      AppendNumberTo(&amp;r, files[i]-&gt;number); <span class="org-comment-delimiter">// </span><span class="org-comment">file_number</span>
      r.push_back(<span class="org-string">':'</span>);
      AppendNumberTo(&amp;r, files[i]-&gt;file_size); <span class="org-comment-delimiter">// </span><span class="org-comment">file&#22823;&#23567;.</span>
      r.append(<span class="org-string">"["</span>);
      r.append(files[i]-&gt;smallest.DebugString()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#23567;&#21644;&#26368;&#22823;&#30340;key&#30340;&#25171;&#21360;.</span>
      r.append(<span class="org-string">" .. "</span>);
      r.append(files[i]-&gt;largest.DebugString());
      r.append(<span class="org-string">"]\n"</span>);
    }
  }
  <span class="org-keyword">return</span> r;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline142" class="outline-4">
<h4 id="orgheadline142"><span class="section-number-4">10.3.12</span> VersionSet</h4>
<div class="outline-text-4" id="text-10-3-12">
<p>
db/version_set.h VersionSet用来管理不同的Version并且应该维护了一些全局信息.还是首先看看结构
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">VersionSet</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">VersionSet</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>,
             <span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-variable-name">options</span>,
             <span class="org-type">TableCache</span>* <span class="org-variable-name">table_cache</span>,
             <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>*);
  ~<span class="org-function-name">VersionSet</span>();
 <span class="org-keyword">private</span>:
  <span class="org-type">Env</span>* <span class="org-keyword">const</span> <span class="org-variable-name">env_</span>;
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">dbname_</span>;
  <span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-keyword">const</span> <span class="org-variable-name">options_</span>;
  <span class="org-type">TableCache</span>* <span class="org-keyword">const</span> <span class="org-variable-name">table_cache_</span>;
  <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span> <span class="org-variable-name">icmp_</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">next_file_number_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#19968;&#20010;&#20998;&#37197;&#30340;file number</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">manifest_file_number_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">manifest file number.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">last_sequence_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#27425;&#25805;&#20316;&#30340;sequence.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;LogNumber&#21644;PrevLogNumber&#27880;&#37322;&#21487;&#20197;&#30475;&#20986;&#26469;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#21035;&#34920;&#31034;&#24403;&#21069;&#20351;&#29992;&#30340;log number&#20197;&#21450;&#20043;&#21069;&#20351;&#29992;&#30340;log number(&#24403;&#21069;&#27491;&#22312;&#34987;&#21387;&#32553;).</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">log_number_</span>; <span class="org-comment-delimiter">//</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">prev_log_number_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">0 or backing store for memtable being compacted</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Opened lazily</span>
  <span class="org-type">WritableFile</span>* <span class="org-variable-name">descriptor_file_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">manifest&#25991;&#20214;</span>
  <span class="org-constant">log</span>::<span class="org-type">Writer</span>* <span class="org-variable-name">descriptor_log_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">manifest&#20197;log&#24418;&#24335;&#25171;&#24320;.</span>
  <span class="org-type">Version</span> <span class="org-variable-name">dummy_versions_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Head of circular doubly-linked list of versions. // &#20026;&#20102;&#32452;&#32455;&#31216;&#20026;&#38142;&#34920;.</span>
  <span class="org-type">Version</span>* <span class="org-variable-name">current_</span>;        <span class="org-comment-delimiter">// </span><span class="org-comment">== dummy_versions_.prev_ // &#24403;&#21069;version</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Per-level key at which the next compaction at that level should start.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Either an empty string, or a valid InternalKey.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#27599;&#23618;&#30340;&#35805;&#37117;&#20250;&#35774;&#32622;&#19968;&#20010;key.&#21482;&#26377;&gt;&#36825;&#23618;&#35774;&#32622;&#30340;key&#25165;&#20801;&#35768;&#36827;&#34892;compaction.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">compact_pointer_</span>[<span class="org-constant">config</span>::kNumLevels]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;level&#36827;&#34892;compaction&#20351;&#29992;&#30340;internal key</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">todo:&#20284;&#20046;&#27599;&#20010;level&#36827;&#34892;compaction&#37117;&#37197;&#19978;&#20102;&#19968;&#20010;internal key</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">DONE:&#35760;&#24405;&#27599;&#23618;&#30340;&#26368;&#22823;key.</span>
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline122"></a>VersionSet<br  /><div class="outline-text-5" id="text-10-3-12-1">
<p>
首先看看构造函数和析构函数.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">VersionSet</span>::<span class="org-function-name">VersionSet</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>,
                       <span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-variable-name">options</span>,
                       <span class="org-type">TableCache</span>* <span class="org-variable-name">table_cache</span>,
                       <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>* <span class="org-variable-name">cmp</span>)
    : env_(options-&gt;env),
      dbname_(dbname),
      options_(options),
      table_cache_(table_cache),
      icmp_(*cmp),
      next_file_number_(2),
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#38754;&#36825;&#20123;&#23383;&#27573;&#37117;&#26159;&#36890;&#36807;Recover&#24674;&#22797;&#30340;.</span>
      manifest_file_number_(0),  <span class="org-comment-delimiter">// </span><span class="org-comment">Filled by Recover()</span>
      last_sequence_(0),
      log_number_(0),
      prev_log_number_(0),
      descriptor_file_(<span class="org-constant">NULL</span>),
      descriptor_log_(<span class="org-constant">NULL</span>),
      dummy_versions_(<span class="org-keyword">this</span>),
      current_(<span class="org-constant">NULL</span>) {
  AppendVersion(<span class="org-keyword">new</span> <span class="org-type">Version</span>(<span class="org-keyword">this</span>)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28155;&#21152;&#19968;&#20010;&#24403;&#21069;version.</span>
}
<span class="org-constant">VersionSet</span>::~<span class="org-function-name">VersionSet</span>() {
  current_-&gt;Unref();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26512;&#26500;&#26102;&#20505;&#24517;&#39035;&#30830;&#20445;&#37324;&#38754;&#27809;&#26377;&#20219;&#20309;&#29256;&#26412;.</span>
  assert(dummy_versions_.next_ == &amp;dummy_versions_);  <span class="org-comment-delimiter">// </span><span class="org-comment">List must be empty</span>
  <span class="org-keyword">delete</span> descriptor_log_;
  <span class="org-keyword">delete</span> descriptor_file_;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline123"></a>NeedsCompaction<br  /><div class="outline-text-5" id="text-10-3-12-2">
<p>
当前versionset是否需要触发compaction操作.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Returns true iff some level needs a compaction.</span>
<span class="org-type">bool</span> <span class="org-function-name">NeedsCompaction</span>() <span class="org-keyword">const</span> {
  <span class="org-type">Version</span>* <span class="org-variable-name">v</span> = current_;
  <span class="org-keyword">return</span> (v-&gt;compaction_score_ &gt;= 1) || (v-&gt;file_to_compact_ != <span class="org-constant">NULL</span>);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline124"></a>AppendVersion<br  /><div class="outline-text-5" id="text-10-3-12-3">
<p>
添加version.非常简单修改引用计数挂载链表上.将version挂在version_set下面的话可以使得
version_set了解到哪些文件依然是被正在使用的.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">AppendVersion</span>(<span class="org-type">Version</span>* <span class="org-variable-name">v</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Make "v" current</span>
  assert(v-&gt;refs_ == 0);
  assert(v != current_);
  <span class="org-keyword">if</span> (current_ != <span class="org-constant">NULL</span>) {
    current_-&gt;Unref();
  }
  current_ = v;
  v-&gt;Ref();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Append to linked list</span>
  v-&gt;prev_ = dummy_versions_.prev_;
  v-&gt;next_ = &amp;dummy_versions_;
  v-&gt;prev_-&gt;next_ = v;
  v-&gt;next_-&gt;prev_ = v;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline125"></a>NumLevelFiles<br  /><div class="outline-text-5" id="text-10-3-12-4">
<p>
得到某个level的文件数目.以current这个Version来计算的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">NumLevelFiles</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>) <span class="org-keyword">const</span> {
  assert(level &gt;= 0);
  assert(level &lt; <span class="org-constant">config</span>::kNumLevels);
  <span class="org-keyword">return</span> current_-&gt;files_[level].size();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline126"></a>NumLevelBytes<br  /><div class="outline-text-5" id="text-10-3-12-5">
<p>
某个level的文件大小.以current这个Version来计算的.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int64_t</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">NumLevelBytes</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>) <span class="org-keyword">const</span> {
  assert(level &gt;= 0);
  assert(level &lt; <span class="org-constant">config</span>::kNumLevels);
  <span class="org-keyword">return</span> TotalFileSize(current_-&gt;files_[level]);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline127"></a>TotalFileSize<br  /><div class="outline-text-5" id="text-10-3-12-6">
<p>
根据file meta data得到所有文件大小.非常简单因为里面有file_size.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">int64_t</span> <span class="org-function-name">TotalFileSize</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span>) {
  <span class="org-type">int64_t</span> <span class="org-variable-name">sum</span> = 0;
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files.size(); i++) {
    sum += files[i]-&gt;file_size;
  }
  <span class="org-keyword">return</span> sum;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline128"></a>MarkFileNumberUsed<br  /><div class="outline-text-5" id="text-10-3-12-7">
<p>
标记当前使用了file_number进度.number表示已经使用的进度,所以下次分配必须+1.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">MarkFileNumberUsed</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">number</span>) {
  <span class="org-keyword">if</span> (next_file_number_ &lt;= number) {
    next_file_number_ = number + 1;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline129"></a>ApproximateOffsetOf<br  /><div class="outline-text-5" id="text-10-3-12-8">
<p>
判断这个key在数据库内部大致偏移是多少.从这个实现里面我们可以看到.对于level-0的文件并不是排序的
对于level&gt;0的文件都是按照range进行排序的。并且这个排序是按照smallest来进行排序的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">uint64_t</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">ApproximateOffsetOf</span>(<span class="org-type">Version</span>* <span class="org-variable-name">v</span>, <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>&amp; <span class="org-variable-name">ikey</span>) {
  <span class="org-type">uint64_t</span> <span class="org-variable-name">result</span> = 0;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span> = v-&gt;files_[level];
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files.size(); i++) {
      <span class="org-keyword">if</span> (icmp_.Compare(files[i]-&gt;largest, ikey) &lt;= 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27604;largest key&#22823;&#30340;&#35805;&#37027;&#20040;&#36825;&#20010;</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#20559;&#31227;&#38656;&#35201;&#31639;&#19978;&#25972;&#20010;&#25991;&#20214;.&#20294;&#26159;&#36825;&#37324;&#36824;&#21253;&#25324;&#20102;index block,meta block&#20197;&#21450;footer&#22823;&#23567;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#20197;&#21482;&#33021;&#22815;&#35828;&#26159;&#22823;&#33268;&#22823;&#23567;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Entire file is before "ikey", so just add the file size</span>
        result += files[i]-&gt;file_size;
      } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (icmp_.Compare(files[i]-&gt;smallest, ikey) &gt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;smallest&#27604;&#24403;&#21069;key&#22823;&#30340;&#35805;&#37027;&#20040;&#21462;&#28040;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Entire file is after "ikey", so ignore</span>
        <span class="org-keyword">if</span> (level &gt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;&gt;0&#30340;level&#37027;&#20040;&#21487;&#20197;&#30452;&#25509;&#21462;&#28040;.&#22240;&#20026;&#36825;&#20010;&#37096;&#20998;&#30340;file&#37117;&#26159;&#25353;&#29031;smallest&#25490;&#24207;&#30340;.</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">Files other than level 0 are sorted by meta-&gt;smallest, so</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">no further files in this level will contain data for</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">"ikey".</span>
          <span class="org-keyword">break</span>;
        }
      } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23384;&#22312;&#20132;&#38598;&#30340;&#35805;&#37027;&#20040;&#37027;&#20040;&#21487;&#20197;&#26500;&#36896;&#20986;Table&#23545;&#35937;&#25214;&#21040;&#36825;&#20010;key&#22823;&#33268;&#20559;&#31227;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">"ikey" falls in the range for this table.  Add the</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">approximate offset of "ikey" within the table.</span>
        <span class="org-type">Table</span>* <span class="org-variable-name">tableptr</span>;
        <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span> = table_cache_-&gt;NewIterator(
            ReadOptions(), files[i]-&gt;number, files[i]-&gt;file_size, &amp;tableptr);
        <span class="org-keyword">if</span> (tableptr != <span class="org-constant">NULL</span>) {
          result += tableptr-&gt;ApproximateOffsetOf(ikey.Encode());
        }
        <span class="org-keyword">delete</span> iter;
      }
    }
  }
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline130"></a>AddLiveFiles<br  /><div class="outline-text-5" id="text-10-3-12-9">
<p>
将version set里面所有version所持有的文件收集起来.非常简单:).
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">AddLiveFiles</span>(<span class="org-constant">std</span>::<span class="org-type">set</span>&lt;<span class="org-type">uint64_t</span>&gt;* <span class="org-variable-name">live</span>) {
  <span class="org-keyword">for</span> (<span class="org-type">Version</span>* <span class="org-variable-name">v</span> = dummy_versions_.next_;
       v != &amp;dummy_versions_;
       v = v-&gt;next_) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
      <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span> = v-&gt;files_[level];
      <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files.size(); i++) {
        live-&gt;insert(files[i]-&gt;number);
      }
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline131"></a>LevelSummary<br  /><div class="outline-text-5" id="text-10-3-12-10">
<p>
每层level的文件个数分别是多少.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-constant">VersionSet</span>::<span class="org-function-name">LevelSummary</span>(<span class="org-type">LevelSummaryStorage</span>* <span class="org-variable-name">scratch</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Update code if kNumLevels changes</span>
  assert(<span class="org-constant">config</span>::kNumLevels == 7);
  snprintf(scratch-&gt;buffer, <span class="org-keyword">sizeof</span>(scratch-&gt;buffer),
           <span class="org-string">"files[ %d %d %d %d %d %d %d ]"</span>,
           <span class="org-type">int</span>(current_-&gt;files_[0].size()),
           <span class="org-type">int</span>(current_-&gt;files_[1].size()),
           <span class="org-type">int</span>(current_-&gt;files_[2].size()),
           <span class="org-type">int</span>(current_-&gt;files_[3].size()),
           <span class="org-type">int</span>(current_-&gt;files_[4].size()),
           <span class="org-type">int</span>(current_-&gt;files_[5].size()),
           <span class="org-type">int</span>(current_-&gt;files_[6].size()));
  <span class="org-keyword">return</span> scratch-&gt;buffer;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline132"></a>WriteSnapshot<br  /><div class="outline-text-5" id="text-10-3-12-11">
<p>
将当前current version写入到磁盘记为log.方式是将内容copy到version edit对象里面去然后持久化.
过程还是非常简单吧:).
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">WriteSnapshot</span>(<span class="org-constant">log</span>::<span class="org-type">Writer</span>* <span class="org-variable-name">log</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">TODO: Break up into multiple records to reduce memory usage on recovery?</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Save metadata</span>
  <span class="org-type">VersionEdit</span> <span class="org-variable-name">edit</span>;
  edit.SetComparatorName(icmp_.user_comparator()-&gt;Name());

  <span class="org-comment-delimiter">// </span><span class="org-comment">Save compaction pointers</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>compact_pointer_[level].empty()) {
      <span class="org-type">InternalKey</span> <span class="org-variable-name">key</span>;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Save files</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span> = current_-&gt;files_[level];
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files.size(); i++) {
      <span class="org-keyword">const</span> <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = files[i];
      edit.AddFile(level, f-&gt;number, f-&gt;file_size, f-&gt;smallest, f-&gt;largest);
    }
  }

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">record</span>;
  edit.EncodeTo(&amp;record);
  <span class="org-keyword">return</span> log-&gt;AddRecord(record);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline133"></a>Finalize<br  /><div class="outline-text-5" id="text-10-3-12-12">
<p>
所谓的Finalize的含义应该是，如果我们不希望修改version这个结构之后我们应该做的事情。可能叫做Finish会更好。
相当于针对这个version而言的话，最高一级的compaction level是什么，分数是多少.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">Finalize</span>(<span class="org-type">Version</span>* <span class="org-variable-name">v</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Precomputed best level for next compaction</span>
  <span class="org-type">int</span> <span class="org-variable-name">best_level</span> = -1;
  <span class="org-type">double</span> <span class="org-variable-name">best_score</span> = -1;

  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels-1; level++) {
    <span class="org-type">double</span> <span class="org-variable-name">score</span>;
    <span class="org-keyword">if</span> (level == 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">We treat level-0 specially by bounding the number of files</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">instead of number of bytes for two reasons:</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">(1) With larger write-buffer sizes, it is nice not to do too</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">many level-0 compactions.</span>
      <span class="org-comment-delimiter">//</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">(2) The files in level-0 are merged on every read and</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">therefore we wish to avoid too many files when the individual</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">file size is small (perhaps because of a small write-buffer</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">setting, or very high compression ratios, or lots of</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">overwrites/deletions).</span>
      score = v-&gt;files_[level].size() /
          <span class="org-keyword">static_cast</span>&lt;<span class="org-type">double</span>&gt;(<span class="org-constant">config</span>::kL0_CompactionTrigger);
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Compute the ratio of current size to size limit.</span>
      <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">level_bytes</span> = TotalFileSize(v-&gt;files_[level]);
      score = <span class="org-keyword">static_cast</span>&lt;<span class="org-type">double</span>&gt;(level_bytes) / MaxBytesForLevel(level);
    }

    <span class="org-keyword">if</span> (score &gt; best_score) {
      best_level = level;
      best_score = score;
    }
  }

  v-&gt;compaction_level_ = best_level;
  v-&gt;compaction_score_ = best_score;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline134"></a>Recover<br  /><div class="outline-text-5" id="text-10-3-12-13">
<p>
从db_impl.cc里面的DB::Open可以看到,这里的Recover并没有将剩余的version_edit回放完成.
回放这个部分在LogAndApply里面完成.所以Recover可能只是恢复到以前某个状态.将当前的
CURRENT里面的manifest文件回放之后就得到最新的内容.然后根据里面的log信息回放后面的内容.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">Recover</span>() {
  <span class="org-keyword">struct</span> <span class="org-type">LogReporter</span> : <span class="org-keyword">public</span> <span class="org-constant">log</span>::<span class="org-constant">Reader</span>::<span class="org-type">Reporter</span> {
    <span class="org-type">Status</span>* <span class="org-variable-name">status</span>;
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Corruption</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>, <span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">s</span>) {
      <span class="org-keyword">if</span> (<span class="org-keyword">this</span>-&gt;status-&gt;ok()) *<span class="org-keyword">this</span>-&gt;status = s;
    }
  };

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#24403;&#21069;current&#36825;&#20010;&#20869;&#23481;,&#24471;&#21040;&#26368;&#26032;&#30340;manifest&#25991;&#20214;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Read "CURRENT" file, which contains a pointer to the current manifest file</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">current</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = ReadFileToString(env_, CurrentFileName(dbname_), &amp;current);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
    <span class="org-keyword">return</span> s;
  }
  <span class="org-keyword">if</span> (current.empty() || current[current.size()-1] != <span class="org-string">'\n'</span>) {
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"CURRENT file does not end with newline"</span>);
  }
  current.resize(current.size() - 1);

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">dscname</span> = dbname_ + <span class="org-string">"/"</span> + current;
  <span class="org-type">SequentialFile</span>* <span class="org-variable-name">file</span>;
  s = env_-&gt;NewSequentialFile(dscname, &amp;file);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
    <span class="org-keyword">return</span> s;
  }

  <span class="org-type">bool</span> <span class="org-variable-name">have_log_number</span> = <span class="org-constant">false</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">have_prev_log_number</span> = <span class="org-constant">false</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">have_next_file</span> = <span class="org-constant">false</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">have_last_sequence</span> = <span class="org-constant">false</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">next_file</span> = 0;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">last_sequence</span> = 0;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">log_number</span> = 0;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">prev_log_number</span> = 0;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#30456;&#24403;&#20110;&#20174;empty status&#26469;&#26500;&#24314;current version.</span>
  <span class="org-type">Builder</span> <span class="org-variable-name">builder</span>(<span class="org-keyword">this</span>, current_);

  {
    <span class="org-type">LogReporter</span> <span class="org-variable-name">reporter</span>;
    reporter.status = &amp;s;
    <span class="org-constant">log</span>::<span class="org-type">Reader</span> <span class="org-variable-name">reader</span>(file, &amp;reporter, <span class="org-constant">true</span><span class="org-comment-delimiter">/*</span><span class="org-comment">checksum*/</span>, 0<span class="org-comment-delimiter">/*</span><span class="org-comment">initial_offset*/</span>);
    <span class="org-type">Slice</span> <span class="org-variable-name">record</span>;
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">scratch</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#29031;&#27599;&#26465;log&#20869;&#23481;&#35835;&#21462;.&#37324;&#38754;&#30340;&#20869;&#23481;&#37117;&#26159;version edit.</span>
    <span class="org-keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) {
      <span class="org-type">VersionEdit</span> <span class="org-variable-name">edit</span>;
      s = edit.DecodeFrom(record);
      <span class="org-keyword">if</span> (s.ok()) {
        <span class="org-keyword">if</span> (edit.has_comparator_ &amp;&amp;
            edit.comparator_ != icmp_.user_comparator()-&gt;Name()) {
          s = <span class="org-constant">Status</span>::InvalidArgument(
              edit.comparator_ + <span class="org-string">"does not match existing comparator "</span>,
              icmp_.user_comparator()-&gt;Name());
        }
      }

      <span class="org-comment-delimiter">// </span><span class="org-comment">&#30452;&#25509;apply&#19978;&#21435;.</span>
      <span class="org-keyword">if</span> (s.ok()) {
        builder.Apply(&amp;edit);
      }

      <span class="org-keyword">if</span> (edit.has_log_number_) {
        log_number = edit.log_number_;
        have_log_number = <span class="org-constant">true</span>;
      }

      <span class="org-keyword">if</span> (edit.has_prev_log_number_) {
        prev_log_number = edit.prev_log_number_;
        have_prev_log_number = <span class="org-constant">true</span>;
      }

      <span class="org-keyword">if</span> (edit.has_next_file_number_) {
        next_file = edit.next_file_number_;
        have_next_file = <span class="org-constant">true</span>;
      }

      <span class="org-keyword">if</span> (edit.has_last_sequence_) {
        last_sequence = edit.last_sequence_;
        have_last_sequence = <span class="org-constant">true</span>;
      }
    }
  }
  <span class="org-keyword">delete</span> file;
  file = <span class="org-constant">NULL</span>;

  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>have_next_file) {
      s = <span class="org-constant">Status</span>::Corruption(<span class="org-string">"no meta-nextfile entry in descriptor"</span>);
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>have_log_number) {
      s = <span class="org-constant">Status</span>::Corruption(<span class="org-string">"no meta-lognumber entry in descriptor"</span>);
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>have_last_sequence) {
      s = <span class="org-constant">Status</span>::Corruption(<span class="org-string">"no last-sequence-number entry in descriptor"</span>);
    }

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>have_prev_log_number) {
      prev_log_number = 0;
    }

    MarkFileNumberUsed(prev_log_number);
    MarkFileNumberUsed(log_number);
  }

  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-type">Version</span>* <span class="org-variable-name">v</span> = <span class="org-keyword">new</span> <span class="org-type">Version</span>(<span class="org-keyword">this</span>);
    builder.SaveTo(v);
    <span class="org-comment-delimiter">// </span><span class="org-comment">Install recovered version</span>
    Finalize(v);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22686;&#21152;&#36825;&#20040;&#19968;&#20010;version&#20316;&#20026;&#24403;&#21069;current version.</span>
    AppendVersion(v);
    manifest_file_number_ = next_file;
    next_file_number_ = next_file + 1;
    last_sequence_ = last_sequence;
    log_number_ = log_number;
    prev_log_number_ = prev_log_number;
  }

  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline135"></a>LogAndApply<br  /><div class="outline-text-5" id="text-10-3-12-14">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">LogAndApply</span>(<span class="org-type">VersionEdit</span>* <span class="org-variable-name">edit</span>, <span class="org-constant">port</span>::<span class="org-type">Mutex</span>* <span class="org-variable-name">mu</span>) {
  <span class="org-keyword">if</span> (edit-&gt;has_log_number_) {
    assert(edit-&gt;log_number_ &gt;= log_number_);
    assert(edit-&gt;log_number_ &lt; next_file_number_);
  } <span class="org-keyword">else</span> {
    edit-&gt;SetLogNumber(log_number_);
  }

  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>edit-&gt;has_prev_log_number_) {
    edit-&gt;SetPrevLogNumber(prev_log_number_);
  }

  edit-&gt;SetNextFile(next_file_number_);
  edit-&gt;SetLastSequence(last_sequence_);

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#36807;&#31243;&#24212;&#35813;&#26159;&#23558;edit&#30340;&#20462;&#25913;&#25918;&#22312;current_&#37324;&#38754;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;edit&#20316;&#29992;&#22312;current&#19978;&#38754;&#65292;&#23558;current_&#20445;&#23384;&#21040;v&#37324;&#38754;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23545;v&#36827;&#34892;finish.</span>
  <span class="org-type">Version</span>* <span class="org-variable-name">v</span> = <span class="org-keyword">new</span> <span class="org-type">Version</span>(<span class="org-keyword">this</span>);
  {
    <span class="org-type">Builder</span> <span class="org-variable-name">builder</span>(<span class="org-keyword">this</span>, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }
  Finalize(v);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Initialize new descriptor log file if necessary by creating</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">a temporary file that contains a snapshot of the current version.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">new_manifest_file</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  <span class="org-keyword">if</span> (descriptor_log_ == <span class="org-constant">NULL</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">No reason to unlock *mu here since we only hit this path in the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">first call to LogAndApply (when opening the database).</span>
    assert(descriptor_file_ == <span class="org-constant">NULL</span>);
    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
    edit-&gt;SetNextFile(next_file_number_);
    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);
    <span class="org-keyword">if</span> (s.ok()) {
      descriptor_log_ = <span class="org-keyword">new</span> <span class="org-constant">log</span>::<span class="org-type">Writer</span>(descriptor_file_);
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;current&#20570;snapshot&#20445;&#23384;&#22312;descriptor log&#37324;&#38754;.</span>
      s = WriteSnapshot(descriptor_log_);
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Unlock during expensive MANIFEST log write</span>
  {
    mu-&gt;Unlock();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Write new record to MANIFEST log</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20010;&#20462;&#25913;&#20063;&#20445;&#23384;&#22312;log&#37324;&#38754;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#29616;&#22312;&#27604;&#36739;&#25285;&#24515;&#26368;&#21518;&#30340;&#32467;&#26500;.&#20284;&#20046;&#29616;&#22312;snapshot&#20197;&#21450;log&#20869;&#23481;&#37117;&#28151;&#22312;&#19968;&#36215;&#20102;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20043;&#21069;&#22312;descriptor_log&#37324;&#38754;&#22635;&#20889;&#20102;current version&#20869;&#23481;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#32780;&#36825;&#37324;&#36824;&#28155;&#21152;&#20102;edit&#22686;&#37327;&#20869;&#23481;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26684;&#24335;&#29616;&#22312;&#30475;&#19978;&#21435;&#36824;&#22909;.&#21040;&#26102;&#20505;&#21487;&#33021;&#38656;&#35201;&#20027;&#35201;&#30475;&#30475;Recover&#20869;&#23481;.</span>
    <span class="org-keyword">if</span> (s.ok()) {
      <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">record</span>;
      edit-&gt;EncodeTo(&amp;record);
      s = descriptor_log_-&gt;AddRecord(record);
      <span class="org-keyword">if</span> (s.ok()) {
        s = descriptor_file_-&gt;Sync(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#25105;&#20204;&#38656;&#35201;&#20570;sync.</span>
      }
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">If we just created a new descriptor file, install it by writing a</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">new CURRENT file that points to it.</span>
    <span class="org-keyword">if</span> (s.ok() &amp;&amp; <span class="org-negation-char">!</span>new_manifest_file.empty()) {
      s = SetCurrentFile(env_, dbname_, manifest_file_number_);
    }

    mu-&gt;Lock();
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Install the new version</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20316;&#20026;&#24403;&#21069;current version&#23384;&#22312;.</span>
  <span class="org-keyword">if</span> (s.ok()) {
    AppendVersion(v);
    log_number_ = edit-&gt;log_number_;
    prev_log_number_ = edit-&gt;prev_log_number_;
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">delete</span> v;
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>new_manifest_file.empty()) {
      <span class="org-keyword">delete</span> descriptor_log_;
      <span class="org-keyword">delete</span> descriptor_file_;
      descriptor_log_ = <span class="org-constant">NULL</span>;
      descriptor_file_ = <span class="org-constant">NULL</span>;
      env_-&gt;DeleteFile(new_manifest_file);
    }
  }

  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline136"></a>GetRange<br  /><div class="outline-text-5" id="text-10-3-12-15">
<p>
得到input files里面的最大和最小key.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Stores the minimal range that covers all entries in inputs in</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">*smallest, *largest.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: inputs is not empty</span>
<span class="org-type">void</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">GetRange</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">inputs</span>,
                          <span class="org-type">InternalKey</span>* <span class="org-variable-name">smallest</span>,
                          <span class="org-type">InternalKey</span>* <span class="org-variable-name">largest</span>) {
  assert(<span class="org-negation-char">!</span>inputs.empty());
  smallest-&gt;Clear();
  largest-&gt;Clear();
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; inputs.size(); i++) {
    <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = inputs[i];
    <span class="org-keyword">if</span> (i == 0) {
      *smallest = f-&gt;smallest;
      *largest = f-&gt;largest;
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">if</span> (icmp_.Compare(f-&gt;smallest, *smallest) &lt; 0) {
        *smallest = f-&gt;smallest;
      }
      <span class="org-keyword">if</span> (icmp_.Compare(f-&gt;largest, *largest) &gt; 0) {
        *largest = f-&gt;largest;
      }
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline137"></a>PickCompaction<br  /><div class="outline-text-5" id="text-10-3-12-16">
<p>
选择一个Compaction来进行操作.对于选择Compaction应该比较具有策略性的。然后丢给DB去执行这个Compaction操作.
PickCompaction和CompactRange都是compaction行为.不过PickCompaction是自动触发的，而CompactRange
是用户自己手动触发的.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Compaction</span>* <span class="org-constant">VersionSet</span>::<span class="org-function-name">PickCompaction</span>() {
  <span class="org-type">Compaction</span>* <span class="org-variable-name">c</span>;
  <span class="org-type">int</span> <span class="org-variable-name">level</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">We prefer compactions triggered by too much data in a level over  // the compactions triggered by seeks.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#25454;&#24403;&#21069;version&#30340;&#32479;&#35745;&#32467;&#26524;&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;compaction.</span>
  <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-variable-name">size_compaction</span> = (current_-&gt;compaction_score_ &gt;= 1);
  <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-variable-name">seek_compaction</span> = (current_-&gt;file_to_compact_ != <span class="org-constant">NULL</span>);
  <span class="org-keyword">if</span> (size_compaction) {
    level = current_-&gt;compaction_level_;
    assert(level &gt;= 0);
    assert(level+1 &lt; <span class="org-constant">config</span>::kNumLevels);
    c = <span class="org-keyword">new</span> <span class="org-type">Compaction</span>(level);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Pick the first file that comes after compact_pointer_[level]</span>
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; current_-&gt;files_[level].size(); i++) {
      <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = current_-&gt;files_[level][i];
      <span class="org-keyword">if</span> (compact_pointer_[level].empty() ||
          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; 0) {
        c-&gt;inputs_[0].push_back(f);
        <span class="org-keyword">break</span>;
      }
    }
    <span class="org-keyword">if</span> (c-&gt;inputs_[0].empty()) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Wrap-around to the beginning of the key space</span>
      c-&gt;inputs_[0].push_back(current_-&gt;files_[level][0]);
    }
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (seek_compaction) {
    level = current_-&gt;file_to_compact_level_;
    c = <span class="org-keyword">new</span> <span class="org-type">Compaction</span>(level);
    c-&gt;inputs_[0].push_back(current_-&gt;file_to_compact_);
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#29616;&#22312;&#24050;&#32463;&#36873;&#25321;&#22909;&#20102;&#19968;&#20010;&#25991;&#20214;&#26469;&#36827;&#34892;compaction.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#24403;&#21069;&#30340;version +ref count.</span>
  c-&gt;input_version_ = current_;
  c-&gt;input_version_-&gt;Ref();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Files in level 0 may overlap each other, so pick up all overlapping ones</span>
  <span class="org-keyword">if</span> (level == 0) {
    <span class="org-type">InternalKey</span> <span class="org-variable-name">smallest</span>, <span class="org-variable-name">largest</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#37322;&#20889;&#30340;&#38750;&#24120;&#28165;&#26970;&#20102;.</span>
    GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);
    <span class="org-comment-delimiter">// </span><span class="org-comment">Note that the next call will discard the file we placed in</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">c-&gt;inputs_[0] earlier and replace it with an overlapping set</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">which will include the picked file.</span>
    current_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[0]);
    assert(<span class="org-negation-char">!</span>c-&gt;inputs_[0].empty());
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36873;&#25321;&#20102;level&#30340;&#25991;&#20214;&#20043;&#21518;&#38656;&#35201;&#36873;&#25321;level+1&#30340;&#25991;&#20214;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#25226;&#20854;&#20182;&#30340;input files&#23383;&#27573;&#22635;&#19978;.</span>
  SetupOtherInputs(c);

  <span class="org-keyword">return</span> c;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline138"></a>CompactRange<br  /><div class="outline-text-5" id="text-10-3-12-17">
<p>
DBImpl里面提供CompactRange打包成为一个Manual Compaction的请求提交到后端.然后判断
如果为Manual Compaction的话那么实际调用的还是VersionSet::CompactRange这个方法产生一个
Compaction对象真正进行执行.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Compaction</span>* <span class="org-constant">VersionSet</span>::<span class="org-function-name">CompactRange</span>(
    <span class="org-type">int</span> <span class="org-variable-name">level</span>,
    <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>* <span class="org-variable-name">begin</span>,
    <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>* <span class="org-variable-name">end</span>) {
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">inputs</span>;
  current_-&gt;GetOverlappingInputs(level, begin, end, &amp;inputs);
  <span class="org-keyword">if</span> (inputs.empty()) {
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Avoid compacting too much in one shot in case the range is large.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21387;&#32553;&#33539;&#22260;&#30340;&#35805;&#21487;&#20197;&#25552;&#20132;&#22810;&#20010;input files&#20316;&#20026;&#24213;&#23618;level&#36755;&#20837;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;&#36890;&#36807;&#25511;&#21046;&#22823;&#23567;&#26469;&#38480;&#21046;&#36755;&#20837;&#25991;&#20214;&#22810;&#23569;.</span>
  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">limit</span> = MaxFileSizeForLevel(level);
  <span class="org-type">uint64_t</span> <span class="org-variable-name">total</span> = 0;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; inputs.size(); i++) {
    <span class="org-type">uint64_t</span> <span class="org-variable-name">s</span> = inputs[i]-&gt;file_size;
    total += s;
    <span class="org-keyword">if</span> (total &gt;= limit) {
      inputs.resize(i + 1);
      <span class="org-keyword">break</span>;
    }
  }

  <span class="org-type">Compaction</span>* <span class="org-variable-name">c</span> = <span class="org-keyword">new</span> <span class="org-type">Compaction</span>(level);
  c-&gt;input_version_ = current_;
  c-&gt;input_version_-&gt;Ref();
  c-&gt;inputs_[0] = inputs;
  SetupOtherInputs(c);
  <span class="org-keyword">return</span> c;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline139"></a>GetRange2<br  /><div class="outline-text-5" id="text-10-3-12-18">
<p>
得到input1和input2两个文件compaction之后的最小和最大key.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Stores the minimal range that covers all entries in inputs1 and inputs2</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">in *smallest, *largest.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: inputs is not empty</span>
<span class="org-type">void</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">GetRange2</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">inputs1</span>,
                           <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">inputs2</span>,
                           <span class="org-type">InternalKey</span>* <span class="org-variable-name">smallest</span>,
                           <span class="org-type">InternalKey</span>* <span class="org-variable-name">largest</span>) {
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">all</span> = inputs1;
  all.insert(all.end(), inputs2.begin(), inputs2.end());
  GetRange(all, smallest, largest);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline140"></a>SetupOtherInputs<br  /><div class="outline-text-5" id="text-10-3-12-19">
<p>
将compaction的另外一层内容(input files)补齐.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">VersionSet</span>::<span class="org-function-name">SetupOtherInputs</span>(<span class="org-type">Compaction</span>* <span class="org-variable-name">c</span>) {
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">level</span> = c-&gt;level();
  <span class="org-type">InternalKey</span> <span class="org-variable-name">smallest</span>, <span class="org-variable-name">largest</span>;
  GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;level+1&#37324;&#38754;&#26377;&#21738;&#20123;&#25991;&#20214;&#26159;&#23384;&#22312;&#37325;&#21472;&#30340;.</span>
  current_-&gt;GetOverlappingInputs(level+1, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[1]);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Get entire range covered by compaction</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24471;&#21040;&#25972;&#20010;compaction&#25152;&#35206;&#30422;&#30340;&#33539;&#22260;</span>
  <span class="org-type">InternalKey</span> <span class="org-variable-name">all_start</span>, <span class="org-variable-name">all_limit</span>;
  GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);

  <span class="org-comment-delimiter">// </span><span class="org-comment">See if we can grow the number of inputs in "level" without</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">changing the number of "level+1" files we pick up.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35266;&#23519;&#26159;&#21542;&#21487;&#20197;&#25193;&#22823;level input files&#25968;&#37327;&#20294;&#26159;&#19981;&#36896;&#25104;level+1 input files&#25968;&#37327;&#21464;&#21270;.</span>
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>c-&gt;inputs_[1].empty()) {
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">expanded0</span>;
    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);
    <span class="org-keyword">if</span> (expanded0.size() &gt; c-&gt;inputs_[0].size()) {
      <span class="org-type">InternalKey</span> <span class="org-variable-name">new_start</span>, <span class="org-variable-name">new_limit</span>;
      GetRange(expanded0, &amp;new_start, &amp;new_limit);
      <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">expanded1</span>;
      current_-&gt;GetOverlappingInputs(level+1, &amp;new_start, &amp;new_limit,
                                     &amp;expanded1);
      <span class="org-keyword">if</span> (expanded1.size() == c-&gt;inputs_[1].size()) {
        Log(options_-&gt;info_log,
            <span class="org-string">"Expanding@%d %d+%d to %d+%d\n"</span>,
            level,
            <span class="org-type">int</span>(c-&gt;inputs_[0].size()),
            <span class="org-type">int</span>(c-&gt;inputs_[1].size()),
            <span class="org-type">int</span>(expanded0.size()),
            <span class="org-type">int</span>(expanded1.size()));
        smallest = new_start;
        largest = new_limit;
        c-&gt;inputs_[0] = expanded0;
        c-&gt;inputs_[1] = expanded1;
        GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);
      }
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Compute the set of grandparent files that overlap this compaction</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">(parent == level+1; grandparent == level+2)</span>
  <span class="org-keyword">if</span> (level + 2 &lt; <span class="org-constant">config</span>::kNumLevels) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20551;&#35774;&#36825;&#20004;&#20010;&#21512;&#24182;&#20043;&#21518;,&#21644;level+2&#20250;&#26377;&#21738;&#20123;&#25991;&#20214;&#20986;&#29616;&#37325;&#21472;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20445;&#23384;&#22312;grandparents&#37324;&#38754;.</span>
    current_-&gt;GetOverlappingInputs(level + 2, &amp;all_start, &amp;all_limit,
                                   &amp;c-&gt;grandparents_);
  }

  <span class="org-keyword">if</span> (<span class="org-constant">false</span>) {
    Log(options_-&gt;info_log, <span class="org-string">"Compacting %d '%s' .. '%s'"</span>,
        level,
        smallest.DebugString().c_str(),
        largest.DebugString().c_str());
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Update the place where we will do the next compaction for this level.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">We update this immediately instead of waiting for the VersionEdit</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">to be applied so that if the compaction fails, we will try a different</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">key range next time.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20445;&#23384;&#21040;&#26412;&#23618;&#26368;&#22823;key.</span>
  compact_pointer_[level] = largest.Encode().ToString();
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;level&#30340;largest&#20445;&#23384;&#21040;edit&#37324;&#38754;.&#36825;&#20010;&#21487;&#33021;&#23545;&#20110;&#24674;&#22797;&#36215;&#26469;&#20043;&#21518;&#21487;&#33021;&#26377;&#29992;.</span>
  c-&gt;edit_.SetCompactPointer(level, largest);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline141"></a>MakeInputIterator<br  /><div class="outline-text-5" id="text-10-3-12-20">
<p>
针对Compaction而言我们可能需要读取多个文件设计的遍历器.底层应该是MergeIterator实现.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Iterator</span>* <span class="org-constant">VersionSet</span>::<span class="org-function-name">MakeInputIterator</span>(<span class="org-type">Compaction</span>* <span class="org-variable-name">c</span>) {
  <span class="org-type">ReadOptions</span> <span class="org-variable-name">options</span>;
  options.verify_checksums = options_-&gt;paranoid_checks;
  options.fill_cache = <span class="org-constant">false</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Level-0 files have to be merged together.  For other levels,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we will make a concatenating iterator per level.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">TODO(opt): use concatenating iterator for level-0 if there is no overlap</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&gt;0&#30340;level&#26469;&#35828;&#30340;&#35805;&#21487;&#20197;&#20351;&#29992;LevelFileNumIterator&#26469;&#24403;&#20570;&#36825;&#19968;&#23618;&#30340;iterator.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#32780;&#23545;==0&#30340;level&#26469;&#35828;&#30340;&#35805;&#27599;&#19968;&#20010;&#25991;&#20214;&#20316;&#20026;&#19968;&#20010;iterator&#23384;&#22312;.</span>
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">space</span> = (c-&gt;level() == 0 ? c-&gt;inputs_[0].size() + 1 : 2);
  <span class="org-type">Iterator</span>** <span class="org-variable-name">list</span> = <span class="org-keyword">new</span> <span class="org-type">Iterator</span>*[space];
  <span class="org-type">int</span> <span class="org-variable-name">num</span> = 0;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">which</span> = 0; which &lt; 2; which++) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>c-&gt;inputs_[which].empty()) {
      <span class="org-keyword">if</span> (c-&gt;level() + which == 0) {
        <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span> = c-&gt;inputs_[which];
        <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; files.size(); i++) {
          <span class="org-type">list</span>[num++] = table_cache_-&gt;NewIterator(
              options, files[i]-&gt;number, files[i]-&gt;file_size);
        }
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Create concatenating iterator for the files from this level</span>
        <span class="org-type">list</span>[num++] = NewTwoLevelIterator(
            <span class="org-keyword">new</span> <span class="org-constant">Version</span>::<span class="org-type">LevelFileNumIterator</span>(icmp_, &amp;c-&gt;inputs_[which]),
            &amp;GetFileIterator, table_cache_, options);
      }
    }
  }
  assert(num &lt;= space);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#20316;&#20026;&#19968;&#20010;merge iterator&#23384;&#22312;.</span>
  <span class="org-type">Iterator</span>* <span class="org-variable-name">result</span> = NewMergingIterator(&amp;icmp_, list, num);
  <span class="org-keyword">delete</span>[] list;
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline147" class="outline-4">
<h4 id="orgheadline147"><span class="section-number-4">10.3.13</span> VersionSetBuilder</h4>
<div class="outline-text-4" id="text-10-3-13">
<p>
db/version_set.cc VersoionSetBuilder存在作用就是为了能够高效地做version edit对象的回放.
沃恩首先看看里面可能涉及到的结构.注意这里面我们没有修改base对应的version对象,只是在SaveTo
的时候可以将这些log全部作用到base这个对象,写到新的对象上面.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A helper class so we can efficiently apply a whole sequence</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">of edits to a particular state without creating intermediate</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Versions that contain full copies of the intermediate state.</span>
<span class="org-keyword">class</span> <span class="org-constant">VersionSet</span>::<span class="org-type">Builder</span> {
 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Helper to sort by v-&gt;files_[file_number].smallest</span>
  <span class="org-keyword">struct</span> <span class="org-type">BySmallestKey</span> {
    <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>* <span class="org-variable-name">internal_comparator</span>;

    <span class="org-type">bool</span> <span class="org-keyword">operator</span><span class="org-function-name">()</span>(<span class="org-type">FileMetaData</span>* <span class="org-variable-name">f1</span>, <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f2</span>) <span class="org-keyword">const</span> {
      <span class="org-type">int</span> <span class="org-variable-name">r</span> = internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);
      <span class="org-keyword">if</span> (r != 0) {
        <span class="org-keyword">return</span> (r &lt; 0);
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Break ties by file number</span>
        <span class="org-keyword">return</span> (f1-&gt;number &lt; f2-&gt;number);
      }
    }
  };

  <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">set</span>&lt;<span class="org-type">FileMetaData</span>*, <span class="org-type">BySmallestKey</span>&gt; <span class="org-type">FileSet</span>;
  <span class="org-keyword">struct</span> <span class="org-type">LevelState</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;level&#38656;&#35201;&#22686;&#21152;&#21644;&#21024;&#38500;&#30340;&#25991;&#20214;.</span>
    <span class="org-constant">std</span>::<span class="org-type">set</span>&lt;<span class="org-type">uint64_t</span>&gt; <span class="org-variable-name">deleted_files</span>;
    <span class="org-type">FileSet</span>* <span class="org-variable-name">added_files</span>;
  };

  <span class="org-type">VersionSet</span>* <span class="org-variable-name">vset_</span>;
  <span class="org-type">Version</span>* <span class="org-variable-name">base_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;&#26576;&#19968;&#20010;version&#36827;&#34892;&#30340;edit&#25805;&#20316;.</span>
  <span class="org-type">LevelState</span> <span class="org-variable-name">levels_</span>[<span class="org-constant">config</span>::kNumLevels];
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline143"></a>VersionSetBuilder<br  /><div class="outline-text-5" id="text-10-3-13-1">
<p>
首先看看构造和析构函数.不是非常麻烦.对于析构函数的话将所有的add files refs&#x2013;.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Initialize a builder with the files from *base and other info from *vset</span>
<span class="org-function-name">Builder</span>(<span class="org-type">VersionSet</span>* <span class="org-variable-name">vset</span>, <span class="org-type">Version</span>* <span class="org-variable-name">base</span>)
    : vset_(vset),
      base_(base) {
  base_-&gt;Ref();
  <span class="org-type">BySmallestKey</span> <span class="org-variable-name">cmp</span>;
  cmp.internal_comparator = &amp;vset_-&gt;icmp_;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    levels_[level].added_files = <span class="org-keyword">new</span> <span class="org-type">FileSet</span>(cmp);
  }
}

~<span class="org-function-name">Builder</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#25152;&#26377;&#30340;add files&#20840;&#37096;refs--.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#22312;SaveTo&#30340;&#26102;&#20505;&#20250;&#23558;FileMetaData&#36825;&#37096;&#20998;&#30340;ref&#36716;&#20041;&#21040;SaveTo&#30340;Version&#19978;&#38754;.</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-keyword">const</span> <span class="org-type">FileSet</span>* <span class="org-variable-name">added</span> = levels_[level].added_files;
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">to_unref</span>;
    to_unref.reserve(added-&gt;size());
    <span class="org-keyword">for</span> (<span class="org-constant">FileSet</span>::<span class="org-type">const_iterator</span> <span class="org-variable-name">it</span> = added-&gt;begin();
        it != added-&gt;end(); ++it) {
      to_unref.push_back(*it);
    }
    <span class="org-keyword">delete</span> added;
    <span class="org-keyword">for</span> (<span class="org-type">uint32_t</span> <span class="org-variable-name">i</span> = 0; i &lt; to_unref.size(); i++) {
      <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = to_unref[i];
      f-&gt;refs--;
      <span class="org-keyword">if</span> (f-&gt;refs &lt;= 0) {
        <span class="org-keyword">delete</span> f;
      }
    }
  }
  base_-&gt;Unref();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline144"></a>Apply<br  /><div class="outline-text-5" id="text-10-3-13-2">
<p>
将edit这个log记录起来.可能会被调用多次.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Apply all of the edits in *edit to the current state.</span>
<span class="org-type">void</span> <span class="org-function-name">Apply</span>(<span class="org-type">VersionEdit</span>* <span class="org-variable-name">edit</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Update compaction pointers</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; edit-&gt;compact_pointers_.size(); i++) {
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">level</span> = edit-&gt;compact_pointers_[i].first;
    vset_-&gt;compact_pointer_[level] =
        edit-&gt;compact_pointers_[i].second.Encode().ToString();
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Delete files</span>
  <span class="org-keyword">const</span> <span class="org-constant">VersionEdit</span>::<span class="org-type">DeletedFileSet</span>&amp; <span class="org-variable-name">del</span> = edit-&gt;deleted_files_;
  <span class="org-keyword">for</span> (<span class="org-constant">VersionEdit</span>::<span class="org-constant">DeletedFileSet</span>::<span class="org-type">const_iterator</span> <span class="org-variable-name">iter</span> = del.begin();
       iter != del.end();
       ++iter) {
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">level</span> = iter-&gt;first;
    <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">number</span> = iter-&gt;second;
    levels_[level].deleted_files.insert(number);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add new files</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; edit-&gt;new_files_.size(); i++) {
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">level</span> = edit-&gt;new_files_[i].first;
    <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = <span class="org-keyword">new</span> <span class="org-type">FileMetaData</span>(edit-&gt;new_files_[i].second);
    f-&gt;refs = 1;

    <span class="org-comment-delimiter">// </span><span class="org-comment">We arrange to automatically compact this file after</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">a certain number of seeks.  Let's assume:</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(1) One seek costs 10ms</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(2) Writing or reading 1MB costs 10ms (100MB/s)</span>
    <span class="org-comment-delimiter">//   </span><span class="org-comment">(3) A compaction of 1MB does 25MB of IO:</span>
    <span class="org-comment-delimiter">//         </span><span class="org-comment">1MB read from this level</span>
    <span class="org-comment-delimiter">//         </span><span class="org-comment">10-12MB read from next level (boundaries may be misaligned)</span>
    <span class="org-comment-delimiter">//         </span><span class="org-comment">10-12MB written to next level</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">This implies that 25 seeks cost the same as the compaction</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">of 1MB of data.  I.e., one seek costs approximately the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">same as the compaction of 40KB of data.  We are a little</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">conservative and allow approximately one seek for every 16KB</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">of data before triggering a compaction.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;allow seek&#30340;&#38480;&#21046;,&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#38480;&#21046;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#20316;&#20026;&#28508;&#22312;&#30340;compaction&#25991;&#20214;.</span>
    f-&gt;allowed_seeks = (f-&gt;file_size / 16384);
    <span class="org-keyword">if</span> (f-&gt;allowed_seeks &lt; 100) f-&gt;allowed_seeks = 100;

    levels_[level].deleted_files.erase(f-&gt;number);
    levels_[level].added_files-&gt;insert(f);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline145"></a>MaybeAddFile<br  /><div class="outline-text-5" id="text-10-3-13-3">
<p>
将f添加到新增加到对应level的文件列表尾部.需要确保没有overlap并且没有存在于标记删除文件集合中.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">MaybeAddFile</span>(<span class="org-type">Version</span>* <span class="org-variable-name">v</span>, <span class="org-type">int</span> <span class="org-variable-name">level</span>, <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span>) {
  <span class="org-keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">File is deleted: do nothing</span>
  } <span class="org-keyword">else</span> {
    <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;* <span class="org-variable-name">files</span> = &amp;v-&gt;files_[level];
    <span class="org-keyword">if</span> (level &gt; 0 &amp;&amp; <span class="org-negation-char">!</span>files-&gt;empty()) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Must not overlap</span>
      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size()-1]-&gt;largest,
                                  f-&gt;smallest) &lt; 0);
    }
    f-&gt;refs++;
    files-&gt;push_back(f);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline146"></a>SaveTo<br  /><div class="outline-text-5" id="text-10-3-13-4">
<p>
当前通过edit修改后的状态保存到新的version里面.我们来仔细看看这个过程.将之前edit回放的内容
保存在v这个version里面来.典型使用方法非常简单.
</p>
<ul class="org-ul">
<li>首先构造builder对象</li>
<li>Apply使用某个edit.</li>
<li>SaveTo生成某个version.</li>
</ul>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Save the current state in *v.</span>
<span class="org-type">void</span> <span class="org-function-name">SaveTo</span>(<span class="org-type">Version</span>* <span class="org-variable-name">v</span>) {
  <span class="org-type">BySmallestKey</span> <span class="org-variable-name">cmp</span>;
  cmp.internal_comparator = &amp;vset_-&gt;icmp_;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">level</span> = 0; level &lt; <span class="org-constant">config</span>::kNumLevels; level++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Merge the set of added files with the set of pre-existing files.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Drop any deleted files.  Store the result in *v.</span>
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">base_files</span> = base_-&gt;files_[level];
    <span class="org-constant">std</span>::<span class="org-constant">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;::<span class="org-type">const_iterator</span> <span class="org-variable-name">base_iter</span> = base_files.begin();
    <span class="org-constant">std</span>::<span class="org-constant">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;::<span class="org-type">const_iterator</span> <span class="org-variable-name">base_end</span> = base_files.end();
    <span class="org-keyword">const</span> <span class="org-type">FileSet</span>* <span class="org-variable-name">added</span> = levels_[level].added_files;
    v-&gt;files_[level].reserve(base_files.size() + added-&gt;size());
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#24517;&#39035;&#25353;&#29031;&#26368;&#23567;&#30340;key&#26469;&#36827;&#34892;&#25490;&#24207;.&#36825;&#37324;&#26159;&#23384;&#22312;&#39034;&#24207;&#38382;&#39064;&#30340;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;&#23545;&#20110;level&gt;0&#30340;&#23618;&#26469;&#35828;&#37324;&#38754;&#30340;&#25991;&#20214;&#37117;&#26159;&#19981;&#37325;&#22797;&#30340;.</span>
    <span class="org-keyword">for</span> (<span class="org-constant">FileSet</span>::<span class="org-type">const_iterator</span> <span class="org-variable-name">added_iter</span> = added-&gt;begin();
         added_iter != added-&gt;end();
         ++added_iter) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Add all smaller files listed in base_</span>
      <span class="org-keyword">for</span> (<span class="org-constant">std</span>::<span class="org-constant">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;::<span class="org-type">const_iterator</span> <span class="org-variable-name">bpos</span>
               = <span class="org-constant">std</span>::upper_bound(base_iter, base_end, *added_iter, cmp);
           base_iter != bpos;
           ++base_iter) {
        MaybeAddFile(v, level, *base_iter);
      }

      MaybeAddFile(v, level, *added_iter);
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Add remaining base files</span>
    <span class="org-keyword">for</span> (; base_iter != base_end; ++base_iter) {
      MaybeAddFile(v, level, *base_iter);
    }
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline156" class="outline-4">
<h4 id="orgheadline156"><span class="section-number-4">10.3.14</span> Compaction</h4>
<div class="outline-text-4" id="text-10-3-14">
<p>
db/version_set.h Compaction包含的是进行compaction操作的信息.针对compaction对象通常是current version
所对应的文件。我们首先来看看Compaction结构.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A Compaction encapsulates information about a compaction.</span>
<span class="org-keyword">class</span> <span class="org-type">Compaction</span> {
 <span class="org-keyword">public</span>:

  <span class="org-type">int</span> <span class="org-variable-name">level_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;&#21738;&#20010;level&#36827;&#34892;</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">max_output_file_size_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">compaction&#20043;&#21518;&#21333;&#20010;&#25991;&#20214;&#30340;&#26368;&#22823;&#22823;&#23567;.</span>
  <span class="org-type">Version</span>* <span class="org-variable-name">input_version_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;&#21738;&#20010;version&#36827;&#34892;&#25805;&#20316;.</span>
  <span class="org-type">VersionEdit</span> <span class="org-variable-name">edit_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24212;&#35813;&#26159;&#38024;&#23545;version&#25805;&#20316;&#20043;&#21518;&#30340;log&#20449;&#24687;.&#27604;&#22914;&#21024;&#38500;&#21738;&#20123;&#25991;&#20214;&#28155;&#21152;&#20102;&#21738;&#20123;&#25991;&#20214;&#31561;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Each compaction reads inputs from "level_" and "level_+1"</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">inputs_</span>[2];      <span class="org-comment-delimiter">// </span><span class="org-comment">The two sets of inputs. &#35201;&#36827;&#34892;compaction&#30340;&#25991;&#20214;&#26377;&#21738;&#20123;.</span>
  <span class="org-comment-delimiter">//</span><span class="org-comment">1 &#24212;&#35813;&#23601;&#26159;parent level.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">State used to check for number of of overlapping grandparent files</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">(parent == level_ + 1, grandparent == level_ + 2)</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt; <span class="org-variable-name">grandparents_</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">grandparent_index_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Index in grandparent_starts_</span>
  <span class="org-type">bool</span> <span class="org-variable-name">seen_key_</span>;             <span class="org-comment-delimiter">// </span><span class="org-comment">Some output key has been seen</span>
  <span class="org-type">int64_t</span> <span class="org-variable-name">overlapped_bytes_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Bytes of overlap between current output</span>
                              <span class="org-comment-delimiter">// </span><span class="org-comment">and grandparent files</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">State for implementing IsBaseLevelForKey</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">level_ptrs_ holds indices into input_version_-&gt;levels_: our state</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">is that we are positioned at one of the file ranges for each</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">higher level than the ones involved in this compaction (i.e. for</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">all L &gt;= level_ + 2).</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">level_ptrs_</span>[<span class="org-constant">config</span>::kNumLevels];
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline148"></a>Compaction<br  /><div class="outline-text-5" id="text-10-3-14-1">
<p>
构造函数过程非常简单.析构函数的话也只是将input_version_修改引用计数。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">Compaction</span>::<span class="org-function-name">Compaction</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>)
    : level_(level),
      max_output_file_size_(MaxFileSizeForLevel(level)), <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#20989;&#25968;&#21518;&#38754;&#20998;&#26512;.</span>
      input_version_(<span class="org-constant">NULL</span>),
      grandparent_index_(0),
      seen_key_(<span class="org-constant">false</span>),
      overlapped_bytes_(0) {
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; <span class="org-constant">config</span>::kNumLevels; i++) {
    level_ptrs_[i] = 0;
  }
}
<span class="org-constant">Compaction</span>::~<span class="org-function-name">Compaction</span>() {
  <span class="org-keyword">if</span> (input_version_ != <span class="org-constant">NULL</span>) {
    input_version_-&gt;Unref(); <span class="org-comment-delimiter">// </span><span class="org-comment">NOTICE:&#36825;&#20010;&#38750;&#24120;&#37325;&#35201;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36825;&#20010;compaction&#23436;&#25104;&#30340;&#35805;,&#37027;&#20040;version&#23601;&#20250;&#38144;&#27585;.</span>
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline149"></a>MaxFileSizeForLevel<br  /><div class="outline-text-5" id="text-10-3-14-2">
<p>
每一层单个文件大小最大是多少.现在实现非常简单是一个固定值.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kTargetFileSize</span> = 2 * 1048576; <span class="org-comment-delimiter">// </span><span class="org-comment">2MB.</span>
<span class="org-keyword">static</span> <span class="org-type">uint64_t</span> <span class="org-function-name">MaxFileSizeForLevel</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>) {
  <span class="org-keyword">return</span> kTargetFileSize;  <span class="org-comment-delimiter">// </span><span class="org-comment">We could vary per level to reduce number of files?</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline150"></a>MaxBytesForLevel<br  /><div class="outline-text-5" id="text-10-3-14-3">
<p>
每一层文件所占用的字节数上限是多少.level0,1是10MB.以后每上一层*10.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">double</span> <span class="org-function-name">MaxBytesForLevel</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: the result for level zero is not really used since we set</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the level-0 compaction threshold based on number of files.</span>
  <span class="org-type">double</span> <span class="org-variable-name">result</span> = 10 * 1048576.0;  <span class="org-comment-delimiter">// </span><span class="org-comment">Result for both level-0 and level-1</span>
  <span class="org-keyword">while</span> (level &gt; 1) {
    result *= 10;
    level--;
  }
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline151"></a>IsTrivialMove<br  /><div class="outline-text-5" id="text-10-3-14-4">
<p>
这个compaction是否为简单的移动.需要满足3个条件
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">Compaction</span>::<span class="org-function-name">IsTrivialMove</span>() <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Avoid a move if there is lots of overlapping grandparent data.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Otherwise, the move could create a parent file that will require</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">a very expensive merge later on.</span>
  <span class="org-keyword">return</span> (num_input_files(0) == 1 &amp;&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">level 1&#20010;&#25991;&#20214;</span>
          num_input_files(1) == 0 &amp;&amp; <span class="org-comment-delimiter">// </span><span class="org-comment">level+1 &#27809;&#26377;&#25991;&#20214;</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">grandparent level&#23384;&#22312;overlap&#30340;&#25991;&#20214;&#22823;&#23567;&#27809;&#26377;&#36807;&#22823;.</span>
          TotalFileSize(grandparents_) &lt;= kMaxGrandParentOverlapBytes);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline152"></a>AddInputDeletions<br  /><div class="outline-text-5" id="text-10-3-14-5">
<p>
通知这次操作做了文件的删除.将这些可以删除的文件填写到edit里面.做好compaction之后的话，
那么inputs_里面的文件基本上就没有用途就可以被删除了。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Compaction</span>::<span class="org-function-name">AddInputDeletions</span>(<span class="org-type">VersionEdit</span>* <span class="org-variable-name">edit</span>) {
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">which</span> = 0; which &lt; 2; which++) {
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; inputs_[which].size(); i++) {
      edit-&gt;DeleteFile(level_ + which, inputs_[which][i]-&gt;number);
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline153"></a>IsBaseLevelForKey<br  /><div class="outline-text-5" id="text-10-3-14-6">
<p>
在db_impl.cc里面的DoCompactionWork里面调用了.具体策略实现没有太仔细分析.判断某个key在高层是否还存在.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">Compaction</span>::<span class="org-function-name">IsBaseLevelForKey</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">user_key</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Maybe use binary search to find right entry instead of linear search?</span>
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">user_cmp</span> = input_version_-&gt;vset_-&gt;icmp_.user_comparator();
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">lvl</span> = level_ + 2; lvl &lt; <span class="org-constant">config</span>::kNumLevels; lvl++) {
    <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">FileMetaData</span>*&gt;&amp; <span class="org-variable-name">files</span> = input_version_-&gt;files_[lvl];
    <span class="org-keyword">for</span> (; level_ptrs_[lvl] &lt; files.size(); ) {
      <span class="org-type">FileMetaData</span>* <span class="org-variable-name">f</span> = files[level_ptrs_[lvl]];
      <span class="org-keyword">if</span> (user_cmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= 0) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">We've advanced far enough</span>
        <span class="org-keyword">if</span> (user_cmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= 0) {
          <span class="org-comment-delimiter">// </span><span class="org-comment">Key falls in this file's range, so definitely not base level</span>
          <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
        <span class="org-keyword">break</span>;
      }
      level_ptrs_[lvl]++;
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline154"></a>ShouldStopBefore<br  /><div class="outline-text-5" id="text-10-3-14-7">
<p>
在db_impl.cc里面的DoCompactionWork里面调用了.作用是判断这个key的话是否应该停止然后
重新开辟一个新的文件用于compaction的输出.这是一个策略,大致应该是希望这个key如果
和grandparent level重合不要过多.更具体的策略方面不太清楚.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">Compaction</span>::<span class="org-function-name">ShouldStopBefore</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">internal_key</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Scan to find earliest grandparent file that contains key.</span>
  <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>* <span class="org-variable-name">icmp</span> = &amp;input_version_-&gt;vset_-&gt;icmp_;
  <span class="org-keyword">while</span> (grandparent_index_ &lt; grandparents_.size() &amp;&amp;
      icmp-&gt;Compare(internal_key,
                    grandparents_[grandparent_index_]-&gt;largest.Encode()) &gt; 0) {
    <span class="org-keyword">if</span> (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]-&gt;file_size;
    }
    grandparent_index_++;
  }
  seen_key_ = <span class="org-constant">true</span>;

  <span class="org-keyword">if</span> (overlapped_bytes_ &gt; kMaxGrandParentOverlapBytes) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Too much overlap for current output; start new output</span>
    overlapped_bytes_ = 0;
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline155"></a>ReleaseInputs<br  /><div class="outline-text-5" id="text-10-3-14-8">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Compaction</span>::<span class="org-function-name">ReleaseInputs</span>() {
  <span class="org-keyword">if</span> (input_version_ != <span class="org-constant">NULL</span>) {
    input_version_-&gt;Unref();
    input_version_ = <span class="org-constant">NULL</span>;
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline157" class="outline-4">
<h4 id="orgheadline157"><span class="section-number-4">10.3.15</span> CompactionState</h4>
<div class="outline-text-4" id="text-10-3-15">
<p>
db/db_impl.cc CompactionState里面记录的是在这次Compaction时候保存的状态.Compaction只是
保存了本次compaction操作所需要的信息，但是没有保存过程状态.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-constant">DBImpl</span>::<span class="org-type">CompactionState</span> {
  <span class="org-type">Compaction</span>* <span class="org-keyword">const</span> <span class="org-variable-name">compaction</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26412;&#27425;compaction&#25152;&#38656;&#35201;&#36827;&#34892;&#30340;&#25805;&#20316;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Sequence numbers &lt; smallest_snapshot are not significant since we</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">will never have to service a snapshot below smallest_snapshot.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Therefore if we have seen a sequence number S &lt;= smallest_snapshot,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we can drop all entries for the same key with sequence numbers &lt; S.</span>
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">smallest_snapshot</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#26377;&#25928;&#30340;sequence number&#26159;&#22810;&#23569;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Files produced by compaction</span>
  <span class="org-keyword">struct</span> <span class="org-type">Output</span> {
    <span class="org-type">uint64_t</span> <span class="org-variable-name">number</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36755;&#20986;&#25991;&#20214;number.</span>
    <span class="org-type">uint64_t</span> <span class="org-variable-name">file_size</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36755;&#20986;&#25991;&#20214;&#22823;&#23567;</span>
    <span class="org-type">InternalKey</span> <span class="org-variable-name">smallest</span>, <span class="org-variable-name">largest</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36755;&#20986;&#25991;&#20214;size.</span>
  };
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">Output</span>&gt; <span class="org-variable-name">outputs</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">State kept for output being generated</span>
  <span class="org-type">WritableFile</span>* <span class="org-variable-name">outfile</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#36755;&#20986;&#25991;&#20214;&#20197;&#21450;table_builder.</span>
  <span class="org-type">TableBuilder</span>* <span class="org-variable-name">builder</span>;

  <span class="org-type">uint64_t</span> <span class="org-variable-name">total_bytes</span>;

  <span class="org-type">Output</span>* <span class="org-function-name">current_output</span>() { <span class="org-keyword">return</span> &amp;outputs[outputs.size()-1]; }

  <span class="org-keyword">explicit</span> <span class="org-function-name">CompactionState</span>(<span class="org-type">Compaction</span>* <span class="org-variable-name">c</span>)
      : compaction(c),
        outfile(<span class="org-constant">NULL</span>),
        builder(<span class="org-constant">NULL</span>),
        total_bytes(0) {
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline161" class="outline-4">
<h4 id="orgheadline161"><span class="section-number-4">10.3.16</span> VersionEdit</h4>
<div class="outline-text-4" id="text-10-3-16">
<p>
db/version_edit.h 阅读完DBImpl::NewDB的话就会发现VersionEdit里面存储的是整个数据库的元信息.
元信息序列化之后作为log写入到Manifest文件里面去。CURRENT文件里面存放的就是当前Manifest文件.
我们首先看看VersionEdit的结构以及里面的字段。个人觉得VersionEdit本身是非常简单的，但是需要了解各个字段含义。
</p>

<p>
:阅读完Compaction之后，觉得这个结构更多的含义应该是针对Version进行Compaction这个过程，对于
Version造成了哪些变动，比如增加或者是删除啦哪些文件，下一个file number以及sequence是什么。将这些
内容记录到log(manifest)里面这样启动的时候就可以进行恢复。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">VersionEdit</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">private:</span>
 <span class="org-keyword">public</span>:
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">VersionSet</span>;

  <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">set</span>&lt; <span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, <span class="org-type">uint64_t</span>&gt; &gt; <span class="org-type">DeletedFileSet</span>;

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">comparator_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27604;&#36739;&#22120;&#30340;&#21517;&#23383;.&#36825;&#26679;&#21487;&#20197;&#38450;&#27490;&#25105;comparator&#30340;&#21464;&#21160;&#36896;&#25104;db&#30340;&#36923;&#36753;&#25439;&#22351;.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">log_number_</span>; <span class="org-comment-delimiter">//</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">prev_log_number_</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">next_file_number_</span>;
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">last_sequence_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19978;&#27425;&#25805;&#20316;&#23436;&#25104;&#20043;&#21518;&#30340;&#24207;&#21015;&#21495;.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">has_comparator_</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">has_log_number_</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">has_prev_log_number_</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">has_next_file_number_</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">has_last_sequence_</span>;

  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt; <span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, InternalKey&gt; &gt; <span class="org-variable-name">compact_pointers_</span>;
  <span class="org-type">DeletedFileSet</span> <span class="org-variable-name">deleted_files_</span>;
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt; <span class="org-constant">std</span>::<span class="org-type">pair</span>&lt;<span class="org-type">int</span>, FileMetaData&gt; &gt; <span class="org-variable-name">new_files_</span>;
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline158"></a>SetCompactPoint<br  /><div class="outline-text-5" id="text-10-3-16-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">SetCompactPointer</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>, <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>&amp; <span class="org-variable-name">key</span>) {
  compact_pointers_.push_back(<span class="org-constant">std</span>::make_pair(level, key));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline159"></a>AddFile<br  /><div class="outline-text-5" id="text-10-3-16-2">
<p>
相当于告诉db系统新增加了这么一个文件以及这个文件里面的信息是什么.这样可以方便db操作.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">AddFile</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">file</span>,
             <span class="org-type">uint64_t</span> <span class="org-variable-name">file_size</span>,
             <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>&amp; <span class="org-variable-name">smallest</span>,
             <span class="org-keyword">const</span> <span class="org-type">InternalKey</span>&amp; <span class="org-variable-name">largest</span>) {
  <span class="org-type">FileMetaData</span> <span class="org-variable-name">f</span>;
  f.number = file;
  f.file_size = file_size;
  f.smallest = smallest;
  f.largest = largest;
  new_files_.push_back(<span class="org-constant">std</span>::make_pair(level, f));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline160"></a>DeleteFile<br  /><div class="outline-text-5" id="text-10-3-16-3">
<p>
告诉db系统删除了这个文件.删除并没有操作new_files数组.而是放进了一个set.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Delete the specified "file" from the specified "level".</span>
<span class="org-type">void</span> <span class="org-function-name">DeleteFile</span>(<span class="org-type">int</span> <span class="org-variable-name">level</span>, <span class="org-type">uint64_t</span> <span class="org-variable-name">file</span>) {
  deleted_files_.insert(<span class="org-constant">std</span>::make_pair(level, file));
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline162" class="outline-4">
<h4 id="orgheadline162"><span class="section-number-4">10.3.17</span> ByteWiseComparatorImpl</h4>
<div class="outline-text-4" id="text-10-3-17">
<p>
util/comparator.cc 对于Compare实现使用slice对象的compare实现。我们着重看看上面两个接口实现
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">FindShortestSeparator</span>(
    <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">start</span>,
    <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">limit</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Find length of common prefix</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">min_length</span> = <span class="org-constant">std</span>::min(start-&gt;size(), limit.size());
  <span class="org-type">size_t</span> <span class="org-variable-name">diff_index</span> = 0;
  <span class="org-keyword">while</span> ((diff_index &lt; min_length) &amp;&amp;
         ((*start)[diff_index] == limit[diff_index])) {
    diff_index++;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#29616;&#19978;&#20165;&#20165;&#26159;&#23545;&#20110;&#31532;&#19968;&#20010;&#19981;&#21516;&#30340;&#23383;&#31526;&#23581;&#35797;+1</span>
  <span class="org-keyword">if</span> (diff_index &gt;= min_length) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Do not shorten if one string is a prefix of the other</span>
  } <span class="org-keyword">else</span> {
    <span class="org-type">uint8_t</span> <span class="org-variable-name">diff_byte</span> = <span class="org-keyword">static_cast</span>&lt;uint8_t&gt;((*start)[diff_index]);
    <span class="org-keyword">if</span> (<span class="org-type">diff_byte</span> &lt; <span class="org-keyword">static_cast</span>&lt;uint8_t&gt;(0xff) &amp;&amp;
        diff_byte + 1 &lt; <span class="org-keyword">static_cast</span>&lt;uint8_t&gt;(limit[diff_index])) {
      (*start)[diff_index]++;  <span class="org-comment-delimiter">// </span><span class="org-comment">+1</span>
      start-&gt;resize(diff_index + 1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#24182;&#19988;&#20462;&#25913;&#38271;&#24230;</span>
      assert(Compare(*start, limit) &lt; 0);
    }
  }
}

<span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">FindShortSuccessor</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Find first character that can be incremented</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = key-&gt;size();
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++) {
    <span class="org-keyword">const</span> <span class="org-type">uint8_t</span> <span class="org-variable-name">byte</span> = (*key)[i];
    <span class="org-keyword">if</span> (byte != <span class="org-keyword">static_cast</span>&lt;uint8_t&gt;(0xff)) {
      (*key)[i] = byte + 1; <span class="org-comment-delimiter">// </span><span class="org-comment">+1</span>
      key-&gt;resize(i+1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20462;&#25913;&#38271;&#24230;</span>
      <span class="org-keyword">return</span>;
    }
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">*key is a run of 0xffs.  Leave it alone.</span>
}
</pre>
</div>
<p>
还算是比较直白吧.
</p>
</div>
</div>

<div id="outline-container-orgheadline163" class="outline-4">
<h4 id="orgheadline163"><span class="section-number-4">10.3.18</span> SnapshotImpl</h4>
<div class="outline-text-4" id="text-10-3-18">
<p>
db/snapshot.h Snapshot实现非常简单，就是一个双向链表的节点，然后挂在一个双向链表上面。
每一个Snapshot实现都附带一个seq number.对于Snapshot最重要的应该是在上面的操作吧.
我们可以猜想对于每次插入的key都会带上一个seq number.这样如果对snapshot操作的话读取的话，
那么只需要读取seq number以下的内容即可了。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Snapshots are kept in a doubly-linked list in the DB.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Each SnapshotImpl corresponds to a particular sequence number.</span>
<span class="org-keyword">class</span> <span class="org-type">SnapshotImpl</span> : <span class="org-keyword">public</span> <span class="org-type">Snapshot</span> {
 <span class="org-keyword">public</span>:
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">number_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">const after creation</span>

 <span class="org-keyword">private</span>:
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">SnapshotList</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">SnapshotImpl is kept in a doubly-linked circular list</span>
  <span class="org-type">SnapshotImpl</span>* <span class="org-variable-name">prev_</span>;
  <span class="org-type">SnapshotImpl</span>* <span class="org-variable-name">next_</span>;

  <span class="org-type">SnapshotList</span>* <span class="org-variable-name">list_</span>;                 <span class="org-comment-delimiter">// </span><span class="org-comment">just for sanity checks</span>
};

<span class="org-keyword">class</span> <span class="org-type">SnapshotList</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">SnapshotList</span>() {
    list_.prev_ = &amp;list_;
    list_.next_ = &amp;list_;
  }

  <span class="org-type">bool</span> <span class="org-function-name">empty</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> list_.next_ == &amp;list_; }
  <span class="org-type">SnapshotImpl</span>* <span class="org-function-name">oldest</span>() <span class="org-keyword">const</span> { assert(<span class="org-negation-char">!</span>empty()); <span class="org-keyword">return</span> list_.next_; }
  <span class="org-type">SnapshotImpl</span>* <span class="org-function-name">newest</span>() <span class="org-keyword">const</span> { assert(<span class="org-negation-char">!</span>empty()); <span class="org-keyword">return</span> list_.prev_; }

  <span class="org-keyword">const</span> <span class="org-type">SnapshotImpl</span>* <span class="org-function-name">New</span>(<span class="org-type">SequenceNumber</span> <span class="org-variable-name">seq</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#37197;&#19968;&#20010;snapshot&#23454;&#20363;</span>
    <span class="org-type">SnapshotImpl</span>* <span class="org-variable-name">s</span> = <span class="org-keyword">new</span> <span class="org-type">SnapshotImpl</span>;
    s-&gt;number_ = seq;
    s-&gt;list_ = <span class="org-keyword">this</span>;
    s-&gt;next_ = &amp;list_;
    s-&gt;prev_ = list_.prev_;
    s-&gt;prev_-&gt;next_ = s;
    s-&gt;next_-&gt;prev_ = s;
    <span class="org-keyword">return</span> s;
  }

  <span class="org-type">void</span> <span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">SnapshotImpl</span>* <span class="org-variable-name">s</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20010;snapshot&#20174;&#38142;&#20013;&#21024;&#38500;</span>
    assert(s-&gt;list_ == <span class="org-keyword">this</span>);
    s-&gt;prev_-&gt;next_ = s-&gt;next_;
    s-&gt;next_-&gt;prev_ = s-&gt;prev_;
    <span class="org-keyword">delete</span> s;
  }

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Dummy head of doubly-linked list of snapshots</span>
  <span class="org-type">SnapshotImpl</span> <span class="org-variable-name">list_</span>;
};
</pre>
</div>

<p>
这里SequenceNumber的实现是一个在db/dbformat.h里面定义了
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-type">uint64_t</span> <span class="org-type">SequenceNumber</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline179" class="outline-3">
<h3 id="orgheadline179"><span class="section-number-3">10.4</span> Posix</h3>
<div class="outline-text-3" id="text-10-4">
</div><div id="outline-container-orgheadline169" class="outline-4">
<h4 id="orgheadline169"><span class="section-number-4">10.4.1</span> PosixEnv</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
util/env_posix.cc PosixEnv是Env接口的实现。PosixEnv的大部分实现都相当直接.不过这里还是把代码贴上了，主要是方便在一些细小的地方进行注记。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">PosixEnv</span> : <span class="org-keyword">public</span> <span class="org-type">Env</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">PosixEnv</span>();
  <span class="org-keyword">virtual</span> ~<span class="org-function-name">PosixEnv</span>() {
    fprintf(stderr, <span class="org-string">"Destroying Env::Default()\n"</span>);
    exit(1);
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewSequentialFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>,
                                   <span class="org-type">SequentialFile</span>** <span class="org-variable-name">result</span>) {
    <span class="org-type">FILE</span>* <span class="org-variable-name">f</span> = fopen(fname.c_str(), <span class="org-string">"r"</span>);
    <span class="org-keyword">if</span> (f == <span class="org-constant">NULL</span>) {
      *result = <span class="org-constant">NULL</span>;
      <span class="org-keyword">return</span> IOError(fname, errno);
    } <span class="org-keyword">else</span> {
      *result = <span class="org-keyword">new</span> <span class="org-type">PosixSequentialFile</span>(fname, f);
      <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
    }
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewRandomAccessFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>,
                                     <span class="org-type">RandomAccessFile</span>** <span class="org-variable-name">result</span>) {
    <span class="org-type">int</span> <span class="org-variable-name">fd</span> = open(fname.c_str(), O_RDONLY);
    <span class="org-keyword">if</span> (fd &lt; 0) {
      *result = <span class="org-constant">NULL</span>;
      <span class="org-keyword">return</span> IOError(fname, errno);
    }
    *result = <span class="org-keyword">new</span> <span class="org-type">PosixRandomAccessFile</span>(fname, fd);
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewWritableFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>,
                                 <span class="org-type">WritableFile</span>** <span class="org-variable-name">result</span>) {
    <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">fd</span> = open(fname.c_str(), O_CREAT | O_RDWR | O_TRUNC, 0644);
    <span class="org-keyword">if</span> (fd &lt; 0) {
      *result = <span class="org-constant">NULL</span>;
      s = IOError(fname, errno);
    } <span class="org-keyword">else</span> {
      *result = <span class="org-keyword">new</span> <span class="org-type">PosixMmapFile</span>(fname, fd, page_size_);
    }
    <span class="org-keyword">return</span> s;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">FileExists</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>) {
    <span class="org-keyword">return</span> access(fname.c_str(), F_OK) == 0;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">GetChildren</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dir</span>,
                             <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::<span class="org-type">string</span>&gt;* <span class="org-variable-name">result</span>) {
    result-&gt;clear();
    <span class="org-type">DIR</span>* <span class="org-variable-name">d</span> = opendir(dir.c_str());
    <span class="org-keyword">if</span> (d == <span class="org-constant">NULL</span>) {
      <span class="org-keyword">return</span> IOError(dir, errno);
    }
    <span class="org-keyword">struct</span> <span class="org-type">dirent</span>* <span class="org-variable-name">entry</span>;
    <span class="org-keyword">while</span> ((entry = readdir(d)) != <span class="org-constant">NULL</span>) {
      result-&gt;push_back(entry-&gt;d_name);
    }
    closedir(d);
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">DeleteFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>) {
    <span class="org-type">Status</span> <span class="org-variable-name">result</span>;
    <span class="org-keyword">if</span> (unlink(fname.c_str()) != 0) {
      result = IOError(fname, errno);
    }
    <span class="org-keyword">return</span> result;
  };

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">CreateDir</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>) {
    <span class="org-type">Status</span> <span class="org-variable-name">result</span>;
    <span class="org-keyword">if</span> (mkdir(name.c_str(), 0755) != 0) {
      result = IOError(name, errno);
    }
    <span class="org-keyword">return</span> result;
  };

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">DeleteDir</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">name</span>) {
    <span class="org-type">Status</span> <span class="org-variable-name">result</span>;
    <span class="org-keyword">if</span> (rmdir(name.c_str()) != 0) {
      result = IOError(name, errno);
    }
    <span class="org-keyword">return</span> result;
  };

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">GetFileSize</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>, <span class="org-type">uint64_t</span>* <span class="org-variable-name">size</span>) {
    <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
    <span class="org-keyword">struct</span> <span class="org-type">stat</span> <span class="org-variable-name">sbuf</span>;
    <span class="org-keyword">if</span> (stat(fname.c_str(), &amp;sbuf) != 0) {
      *size = 0;
      s = IOError(fname, errno);
    } <span class="org-keyword">else</span> {
      *size = sbuf.st_size;
    }
    <span class="org-keyword">return</span> s;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">RenameFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">src</span>, <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">target</span>) {
    <span class="org-type">Status</span> <span class="org-variable-name">result</span>;
    <span class="org-keyword">if</span> (rename(src.c_str(), target.c_str()) != 0) {
      result = IOError(src, errno);
    }
    <span class="org-keyword">return</span> result;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">LockFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>, <span class="org-type">FileLock</span>** <span class="org-variable-name">lock</span>) {
    *lock = <span class="org-constant">NULL</span>;
    <span class="org-type">Status</span> <span class="org-variable-name">result</span>;
    <span class="org-type">int</span> <span class="org-variable-name">fd</span> = open(fname.c_str(), O_RDWR | O_CREAT, 0644); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#19968;&#20010;&#25991;&#20214;&#34920;&#31034;&#38145;&#20303;.</span>
    <span class="org-keyword">if</span> (fd &lt; 0) {
      result = IOError(fname, errno);
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (LockOrUnlock(fd, <span class="org-constant">true</span>) == -1) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#20250;&#22312;&#21518;&#38754;&#20180;&#32454;&#30475;&#30475;.true&#34920;&#31034;lock.</span>
      result = IOError(<span class="org-string">"lock "</span> + fname, errno);
      close(fd);
    } <span class="org-keyword">else</span> {
      <span class="org-type">PosixFileLock</span>* <span class="org-variable-name">my_lock</span> = <span class="org-keyword">new</span> <span class="org-type">PosixFileLock</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#19968;&#20010;PosixFileLock&#23545;&#35937;</span>
      my_lock-&gt;fd_ = fd; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26631;&#35760;fd.</span>
      *lock = my_lock;
    }
    <span class="org-keyword">return</span> result;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">UnlockFile</span>(<span class="org-type">FileLock</span>* <span class="org-variable-name">lock</span>) {
    <span class="org-type">PosixFileLock</span>* <span class="org-variable-name">my_lock</span> = <span class="org-keyword">reinterpret_cast</span>&lt;PosixFileLock*&gt;(lock);
    <span class="org-type">Status</span> <span class="org-variable-name">result</span>;
    <span class="org-keyword">if</span> (LockOrUnlock(my_lock-&gt;fd_, <span class="org-constant">false</span>) == -1) { <span class="org-comment-delimiter">// </span><span class="org-comment">false&#34920;&#31034;unlock</span>
      result = IOError(<span class="org-string">"unlock"</span>, errno);
    }
    close(my_lock-&gt;fd_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20851;&#38381;&#23545;&#24212;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;.</span>
    <span class="org-keyword">delete</span> my_lock;
    <span class="org-keyword">return</span> result;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Schedule</span>(<span class="org-type">void</span> (*<span class="org-variable-name">function</span>)(<span class="org-type">void</span>*), <span class="org-type">void</span>* <span class="org-variable-name">arg</span>);

  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">StartThread</span>(<span class="org-type">void</span> (*<span class="org-variable-name">function</span>)(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>), <span class="org-type">void</span>* <span class="org-variable-name">arg</span>);

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">GetTestDirectory</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">result</span>) {
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">env</span> = getenv(<span class="org-string">"TEST_TMPDIR"</span>);
    <span class="org-keyword">if</span> (env &amp;&amp; env[0] != <span class="org-string">'\0'</span>) {
      *result = env;
    } <span class="org-keyword">else</span> {
      <span class="org-type">char</span> <span class="org-variable-name">buf</span>[100];
      snprintf(buf, <span class="org-keyword">sizeof</span>(buf), <span class="org-string">"/tmp/leveldbtest-%d"</span>, <span class="org-type">int</span>(<span class="org-variable-name">geteuid</span>()));
      *result = buf;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">Directory may already exist</span>
    CreateDir(*result);
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
  }

  <span class="org-keyword">static</span> <span class="org-type">uint64_t</span> <span class="org-function-name">gettid</span>() {
    <span class="org-type">pthread_t</span> <span class="org-variable-name">tid</span> = pthread_self();
    <span class="org-type">uint64_t</span> <span class="org-variable-name">thread_id</span> = 0;
    memcpy(&amp;thread_id, &amp;tid, <span class="org-constant">std</span>::min(<span class="org-keyword">sizeof</span>(thread_id), <span class="org-keyword">sizeof</span>(tid)));
    <span class="org-keyword">return</span> thread_id;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">NewLogger</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>, <span class="org-type">Logger</span>** <span class="org-variable-name">result</span>) {
    <span class="org-type">FILE</span>* <span class="org-variable-name">f</span> = fopen(fname.c_str(), <span class="org-string">"w"</span>);
    <span class="org-keyword">if</span> (f == <span class="org-constant">NULL</span>) {
      *result = <span class="org-constant">NULL</span>;
      <span class="org-keyword">return</span> IOError(fname, errno);
    } <span class="org-keyword">else</span> {
      *result = <span class="org-keyword">new</span> <span class="org-type">PosixLogger</span>(f, &amp;<span class="org-constant">PosixEnv</span>::gettid); <span class="org-comment-delimiter">// </span><span class="org-comment">Logger.&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;.</span>
      <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
    }
  }

  <span class="org-keyword">virtual</span> <span class="org-type">uint64_t</span> <span class="org-function-name">NowMicros</span>() {
    <span class="org-keyword">struct</span> <span class="org-type">timeval</span> <span class="org-variable-name">tv</span>;
    gettimeofday(&amp;tv, <span class="org-constant">NULL</span>);
    <span class="org-keyword">return</span> <span class="org-keyword">static_cast</span>&lt;uint64_t&gt;(tv.tv_sec) * 1000000 + tv.tv_usec;
  }

  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SleepForMicroseconds</span>(<span class="org-type">int</span> <span class="org-variable-name">micros</span>) {
    usleep(micros);
  }

 <span class="org-keyword">private</span>:
  <span class="org-type">void</span> <span class="org-function-name">PthreadCall</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">label</span>, <span class="org-type">int</span> <span class="org-variable-name">result</span>) {
    <span class="org-keyword">if</span> (result != 0) {
      fprintf(stderr, <span class="org-string">"pthread %s: %s\n"</span>, label, strerror(result));
      exit(1);
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#29468;&#24819;DB&#21518;&#38754;&#26377;&#19968;&#20010;&#32447;&#31243;&#23436;&#25104;&#19968;&#20123;&#20107;&#24773;&#36890;&#36807;queue&#26469;&#36827;&#34892;&#36890;&#30693;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">BGThread() is the body of the background thread</span>
  <span class="org-type">void</span> <span class="org-function-name">BGThread</span>();
  <span class="org-keyword">static</span> <span class="org-type">void</span>* <span class="org-function-name">BGThreadWrapper</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>) {
    <span class="org-keyword">reinterpret_cast</span>&lt;PosixEnv*&gt;(arg)-&gt;BGThread();
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  }

  <span class="org-type">size_t</span> <span class="org-variable-name">page_size_</span>;
  <span class="org-type">pthread_mutex_t</span> <span class="org-variable-name">mu_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">queue&#30340;&#38145;&#21644;&#26465;&#20214;&#21464;&#37327;</span>
  <span class="org-type">pthread_cond_t</span> <span class="org-variable-name">bgsignal_</span>;
  <span class="org-type">pthread_t</span> <span class="org-variable-name">bgthread_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">background thread identity.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">started_bgthread_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">bg thread&#26159;&#21542;&#21551;&#21160;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Entry per Schedule() call</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">background item&#36824;&#26159;&#27604;&#36739;&#36890;&#29992;&#30340;,function+arg.</span>
  <span class="org-keyword">struct</span> <span class="org-type">BGItem</span> { <span class="org-type">void</span>* <span class="org-variable-name">arg</span>; <span class="org-type">void</span> (*<span class="org-function-name">function</span>)(<span class="org-type">void</span>*); };
  <span class="org-keyword">typedef</span> <span class="org-constant">std</span>::<span class="org-type">deque</span>&lt;<span class="org-type">BGItem</span>&gt; <span class="org-type">BGQueue</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Background queue&#38431;&#21015;.</span>
  <span class="org-type">BGQueue</span> <span class="org-variable-name">queue_</span>;
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline165"></a>LockOrUnlock<br  /><div class="outline-text-5" id="text-10-4-1-1">
<p>
将fd设置成写锁.lock表示是加锁还是解锁.这里flock不需要保留空间只是传引用即可,对于内部调用仅仅是修改了fd的一个标记吧.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">int</span> <span class="org-function-name">LockOrUnlock</span>(<span class="org-type">int</span> <span class="org-variable-name">fd</span>, <span class="org-type">bool</span> <span class="org-variable-name">lock</span>) {
  errno = 0;
  <span class="org-keyword">struct</span> <span class="org-type">flock</span> <span class="org-variable-name">f</span>;
  memset(&amp;f, 0, <span class="org-keyword">sizeof</span>(f));
  f.l_type = (lock ? F_WRLCK : F_UNLCK);
  f.l_whence = SEEK_SET;
  f.l_start = 0;
  f.l_len = 0;        <span class="org-comment-delimiter">// </span><span class="org-comment">Lock/unlock entire file</span>
  <span class="org-keyword">return</span> fcntl(fd, F_SETLK, &amp;f);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline166"></a>Schedule<br  /><div class="outline-text-5" id="text-10-4-1-2">
<p>
Schedule语义就是将一个function+arg丢到background里面运行.background线程是惰性初始化的.
注意background只有一个执行线程，需要考虑工作是否会阻塞住。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">PosixEnv</span>::<span class="org-function-name">Schedule</span>(<span class="org-type">void</span> (*<span class="org-variable-name">function</span>)(<span class="org-type">void</span>*), <span class="org-type">void</span>* <span class="org-variable-name">arg</span>) {
  PthreadCall(<span class="org-string">"lock"</span>, pthread_mutex_lock(&amp;mu_));

  <span class="org-comment-delimiter">// </span><span class="org-comment">Start background thread if necessary</span>
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>started_bgthread_) {
    started_bgthread_ = <span class="org-constant">true</span>;
    PthreadCall( <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#32447;&#31243;.</span>
        <span class="org-string">"create thread"</span>,
        pthread_create(&amp;bgthread_, <span class="org-constant">NULL</span>,  &amp;<span class="org-constant">PosixEnv</span>::BGThreadWrapper, <span class="org-keyword">this</span>));
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">If the queue is currently empty, the background thread may currently be</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">waiting.</span>
  <span class="org-keyword">if</span> (queue_.empty()) {
    PthreadCall(<span class="org-string">"signal"</span>, pthread_cond_signal(&amp;bgsignal_)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#38431;&#21015;&#36890;&#30693;</span>
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add to priority queue</span>
  queue_.push_back(BGItem()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#38431;&#21015;&#20869;&#37096;&#21152;&#20837;&#23545;&#35937;.</span>
  queue_.back().function = function;
  queue_.back().arg = arg;

  PthreadCall(<span class="org-string">"unlock"</span>, pthread_mutex_unlock(&amp;mu_));
}
</pre>
</div>

<p>
其中BGThreadWrapper非常简单调用BGThread函数执行
</p>
<div class="org-src-container">

<pre class="src src-C++">  <span class="org-keyword">static</span> <span class="org-type">void</span>* <span class="org-function-name">BGThreadWrapper</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>) {
    <span class="org-keyword">reinterpret_cast</span>&lt;PosixEnv*&gt;(arg)-&gt;BGThread();
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  }
<span class="org-type">void</span> <span class="org-constant">PosixEnv</span>::<span class="org-function-name">BGThread</span>() {
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Wait until there is an item that is ready to run</span>
    PthreadCall(<span class="org-string">"lock"</span>, pthread_mutex_lock(&amp;mu_));
    <span class="org-keyword">while</span> (queue_.empty()) {
      PthreadCall(<span class="org-string">"wait"</span>, pthread_cond_wait(&amp;bgsignal_, &amp;mu_));
    }

    <span class="org-type">void</span> (*<span class="org-variable-name">function</span>)(<span class="org-type">void</span>*) = queue_.front().function; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#32447;&#31243;&#20869;&#37096;&#25191;&#34892;&#20989;&#25968;.</span>
    <span class="org-type">void</span>* <span class="org-variable-name">arg</span> = queue_.front().arg;
    queue_.pop_front();

    PthreadCall(<span class="org-string">"unlock"</span>, pthread_mutex_unlock(&amp;mu_));
    (*function)(arg);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline167"></a>StartThread<br  /><div class="outline-text-5" id="text-10-4-1-3">
<p>
启动一个线程.但是似乎有限制没有能力进行join.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">PosixEnv</span>::<span class="org-function-name">StartThread</span>(<span class="org-type">void</span> (*<span class="org-variable-name">function</span>)(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>), <span class="org-type">void</span>* <span class="org-variable-name">arg</span>) {
  <span class="org-type">pthread_t</span> <span class="org-variable-name">t</span>;
  <span class="org-type">StartThreadState</span>* <span class="org-variable-name">state</span> = <span class="org-keyword">new</span> <span class="org-type">StartThreadState</span>;
  state-&gt;user_function = function;
  state-&gt;arg = arg;
  PthreadCall(<span class="org-string">"start thread"</span>,
              pthread_create(&amp;t, <span class="org-constant">NULL</span>,  &amp;StartThreadWrapper, state));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline168"></a>Default<br  /><div class="outline-text-5" id="text-10-4-1-4">
<p>
Default是为了获得Env的一个实例.为了防止多个线程产生多个Env实例.使用pthread_once来产生.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">pthread_once_t</span> <span class="org-variable-name">once</span> = PTHREAD_ONCE_INIT;
<span class="org-keyword">static</span> <span class="org-type">Env</span>* <span class="org-variable-name">default_env</span>;
<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">InitDefaultEnv</span>() { default_env = <span class="org-keyword">new</span> <span class="org-type">PosixEnv</span>; }

<span class="org-type">Env</span>* <span class="org-constant">Env</span>::<span class="org-function-name">Default</span>() {
  pthread_once(&amp;once, InitDefaultEnv);
  <span class="org-keyword">return</span> default_env;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline170" class="outline-4">
<h4 id="orgheadline170"><span class="section-number-4">10.4.2</span> PosixFileLock</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
util/env_posix.cc PosixFilLock是FileLock的实现。基本上PosixFileLock没有任何内容，里面只需要维护fd即可。然后在LockOrUnlock里面操作fd即可以加锁解锁
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">PosixFileLock</span> : <span class="org-keyword">public</span> <span class="org-type">FileLock</span> {
 <span class="org-keyword">public</span>:
  <span class="org-type">int</span> <span class="org-variable-name">fd_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline171" class="outline-4">
<h4 id="orgheadline171"><span class="section-number-4">10.4.3</span> PosixLogger</h4>
<div class="outline-text-4" id="text-10-4-3">
<p>
util/posix_logger.h PosixLogger是Logger的实现。我们主要看看logger打印了哪些信息，并且稍微看看如果我们写logger的话大致应该需要考虑什么问题
PosixLogger持有了FILE*对象以及gettid的函数指针.只有一个方法Logv
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Logv</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">format</span>, <span class="org-type">va_list</span> <span class="org-variable-name">ap</span>) {
  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">thread_id</span> = (*gettid_)();

  <span class="org-comment-delimiter">// </span><span class="org-comment">We try twice: the first time with a fixed-size stack allocated buffer,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">and the second time with a much larger dynamically allocated buffer.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#22320;&#26041;&#20540;&#24471;&#23398;&#20064;&#19968;&#19979;.&#31532;&#19968;&#27425;&#20351;&#29992;stack&#20998;&#37197;&#20869;&#23384;&#65292;&#31532;&#20108;&#27425;&#20351;&#29992;heap&#20998;&#37197;&#20869;&#23384;.</span>
  <span class="org-type">char</span> <span class="org-variable-name">buffer</span>[500];
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">iter</span> = 0; iter &lt; 2; iter++) {
    <span class="org-type">char</span>* <span class="org-variable-name">base</span>;
    <span class="org-type">int</span> <span class="org-variable-name">bufsize</span>;
    <span class="org-keyword">if</span> (iter == 0) {
      bufsize = <span class="org-keyword">sizeof</span>(buffer);
      base = buffer;
    } <span class="org-keyword">else</span> {
      bufsize = 30000;
      base = <span class="org-keyword">new</span> <span class="org-type">char</span>[bufsize];
    }
    <span class="org-type">char</span>* <span class="org-variable-name">p</span> = base;
    <span class="org-type">char</span>* <span class="org-variable-name">limit</span> = base + bufsize;

    <span class="org-keyword">struct</span> <span class="org-type">timeval</span> <span class="org-variable-name">now_tv</span>;
    gettimeofday(&amp;now_tv, <span class="org-constant">NULL</span>);
    <span class="org-keyword">const</span> <span class="org-type">time_t</span> <span class="org-variable-name">seconds</span> = now_tv.tv_sec;
    <span class="org-keyword">struct</span> <span class="org-type">tm</span> <span class="org-variable-name">t</span>;
    localtime_r(&amp;seconds, &amp;t); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26412;&#22320;&#26102;&#38388;+microseconds &#32447;&#31243;&#21495; &#33258;&#23450;&#20041;&#26684;&#24335;.</span>
    p += snprintf(p, limit - p,
                  <span class="org-string">"%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "</span>,
                  t.tm_year + 1900,
                  t.tm_mon + 1,
                  t.tm_mday,
                  t.tm_hour,
                  t.tm_min,
                  t.tm_sec,
                  <span class="org-keyword">static_cast</span>&lt;<span class="org-type">int</span>&gt;(now_tv.tv_usec),
                  <span class="org-keyword">static_cast</span>&lt;<span class="org-type">long</span> <span class="org-type">long</span> <span class="org-type">unsigned</span> <span class="org-type">int</span>&gt;(thread_id));

    <span class="org-comment-delimiter">// </span><span class="org-comment">Print the message</span>
    <span class="org-keyword">if</span> (p &lt; limit) {
      <span class="org-type">va_list</span> <span class="org-variable-name">backup_ap</span>;
      va_copy(backup_ap, ap);
      p += vsnprintf(p, limit - p, format, backup_ap);
      va_end(backup_ap);
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Truncate to available space if necessary</span>
    <span class="org-keyword">if</span> (p &gt;= limit) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36229;&#36807;&#30340;&#35805;&#24182;&#19988;&#26159;stack&#20998;&#37197;&#37027;&#20040;&#37325;&#26032;&#19968;&#36718;.</span>
      <span class="org-keyword">if</span> (iter == 0) {
        <span class="org-keyword">continue</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">Try again with larger buffer</span>
      } <span class="org-keyword">else</span> {
        p = limit - 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#31532;&#20108;&#36718;&#30340;&#35805;&#36827;&#34892;&#25130;&#26029;.</span>
      }
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Add newline if necessary</span>
    <span class="org-keyword">if</span> (p == base || p[-1] != <span class="org-string">'\n'</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30830;&#20445;&#23384;&#22312;&#25442;&#34892;.</span>
      *p++ = <span class="org-string">'\n'</span>;
    }

    assert(p &lt;= limit);
    fwrite(base, 1, p - base, file_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;&#20837;&#25991;&#20214;&#24182;&#19988;&#36825;&#37324;&#27880;&#24847;&#38656;&#35201;flush.</span>
    fflush(file_);
    <span class="org-keyword">if</span> (base != buffer) {
      <span class="org-keyword">delete</span>[] base;
    }
    <span class="org-keyword">break</span>;
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline172" class="outline-4">
<h4 id="orgheadline172"><span class="section-number-4">10.4.4</span> PosixRandomAccessFile</h4>
<div class="outline-text-4" id="text-10-4-4">
<p>
util/env_posix.cc PosixRandomAccessFile是RandomAccessFile的实现。对于随机读取的话使用pread应该就可以了.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Read</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">offset</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">Slice</span>* <span class="org-variable-name">result</span>,
                    <span class="org-type">char</span>* <span class="org-variable-name">scratch</span>) <span class="org-keyword">const</span> {
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  <span class="org-type">ssize_t</span> <span class="org-variable-name">r</span> = pread(fd_, scratch, n, <span class="org-keyword">static_cast</span>&lt;off_t&gt;(offset));
  *result = Slice(scratch, (r &lt; 0) ? 0 : r);
  <span class="org-keyword">if</span> (r &lt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">An error: return a non-ok status</span>
    s = IOError(filename_, errno);
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline173" class="outline-4">
<h4 id="orgheadline173"><span class="section-number-4">10.4.5</span> PosixSequentialFile</h4>
<div class="outline-text-4" id="text-10-4-5">
<p>
util/env_posix.cc PosixSequentialFile是SequentialFile的实现。内部实现的持有FILE*指针.猜想对于顺序访问而言的话，缓存还是会非常有效果的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Read</span>(<span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">Slice</span>* <span class="org-variable-name">result</span>, <span class="org-type">char</span>* <span class="org-variable-name">scratch</span>) {
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">r</span> = fread_unlocked(scratch, 1, n, file_);
  *result = Slice(scratch, r);
  <span class="org-keyword">if</span> (r &lt; n) {
    <span class="org-keyword">if</span> (feof(file_)) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">We leave status as ok if we hit the end of the file</span>
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">A partial read with an error: return a non-ok status</span>
      s = IOError(filename_, errno);
    }
  }
  <span class="org-keyword">return</span> s;
}

<span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Skip</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">n</span>) {
  <span class="org-keyword">if</span> (fseek(file_, n, SEEK_CUR)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#24403;&#21069;&#36339;&#36807;n&#20010;&#23383;&#33410;.</span>
    <span class="org-keyword">return</span> IOError(filename_, errno);
  }
  <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
}
</pre>
</div>
<p>
fread_unlocked表示内部不会存在多个线程来读取这个文件.可以在一定程度上提高性能.
</p>
</div>
</div>

<div id="outline-container-orgheadline178" class="outline-4">
<h4 id="orgheadline178"><span class="section-number-4">10.4.6</span> PosixMmapFile</h4>
<div class="outline-text-4" id="text-10-4-6">
<p>
util/env_posix.cc PosixMmapFile是为了实现WritableFile的.内部使用mmap来实现的文件追加写和同步方式.还是比较精巧的，值得仔细看看
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-function-name">PosixMmapFile</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">fname</span>, <span class="org-type">int</span> <span class="org-variable-name">fd</span>, <span class="org-type">size_t</span> <span class="org-variable-name">page_size</span>)
    : filename_(fname),
      fd_(fd),
      page_size_(page_size),
      map_size_(Roundup(65536, page_size)), <span class="org-comment-delimiter">// </span><span class="org-comment">65536 roundup to pagesize&#20316;&#20026;&#19968;&#20010;mmap&#30340;&#22823;&#23567;.</span>
      base_(<span class="org-constant">NULL</span>), <span class="org-comment-delimiter">// </span><span class="org-comment">mmap&#20986;&#26469;&#30340;base,dst(&#24403;&#21069;&#21487;&#29992;&#22320;&#22336;),limit(&#32467;&#26463;&#22320;&#22336;)</span>
      limit_(<span class="org-constant">NULL</span>),
      dst_(<span class="org-constant">NULL</span>),
      last_sync_(<span class="org-constant">NULL</span>), <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#36733;&#36827;&#34892;sync&#30340;&#36215;&#22987;&#22320;&#22336;</span>
      file_offset_(0), <span class="org-comment-delimiter">//</span>
      pending_sync_(<span class="org-constant">false</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#23384;&#22312;pending sync&#30913;&#30424;&#20869;&#23481;.&#21542;&#21017;&#38656;&#35201;&#35843;&#29992;fdatasync</span>
  assert((page_size &amp; (page_size - 1)) == 0);
}


~<span class="org-function-name">PosixMmapFile</span>() {
  <span class="org-keyword">if</span> (fd_ &gt;= 0) {
    <span class="org-constant">PosixMmapFile</span>::Close();
  }
}

<span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Append</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">data</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23581;&#35797;&#22686;&#21152;&#25968;&#25454;.</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">src</span> = data.data();
  <span class="org-type">size_t</span> <span class="org-variable-name">left</span> = data.size();
  <span class="org-keyword">while</span> (left &gt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36824;&#26377;&#37096;&#20998;&#25968;&#25454;&#27809;&#26377;&#20889;&#20837;.</span>
    assert(base_ &lt;= dst_);
    assert(dst_ &lt;= limit_);
    <span class="org-type">size_t</span> <span class="org-variable-name">avail</span> = limit_ - dst_;
    <span class="org-keyword">if</span> (avail == 0) {
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>UnmapCurrentRegion() || <span class="org-comment-delimiter">// </span><span class="org-comment">unmap&#24403;&#21069;&#30340;&#21306;&#22495;&#24182;&#19988;&#20998;&#37197;&#26032;&#30340;&#21306;&#22495;.</span>
          <span class="org-negation-char">!</span>MapNewRegion()) {
        <span class="org-keyword">return</span> IOError(filename_, errno);
      }
    }

    <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = (left &lt;= avail) ? left : avail;
    memcpy(dst_, src, n);
    dst_ += n;
    src += n;
    left -= n;
  }
  <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
}

<span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Close</span>() {
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">unused</span> = limit_ - dst_;
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>UnmapCurrentRegion()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#21097;&#20313;&#30340;&#37096;&#20998;unmap&#25481;</span>
    s = IOError(filename_, errno);
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (unused &gt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Trim the extra space at the end of the file</span>
    <span class="org-keyword">if</span> (ftruncate(fd_, file_offset_ - unused) &lt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#26102;&#38656;&#35201;truncate&#22810;mmap&#30340;&#37096;&#20998;.</span>
      s = IOError(filename_, errno);
    }
  }

  <span class="org-keyword">if</span> (close(fd_) &lt; 0) {
    <span class="org-keyword">if</span> (s.ok()) {
      s = IOError(filename_, errno);
    }
  }

  fd_ = -1;
  base_ = <span class="org-constant">NULL</span>;
  limit_ = <span class="org-constant">NULL</span>;
  <span class="org-keyword">return</span> s;
}

<span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Flush</span>() {
  <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
}

<span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">Sync</span>() {
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;

  <span class="org-keyword">if</span> (pending_sync_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23384;&#22312;&#38656;&#35201;sync&#30340;&#37096;&#20998;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Some unmapped data was not synced</span>
    pending_sync_ = <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> (fdatasync(fd_) &lt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20010;&#37096;&#20998;data sync.</span>
      s = IOError(filename_, errno);
    }
  }

  <span class="org-keyword">if</span> (dst_ &gt; last_sync_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#20869;&#23384;&#37096;&#20998;&#36827;&#34892;sync.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Find the beginnings of the pages that contain the first and last</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">bytes to be synced.</span>
    <span class="org-type">size_t</span> <span class="org-variable-name">p1</span> = TruncateToPageBoundary(last_sync_ - base_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#33021;&#20250;&#22810;msync&#37096;&#20998;&#20294;&#26159;&#27809;&#26377;&#20851;&#31995;.</span>
    <span class="org-type">size_t</span> <span class="org-variable-name">p2</span> = TruncateToPageBoundary(dst_ - base_ - 1);
    last_sync_ = dst_;
    <span class="org-keyword">if</span> (msync(base_ + p1, p2 - p1 + page_size_, MS_SYNC) &lt; 0) {
      s = IOError(filename_, errno);
    }
  }

  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline174"></a>Roundup<br  /><div class="outline-text-5" id="text-10-4-6-1">
<p>
Roundup非常简单.使用时候就是希望mapsize作为pagesize的整数倍存在.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Roundup x to a multiple of y</span>
<span class="org-keyword">static</span> <span class="org-type">size_t</span> <span class="org-function-name">Roundup</span>(<span class="org-type">size_t</span> <span class="org-variable-name">x</span>, <span class="org-type">size_t</span> <span class="org-variable-name">y</span>) {
  <span class="org-keyword">return</span> ((x + y - 1) / y) * y;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline175"></a>TruncateToPageBoundar<br  /><div class="outline-text-5" id="text-10-4-6-2">
<p>
我们需要记住这个函数的语境，是将s的长度截断到pagesize整数倍，这样可以让msync刷新确保正确。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">size_t</span> <span class="org-function-name">TruncateToPageBoundary</span>(<span class="org-type">size_t</span> <span class="org-variable-name">s</span>) {
  s -= (s &amp; (page_size_ - 1));
  assert((s % page_size_) == 0);
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline176"></a>UnmapCurrentRegion<br  /><div class="outline-text-5" id="text-10-4-6-3">
<p>
解除当前的内存映射。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-function-name">UnmapCurrentRegion</span>() {
  <span class="org-type">bool</span> <span class="org-variable-name">result</span> = <span class="org-constant">true</span>;
  <span class="org-keyword">if</span> (base_ != <span class="org-constant">NULL</span>) {
    <span class="org-keyword">if</span> (last_sync_ &lt; limit_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19978;&#19968;&#27425;&#27809;&#20869;&#23384;&#26144;&#23556;&#23436;&#25104;&#30340;&#35805;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Defer syncing this data until next Sync() call, if any</span>
      pending_sync_ = <span class="org-constant">true</span>;
    }
    <span class="org-keyword">if</span> (munmap(base_, limit_ - base_) != 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35299;&#38500;&#20869;&#23384;&#26144;&#23556;.</span>
      result = <span class="org-constant">false</span>;
    }
    file_offset_ += limit_ - base_; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;fileoffset&#26377;&#22810;&#23569;.</span>
    base_ = <span class="org-constant">NULL</span>;
    limit_ = <span class="org-constant">NULL</span>;
    last_sync_ = <span class="org-constant">NULL</span>;
    dst_ = <span class="org-constant">NULL</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Increase the amount we map the next time, but capped at 1MB</span>
    <span class="org-keyword">if</span> (map_size_ &lt; (1&lt;&lt;20)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#27425;mapsize&#38656;&#35201;&#32763;&#20493;.</span>
      map_size_ *= 2;
    }
  }
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline177"></a>MapNewRegion<br  /><div class="outline-text-5" id="text-10-4-6-4">
<p>
使用mmap分配一块新的内存然后用于后续的写文件
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-function-name">MapNewRegion</span>() {
  assert(base_ == <span class="org-constant">NULL</span>);
  <span class="org-keyword">if</span> (ftruncate(fd_, file_offset_ + map_size_) &lt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;&#36825;&#27425;&#25105;&#20204;&#25171;&#31639;&#21482;&#20889;file_offset+map_size&#36825;&#20040;&#22823;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#25152;&#20197;&#22810;&#20313;&#30340;&#37096;&#20998;&#25105;&#20204;&#21487;&#20197;&#25130;&#26029;.</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
  <span class="org-type">void</span>* <span class="org-variable-name">ptr</span> = mmap(<span class="org-constant">NULL</span>, map_size_, PROT_READ | PROT_WRITE, MAP_SHARED,
                   fd_, file_offset_);
  <span class="org-keyword">if</span> (ptr == MAP_FAILED) {
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
  base_ = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-type">char</span>*&gt;(ptr);
  limit_ = base_ + map_size_;
  dst_ = base_;
  last_sync_ = base_;
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>
</div></li></ol>
</div>
</div>

<div id="outline-container-orgheadline188" class="outline-3">
<h3 id="orgheadline188"><span class="section-number-3">10.5</span> Cache</h3>
<div class="outline-text-3" id="text-10-5">
</div><div id="outline-container-orgheadline180" class="outline-4">
<h4 id="orgheadline180"><span class="section-number-4">10.5.1</span> ShardedLRUCache</h4>
<div class="outline-text-4" id="text-10-5-1">
<p>
util/cache.cc 所谓Shard意思非常简单，就是将所有的请求进行load-balance.首先看看字段.里面使用到了LRUCache.LRUCache后面会讲到
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kNumShardBits</span> = 4;
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kNumShards</span> = 1 &lt;&lt; kNumShardBits;

<span class="org-keyword">class</span> <span class="org-type">ShardedLRUCache</span> : <span class="org-keyword">public</span> <span class="org-type">Cache</span> {
 <span class="org-keyword">private</span>:
  <span class="org-type">LRUCache</span> <span class="org-variable-name">shard_</span>[kNumShards];
  <span class="org-constant">port</span>::<span class="org-type">Mutex</span> <span class="org-variable-name">id_mutex_</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">last_id_</span>;
};
</pre>
</div>
<p>
可以看到有16个slot.对于load-balance策略也非常简单.取hash结果的高位.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">uint32_t</span> <span class="org-function-name">Shard</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>) {
  <span class="org-keyword">return</span> hash &gt;&gt; (32 - kNumShardBits);
}
</pre>
</div>
<p>
对于Shard而言的话，capacity也需要进行均分:)
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">explicit</span> <span class="org-function-name">ShardedLRUCache</span>(<span class="org-type">size_t</span> <span class="org-variable-name">capacity</span>)
    : last_id_(0) {
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">per_shard</span> = (capacity + (kNumShards - 1)) / kNumShards;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">s</span> = 0; s &lt; kNumShards; s++) {
    shard_[s].SetCapacity(per_shard);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline185" class="outline-4">
<h4 id="orgheadline185"><span class="section-number-4">10.5.2</span> LRUCache</h4>
<div class="outline-text-4" id="text-10-5-2">
<p>
util/cache.cc LRUCache实现就是按照LRU来实现的.LRUCache每一个item是一个LRUHandle，而LRUHandle管理是放在HandleTable里面管理的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A single shard of sharded cache.</span>
<span class="org-keyword">class</span> <span class="org-type">LRUCache</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">LRUCache</span>();
  ~<span class="org-function-name">LRUCache</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Separate from constructor so caller can easily make an array of LRUCache</span>
  <span class="org-type">void</span> <span class="org-function-name">SetCapacity</span>(<span class="org-type">size_t</span> <span class="org-variable-name">capacity</span>) { capacity_ = capacity; }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Like Cache methods, but with an extra "hash" parameter.</span>
  <span class="org-constant">Cache</span>::Handle* Insert(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>,
                        <span class="org-type">void</span>* <span class="org-variable-name">value</span>, <span class="org-type">size_t</span> <span class="org-variable-name">charge</span>,
                        <span class="org-type">void</span> (*<span class="org-variable-name">deleter</span>)(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">void</span>* <span class="org-variable-name">value</span>));
  <span class="org-constant">Cache</span>::Handle* Lookup(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>);
  <span class="org-type">void</span> <span class="org-function-name">Release</span>(<span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-variable-name">handle</span>);
  <span class="org-type">void</span> <span class="org-function-name">Erase</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>);

 <span class="org-keyword">private</span>:
  <span class="org-type">void</span> <span class="org-function-name">LRU_Remove</span>(<span class="org-type">LRUHandle</span>* <span class="org-variable-name">e</span>);
  <span class="org-type">void</span> <span class="org-function-name">LRU_Append</span>(<span class="org-type">LRUHandle</span>* <span class="org-variable-name">e</span>);
  <span class="org-type">void</span> <span class="org-function-name">Unref</span>(<span class="org-type">LRUHandle</span>* <span class="org-variable-name">e</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Initialized before use.</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">capacity_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">usage_&#30340;&#26368;&#22823;&#20540;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">mutex_ protects the following state.</span>
  <span class="org-constant">port</span>::<span class="org-type">Mutex</span> <span class="org-variable-name">mutex_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#22810;&#32447;&#31243;&#26377;&#25928;</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">usage_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#20351;&#29992;&#22823;&#23567;.+=Insert&#21442;&#25968;&#30340;charge.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">last_id_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;ShardedLRUCache&#37324;&#38754;&#20351;&#29992;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Dummy head of LRU list.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">lru.prev is newest entry, lru.next is oldest entry.</span>
  <span class="org-type">LRUHandle</span> <span class="org-variable-name">lru_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">LRU&#38142;.</span>

  <span class="org-type">HandleTable</span> <span class="org-variable-name">table_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">LRUHandle&#30340;&#31649;&#29702;&#23545;&#35937;&#34920;(hashtable).</span>
};
</pre>
</div>
<p>
对于LRU_Remove/LRU_Append非常简单.这里稍微着重看看Insert/Loopup/Release/Erase的实现.
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline181"></a>Insert<br  /><div class="outline-text-5" id="text-10-5-2-1">
<p>
Insert的工作就是创建一个LRUHandle对象加入hashtable以及LRU队列里面.注意这里的引用计数
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-constant">LRUCache</span>::<span class="org-function-name">Insert</span>(
    <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>, <span class="org-type">void</span>* <span class="org-variable-name">value</span>, <span class="org-type">size_t</span> <span class="org-variable-name">charge</span>,
    <span class="org-type">void</span> (*<span class="org-variable-name">deleter</span>)(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">void</span>* <span class="org-variable-name">value</span>)) {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);

  <span class="org-type">LRUHandle</span>* <span class="org-variable-name">e</span> = <span class="org-keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(
      malloc(<span class="org-keyword">sizeof</span>(LRUHandle)-1 + key.size()));
  e-&gt;value = value; <span class="org-comment-delimiter">// </span><span class="org-comment">value.</span>
  e-&gt;deleter = deleter; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21024;&#38500;&#20989;&#25968;</span>
  e-&gt;charge = charge; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21344;&#29992;&#22823;&#23567;</span>
  e-&gt;key_length = key.size(); <span class="org-comment-delimiter">// </span><span class="org-comment">key</span>
  e-&gt;hash = hash; <span class="org-comment-delimiter">// </span><span class="org-comment">hash</span>
  e-&gt;refs = 2;  <span class="org-comment-delimiter">// </span><span class="org-comment">One from LRUCache, one for the returned handle</span>
  memcpy(e-&gt;key_data, key.data(), key.size());
  LRU_Append(e); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21152;&#20837;LRU&#38431;&#21015;</span>
  usage_ += charge; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#21344;&#29992;&#37327;</span>

  <span class="org-type">LRUHandle</span>* <span class="org-variable-name">old</span> = table_.Insert(e);
  <span class="org-keyword">if</span> (old != <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#28120;&#27760;&#20986;&#30340;&#20869;&#23481;.</span>
    LRU_Remove(old);
    Unref(old);
  }

  <span class="org-keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) {
    <span class="org-type">LRUHandle</span>* <span class="org-variable-name">old</span> = lru_.next;
    LRU_Remove(old);
    table_.Remove(old-&gt;key(), old-&gt;hash);
    Unref(old);
  }

  <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-constant">Cache</span>::Handle*&gt;(e);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline182"></a>Lookup<br  /><div class="outline-text-5" id="text-10-5-2-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-constant">LRUCache</span>::<span class="org-function-name">Lookup</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>) {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-type">LRUHandle</span>* <span class="org-variable-name">e</span> = table_.Lookup(key, hash); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#23545;&#35937;</span>
  <span class="org-keyword">if</span> (e != <span class="org-constant">NULL</span>) {
    e-&gt;refs++; <span class="org-comment-delimiter">// </span><span class="org-comment">&#38656;&#35201;&#20462;&#25913;&#24341;&#29992;&#35745;&#25968;.</span>
    LRU_Remove(e); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20462;&#25913;&#19968;&#19979;LRU&#29366;&#24577;.</span>
    LRU_Append(e);
  }
  <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-constant">Cache</span>::Handle*&gt;(e);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline183"></a>Release<br  /><div class="outline-text-5" id="text-10-5-2-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">LRUCache</span>::<span class="org-function-name">Release</span>(<span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-variable-name">handle</span>) {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  Unref(<span class="org-keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20943;&#23569;&#24341;&#29992;&#35745;&#25968;</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline184"></a>Erase<br  /><div class="outline-text-5" id="text-10-5-2-4">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">LRUCache</span>::<span class="org-function-name">Erase</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>) {
  MutexLock <span class="org-type">l</span>(&amp;<span class="org-variable-name">mutex_</span>);
  <span class="org-type">LRUHandle</span>* <span class="org-variable-name">e</span> = table_.Remove(key, hash); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;table&#37324;&#38754;remove&#20986;&#26469;</span>
  <span class="org-keyword">if</span> (e != <span class="org-constant">NULL</span>) {
    LRU_Remove(e); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;LRU&#38431;&#21015;&#37324;&#38754;&#31227;&#38500;&#20986;&#26469;</span>
    Unref(e); <span class="org-comment-delimiter">// </span><span class="org-comment">--&#24341;&#29992;&#35745;&#25968;.</span>
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline186" class="outline-4">
<h4 id="orgheadline186"><span class="section-number-4">10.5.3</span> LRUHandle</h4>
<div class="outline-text-4" id="text-10-5-3">
<p>
util/cache.cc LRUHandle是LRUCache的管理对象，我们主要就是为了看看里面的结构.LRUHandle一方面在LRU队列里面需要维护指针，
一方面在hashtable(HandleTable下面会讲到)需要维护指针.同时存在于LRU队列和HashTable里面.但是引用计数以LRU队列为准
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">An entry is a variable length heap-allocated structure.  Entries</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">are kept in a circular doubly linked list ordered by access time.</span>
<span class="org-keyword">struct</span> <span class="org-type">LRUHandle</span> {
  <span class="org-type">void</span>* <span class="org-variable-name">value</span>;
  <span class="org-type">void</span> (*<span class="org-function-name">deleter</span>)(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp;, <span class="org-type">void</span>* <span class="org-variable-name">value</span>);
  <span class="org-type">LRUHandle</span>* <span class="org-variable-name">next_hash</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;hash table&#30340;&#21333;&#21521;&#38142;&#34920;.</span>
  <span class="org-type">LRUHandle</span>* <span class="org-variable-name">next</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">LRU&#38431;&#21015;&#25152;&#38656;&#35201;&#30340;&#25351;&#38024;.</span>
  <span class="org-type">LRUHandle</span>* <span class="org-variable-name">prev</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">charge</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">TODO(opt): Only allow uint32_t? // &#21344;&#29992;cache&#22823;&#23567;</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">key_length</span>;
  <span class="org-type">uint32_t</span> <span class="org-variable-name">refs</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24341;&#29992;&#35745;&#25968;.</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">hash</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">Hash of key(); used for fast sharding and comparisons // &#21487;&#33021;&#38656;&#35201;&#36827;&#34892;rehash.</span>
  <span class="org-type">char</span> <span class="org-variable-name">key_data</span>[1];   <span class="org-comment-delimiter">// </span><span class="org-comment">Beginning of key</span>

  <span class="org-type">Slice</span> <span class="org-function-name">key</span>() <span class="org-keyword">const</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">For cheaper lookups, we allow a temporary Handle object</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">to store a pointer to a key in "value".</span>
    <span class="org-keyword">if</span> (next == <span class="org-keyword">this</span>) {
      <span class="org-keyword">return</span> *(<span class="org-keyword">reinterpret_cast</span>&lt;Slice*&gt;(value));
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">return</span> Slice(key_data, key_length);
    }
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline187" class="outline-4">
<h4 id="orgheadline187"><span class="section-number-4">10.5.4</span> HandleTable</h4>
<div class="outline-text-4" id="text-10-5-4">
<p>
util/cache.cc HandleTable实现非常简单，就是一个可扩展的hashtable.没有必要值得仔细分析。HandleTable主要就是用来管理
LRUHandle所管理的cache对象的。触发resize的操作是element &gt;= length.这里可以看看length的分配方式
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">uint32_t</span> <span class="org-variable-name">new_length</span> = 4;
<span class="org-keyword">while</span> (new_length &lt; elems_) {
  new_length *= 2;
}
</pre>
</div>
<p>
length肯定是2^n.计算slot的方式就是
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">LRUHandle</span>** <span class="org-variable-name">ptr</span> = &amp;list_[hash &amp; (length_ - 1)];
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline205" class="outline-3">
<h3 id="orgheadline205"><span class="section-number-3">10.6</span> Batch</h3>
<div class="outline-text-3" id="text-10-6">
</div><div id="outline-container-orgheadline197" class="outline-4">
<h4 id="orgheadline197"><span class="section-number-4">10.6.1</span> WriteBatch</h4>
<div class="outline-text-4" id="text-10-6-1">
<p>
db/write_batch.cc db/write_batch_internal.h WriteBatch可以认为就是一个小型的数据记录仓库.
write_batch_internal.h里面是一些write_batch里面可能使用到的静态函数，将选择将声明放在这个头文件里面而不是放在include/leveldb/write_batch.h里面.
之前有一段注释表明WriteBatch内部二进制组织方式.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">WriteBatch::rep_ :=</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">sequence: fixed64</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">count: fixed32</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">data: record[count]</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">record :=</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">kTypeValue varstring varstring         |</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">kTypeDeletion varstring</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">varstring :=</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">len: varint32</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">data: uint8[len]</span>
</pre>
</div>
<ul class="org-ul">
<li>sequence fixed64</li>
<li>记录长度 fixed32(因为这个写入是多次的,所以存放fixed比较容易修改)</li>
<li>每条记录有头部表示数据还是删除.对于数据就是kv,对于删除只是存放k</li>
<li>kv的话都是varint32 + data</li>
</ul>
<p>
这里rep_的类型是std::stirng.
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline189"></a>Count<br  /><div class="outline-text-5" id="text-10-6-1-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">WriteBatchInternal</span>::<span class="org-function-name">Count</span>(<span class="org-keyword">const</span> <span class="org-type">WriteBatch</span>* <span class="org-variable-name">b</span>) {
  <span class="org-keyword">return</span> DecodeFixed32(b-&gt;rep_.data() + 8);
}

<span class="org-type">void</span> <span class="org-constant">WriteBatchInternal</span>::<span class="org-function-name">SetCount</span>(<span class="org-type">WriteBatch</span>* <span class="org-variable-name">b</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>) {
  EncodeFixed32(&amp;b-&gt;rep_[8], n);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline190"></a>Sequence<br  /><div class="outline-text-5" id="text-10-6-1-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">SequenceNumber</span> <span class="org-constant">WriteBatchInternal</span>::<span class="org-function-name">Sequence</span>(<span class="org-keyword">const</span> <span class="org-type">WriteBatch</span>* <span class="org-variable-name">b</span>) {
  <span class="org-keyword">return</span> SequenceNumber(DecodeFixed64(b-&gt;rep_.data()));
}

<span class="org-type">void</span> <span class="org-constant">WriteBatchInternal</span>::<span class="org-function-name">SetSequence</span>(<span class="org-type">WriteBatch</span>* <span class="org-variable-name">b</span>, <span class="org-type">SequenceNumber</span> <span class="org-variable-name">seq</span>) {
  EncodeFixed64(&amp;b-&gt;rep_[0], seq);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline191"></a>Contents<br  /><div class="outline-text-5" id="text-10-6-1-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#30452;&#25509;&#35774;&#32622;WriteBatch&#20869;&#23481;.&#19981;&#36807;&#25105;&#35273;&#24471;&#24212;&#35813;&#27809;&#26377;&#22826;&#22810;&#29992;&#36884;&#21543;.</span>
<span class="org-type">void</span> <span class="org-constant">WriteBatchInternal</span>::<span class="org-function-name">SetContents</span>(<span class="org-type">WriteBatch</span>* <span class="org-variable-name">b</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">contents</span>) {
  assert(contents.size() &gt;= 12);
  b-&gt;rep_.assign(contents.data(), contents.size());
}
</pre>
</div>
</div></li>

<li><a id="orgheadline192"></a>Clear<br  /><div class="outline-text-5" id="text-10-6-1-4">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">WriteBatch</span>::<span class="org-function-name">Clear</span>() {
  rep_.clear();
  rep_.resize(12); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22836;&#37096;&#24517;&#28982;&#23384;&#25918;12&#20010;&#23383;&#33410;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline193"></a>Put<br  /><div class="outline-text-5" id="text-10-6-1-5">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">WriteBatch</span>::<span class="org-function-name">Put</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) {
  <span class="org-constant">WriteBatchInternal</span>::SetCount(<span class="org-keyword">this</span>, <span class="org-constant">WriteBatchInternal</span>::Count(<span class="org-keyword">this</span>) + 1);
  rep_.push_back(<span class="org-keyword">static_cast</span>&lt;<span class="org-type">char</span>&gt;(kTypeValue)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20165;&#20165;&#26159;value&#31867;&#22411;&#25805;&#20316;</span>
  PutLengthPrefixedSlice(&amp;rep_, key); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25918;&#20837;k,v.&#20043;&#21069;&#37117;&#23384;&#25918;&#20102;&#38271;&#24230;.</span>
  PutLengthPrefixedSlice(&amp;rep_, value);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline194"></a>Delete<br  /><div class="outline-text-5" id="text-10-6-1-6">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">WriteBatch</span>::<span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-constant">WriteBatchInternal</span>::SetCount(<span class="org-keyword">this</span>, <span class="org-constant">WriteBatchInternal</span>::Count(<span class="org-keyword">this</span>) + 1);
  rep_.push_back(<span class="org-keyword">static_cast</span>&lt;<span class="org-type">char</span>&gt;(kTypeDeletion)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20165;&#20165;&#26159;delete&#31867;&#22411;&#25805;&#20316;</span>
  PutLengthPrefixedSlice(&amp;rep_, key); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20165;&#20165;&#26159;&#23384;&#25918;key.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline195"></a>InsertInto<br  /><div class="outline-text-5" id="text-10-6-1-7">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;WriteBatch&#20869;&#23481;&#20840;&#37096;&#25554;&#20837;&#21040;MemTable&#37324;&#38754;&#21435;.&#35843;&#29992;Iterate&#25509;&#21475;.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">MemTableInserter&#20250;&#22312;&#21518;&#38754;&#35762;&#35299;&#21040;.&#36825;&#20010;&#21487;&#20197;&#29992;&#20110;&#23558;WriteBatch&#25552;&#20132;.</span>
<span class="org-type">Status</span> <span class="org-constant">WriteBatchInternal</span>::<span class="org-function-name">InsertInto</span>(<span class="org-keyword">const</span> <span class="org-type">WriteBatch</span>* <span class="org-variable-name">b</span>,
                                      <span class="org-type">MemTable</span>* <span class="org-variable-name">memtable</span>) {
  <span class="org-type">MemTableInserter</span> <span class="org-variable-name">inserter</span>;
  inserter.sequence_ = <span class="org-constant">WriteBatchInternal</span>::Sequence(b);
  inserter.mem_ = memtable;
  <span class="org-keyword">return</span> b-&gt;Iterate(&amp;inserter);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline196"></a>Iterate<br  /><div class="outline-text-5" id="text-10-6-1-8">
<p>
遍历内容存放到handler对象里面.要求handler有Put和Delete实现.这个实现在后面MemTableInserter有.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">WriteBatch</span>::<span class="org-function-name">Iterate</span>(<span class="org-type">Handler</span>* <span class="org-variable-name">handler</span>) <span class="org-keyword">const</span> {
  <span class="org-type">Slice</span> <span class="org-variable-name">input</span>(rep_);
  <span class="org-keyword">if</span> (input.size() &lt; 12) {
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"malformed WriteBatch (too small)"</span>);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#24573;&#30053;&#20043;&#21069;&#30340;12&#20010;&#23383;&#33410;.</span>
  input.remove_prefix(12);
  <span class="org-type">Slice</span> <span class="org-variable-name">key</span>, <span class="org-variable-name">value</span>;
  <span class="org-type">int</span> <span class="org-variable-name">found</span> = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">found&#24212;&#35813;&#26159;&#29992;&#26469;&#36827;&#34892;&#26657;&#39564;&#30340;.</span>
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>input.empty()) {
    found++;
    <span class="org-type">char</span> <span class="org-variable-name">tag</span> = input[0];
    input.remove_prefix(1);
    <span class="org-keyword">switch</span> (tag) {
      <span class="org-keyword">case</span> kTypeValue: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;kv&#25968;&#25454;&#30340;&#35805;.</span>
        <span class="org-keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key) &amp;&amp;
            GetLengthPrefixedSlice(&amp;input, &amp;value)) {
          handler-&gt;Put(key, value); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;handler-&gt;Put&#25509;&#21475;.</span>
        } <span class="org-keyword">else</span> {
          <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"bad WriteBatch Put"</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#35748;&#20026;&#25968;&#25454;&#25439;&#22351;.</span>
        }
        <span class="org-keyword">break</span>;
      <span class="org-keyword">case</span> kTypeDeletion: <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26159;delete&#25805;&#20316;&#30340;&#35805;.</span>
        <span class="org-keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key)) {
          handler-&gt;Delete(key); <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#35843;&#29992;Delete&#25509;&#21475;</span>
        } <span class="org-keyword">else</span> {
          <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"bad WriteBatch Delete"</span>);
        }
        <span class="org-keyword">break</span>;
      <span class="org-keyword">default</span>: <span class="org-comment-delimiter">// </span><span class="org-comment">&#40664;&#35748;&#20026;&#25968;&#25454;&#25439;&#22351;.</span>
        <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"unknown WriteBatch tag"</span>);
    }
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26657;&#39564;&#19968;&#19979;&#20010;&#25968;&#26159;&#21542;&#27491;&#30830;.</span>
  <span class="org-keyword">if</span> (found != <span class="org-constant">WriteBatchInternal</span>::Count(<span class="org-keyword">this</span>)) {
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"WriteBatch has wrong count"</span>);
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline202" class="outline-4">
<h4 id="orgheadline202"><span class="section-number-4">10.6.2</span> MemTable</h4>
<div class="outline-text-4" id="text-10-6-2">
<p>
db/memtable.cc MemTable应该算是leveldb里面的table一种.只不过所有的内容都是存放在内存里面的。我们首先看看字段和数据结构.
</p>

<p>
(#note: 阅读MemTable必须和WriteBatch的数据结构分开，这里非常容易弄混。WriteBatch是一个连续字节流的表示，是将所有的请求
序列化称为连续的字节流，而MemTable是将每一对kv做成一个连续字节流放入SkipList里面去.如果不分清楚的话这里非常容易搞混).
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline198"></a>MemTable<br  /><div class="outline-text-5" id="text-10-6-2-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">MemTable</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">MemTables are reference counted.  The initial reference count</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">is zero and the caller must call Ref() at least once.</span>
  <span class="org-keyword">explicit</span> <span class="org-function-name">MemTable</span>(<span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>&amp; <span class="org-variable-name">comparator</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Increase reference count.</span>
  <span class="org-type">void</span> <span class="org-function-name">Ref</span>() { ++refs_; } <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#22312;&#24341;&#29992;&#35745;&#25968;&#24182;&#19988;&#19968;&#24320;&#22987;==0.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Drop reference count.  Delete if no more references exist.</span>
  <span class="org-type">void</span> <span class="org-function-name">Unref</span>() {
    --refs_;
    assert(refs_ &gt;= 0);
    <span class="org-keyword">if</span> (refs_ &lt;= 0) {
      <span class="org-keyword">delete</span> <span class="org-keyword">this</span>;
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns an estimate of the number of bytes of data in use by this</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">data structure.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: external synchronization to prevent simultaneous</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">operations on the same MemTable.</span>
  <span class="org-type">size_t</span> <span class="org-function-name">ApproximateMemoryUsage</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;arena&#30340;MemoryUsage.&#22240;&#20026;&#36825;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23384;&#37117;&#26159;&#20174;arena&#37324;&#38754;&#20998;&#37197;&#30340;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return an iterator that yields the contents of the memtable.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The caller must ensure that the underlying MemTable remains live</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">while the returned iterator is live.  The keys returned by this</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">iterator are internal keys encoded by AppendInternalKey in the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">db/format.{h,cc} module.</span>
  Iterator* NewIterator(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20135;&#29983;&#26032;&#30340;&#36845;&#20195;&#22120;.&#25509;&#19979;&#26469;&#25105;&#20204;&#20250;&#30475;&#30475;&#36845;&#20195;&#22120;&#26159;&#22914;&#20309;&#23454;&#29616;&#30340;&#12290;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add an entry into memtable that maps key to value at the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">specified sequence number and with the specified type.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Typically value will be empty if type==kTypeDeletion.</span>
  <span class="org-type">void</span> <span class="org-function-name">Add</span>(<span class="org-type">SequenceNumber</span> <span class="org-variable-name">seq</span>, <span class="org-type">ValueType</span> <span class="org-variable-name">type</span>,
           <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>,
           <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">If memtable contains a value for key, store it in *value and return true.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If memtable contains a deletion for key, store a NotFound() error</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">in *status and return true.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Else, return false.</span>
  <span class="org-type">bool</span> <span class="org-function-name">Get</span>(<span class="org-keyword">const</span> <span class="org-type">LookupKey</span>&amp; <span class="org-variable-name">key</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>, <span class="org-type">Status</span>* <span class="org-variable-name">s</span>);

 <span class="org-keyword">private</span>:
  ~<span class="org-function-name">MemTable</span>();  <span class="org-comment-delimiter">// </span><span class="org-comment">Private since only Unref() should be used to delete it</span>

  <span class="org-keyword">struct</span> <span class="org-type">KeyComparator</span> {
    <span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span> <span class="org-variable-name">comparator</span>;
    <span class="org-keyword">explicit</span> <span class="org-function-name">KeyComparator</span>(<span class="org-keyword">const</span> <span class="org-type">InternalKeyComparator</span>&amp; <span class="org-variable-name">c</span>) : comparator(c) { }
    <span class="org-type">int</span> <span class="org-keyword">operator</span><span class="org-function-name">()</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">b</span>) <span class="org-keyword">const</span>;
  };
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">MemTableIterator</span>;
  <span class="org-keyword">friend</span> <span class="org-keyword">class</span> <span class="org-type">MemTableBackwardIterator</span>;

  <span class="org-keyword">typedef</span> <span class="org-type">SkipList</span>&lt;<span class="org-keyword">const</span> <span class="org-type">char</span>*, <span class="org-type">KeyComparator</span>&gt; <span class="org-type">Table</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24213;&#23618;Table&#32467;&#26500;&#26159;&#20351;&#29992;SkipList&#23384;&#20648;&#30340;.</span>

  <span class="org-type">KeyComparator</span> <span class="org-variable-name">comparator_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">k&#27604;&#36739;&#22120;.</span>
  <span class="org-type">int</span> <span class="org-variable-name">refs_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">ref.</span>
  <span class="org-type">Arena</span> <span class="org-variable-name">arena_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20869;&#23384;&#20998;&#37197;</span>
  <span class="org-type">Table</span> <span class="org-variable-name">table_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">table</span>
};
</pre>
</div>
</div></li>

<li><a id="orgheadline199"></a>Compare<br  /><div class="outline-text-5" id="text-10-6-2-2">
<p>
这里KeyComparator的话因为考虑到key是length-prefixed的.底层使用InternalKeyComparator处理的就是
后面我们会看看InternalKeyComparator的实现.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">MemTable</span>::<span class="org-constant">KeyComparator</span>::<span class="org-keyword">operator</span><span class="org-function-name">()</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">aptr</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">bptr</span>)
    <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Internal keys are encoded as length-prefixed strings.</span>
  <span class="org-type">Slice</span> <span class="org-variable-name">a</span> = GetLengthPrefixedSlice(aptr);
  <span class="org-type">Slice</span> <span class="org-variable-name">b</span> = GetLengthPrefixedSlice(bptr);
  <span class="org-keyword">return</span> comparator.Compare(a, b); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#35843;&#29992;&#24213;&#23618;&#30340;</span>
  <span class="org-comment-delimiter">//</span><span class="org-comment">InternalKeyComparator.&#27880;&#24847;&#36825;&#37324;&#30340;aptr,bptr&#21253;&#25324;&#20102;&#21518;&#38754;&#38468;&#21152;&#30340;8&#23383;&#33410;&#20449;&#24687;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline200"></a>Add<br  /><div class="outline-text-5" id="text-10-6-2-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">MemTable</span>::<span class="org-function-name">Add</span>(<span class="org-type">SequenceNumber</span> <span class="org-variable-name">s</span>, <span class="org-type">ValueType</span> <span class="org-variable-name">type</span>,
                   <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>,
                   <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Format of an entry is concatenation of:</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">key_size     : varint32 of internal_key.size()</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">key bytes    : char[internal_key.size()]</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">value_size   : varint32 of value.size()</span>
  <span class="org-comment-delimiter">//  </span><span class="org-comment">value bytes  : char[value.size()]</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">key_size</span> = key.size();
  <span class="org-type">size_t</span> <span class="org-variable-name">val_size</span> = value.size();
  <span class="org-type">size_t</span> <span class="org-variable-name">internal_key_size</span> = key_size + 8; <span class="org-comment-delimiter">// </span><span class="org-comment">internal key size +8.</span>
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">encoded_len</span> =
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#30340;key size&#21253;&#25324;&#20102;8&#23383;&#33410;&#30340;&#38468;&#21152;&#20449;&#24687;.</span>
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  <span class="org-type">char</span>* <span class="org-variable-name">buf</span> = arena_.Allocate(encoded_len);
  <span class="org-type">char</span>* <span class="org-variable-name">p</span> = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s &lt;&lt; 8) | type); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#23601;&#26159;8&#20010;&#23383;&#33410;&#20195;&#34920;&#30340;&#21547;&#20041;.(seq &lt;&lt; 8) | type.</span>
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23558;&#36825;&#20010;key&#25554;&#20837;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline201"></a>Get<br  /><div class="outline-text-5" id="text-10-6-2-4">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#20351;&#29992;&#36845;&#20195;&#22120;&#26597;&#25214;&#23545;&#24212;&#30340;&#20869;&#23481;.&#26684;&#24335;&#30340;&#35805;&#21487;&#20197;&#21442;&#32771;Add&#30340;&#37324;&#38754;&#30340;&#23454;&#29616;</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">key_size + key_data + (seq &lt;&lt; 8) | type(8 bytes) + val_size + val_data.</span>
<span class="org-type">bool</span> <span class="org-constant">MemTable</span>::<span class="org-function-name">Get</span>(<span class="org-keyword">const</span> <span class="org-type">LookupKey</span>&amp; <span class="org-variable-name">key</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">value</span>, <span class="org-type">Status</span>* <span class="org-variable-name">s</span>) {
  <span class="org-type">Slice</span> <span class="org-variable-name">memkey</span> = key.memtable_key();
  <span class="org-constant">Table</span>::Iterator <span class="org-type">iter</span>(&amp;<span class="org-variable-name">table_</span>);
  iter.Seek(memkey.data());
  <span class="org-keyword">if</span> (iter.Valid()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">entry format is:</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">klength  varint32</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">userkey  char[klength]</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">tag      uint64</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">vlength  varint32</span>
    <span class="org-comment-delimiter">//    </span><span class="org-comment">value    char[vlength]</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Check that it belongs to same user key.  We do not check the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">sequence number since the Seek() call above should have skipped</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">all entries with overly large sequence numbers.</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">entry</span> = iter.key();
    <span class="org-type">uint32_t</span> <span class="org-variable-name">key_length</span>;
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">key_ptr</span> = GetVarint32Ptr(entry, entry+5, &amp;key_length);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#20351;&#29992;&#24213;&#23618;&#30340;comparator&#26469;&#36827;&#34892;&#27604;&#36739;.</span>
    <span class="org-keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Correct user key</span>
      <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">tag</span> = DecodeFixed64(key_ptr + key_length - 8);
      <span class="org-keyword">switch</span> (<span class="org-keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; 0xff)) {
        <span class="org-keyword">case</span> kTypeValue: {
          <span class="org-type">Slice</span> <span class="org-variable-name">v</span> = GetLengthPrefixedSlice(key_ptr + key_length);
          value-&gt;assign(v.data(), v.size());
          <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }
        <span class="org-keyword">case</span> kTypeDeletion:
          *s = <span class="org-constant">Status</span>::NotFound(Slice());
          <span class="org-keyword">return</span> <span class="org-constant">true</span>;
      }
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline203" class="outline-4">
<h4 id="orgheadline203"><span class="section-number-4">10.6.3</span> MemTableInserter</h4>
<div class="outline-text-4" id="text-10-6-3">
<p>
db/write_batch.cc MemTableInserter作为WriteBatch::Handler实现,基本上可以认为是操作MemTable的代理类.
具体代码非常简单，实现部分可能需要看MemTable.这个后面会讲解
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">MemTableInserter</span> : <span class="org-keyword">public</span> <span class="org-constant">WriteBatch</span>::<span class="org-type">Handler</span> {
 <span class="org-keyword">public</span>:
  <span class="org-type">SequenceNumber</span> <span class="org-variable-name">sequence_</span>;
  <span class="org-type">MemTable</span>* <span class="org-variable-name">mem_</span>;

  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Put</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) {
    mem_-&gt;Add(sequence_, kTypeValue, key, value);
    sequence_++; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#36825;&#37324;sequence_&#22312;++.&#34429;&#28982;&#19981;&#22826;&#28165;&#26970;&#36825;&#37324;sequence&#26377;&#20160;&#20040;&#29992;&#36884;.</span>
  }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Delete</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
    mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }
};
</pre>
</div>
<p>
至于sequence的初始值，在WriteBatchInternal::InsertInto里面是WriteBatch本身的Sequence作为初始值的。
</p>
</div>
</div>

<div id="outline-container-orgheadline204" class="outline-4">
<h4 id="orgheadline204"><span class="section-number-4">10.6.4</span> MemtableIterator</h4>
<div class="outline-text-4" id="text-10-6-4">
<p>
db/memtable.cc MemtableIterator实现非常简单，就是之前Table::Iterator的封装.后面我们会着重看看SkipList的实现.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-type">SkipList</span>&lt;<span class="org-keyword">const</span> <span class="org-type">char</span>*, <span class="org-variable-name">KeyComparator</span>&gt; <span class="org-type">Table</span>;
<span class="org-keyword">class</span> <span class="org-type">MemTableIterator</span>: <span class="org-keyword">public</span> <span class="org-type">Iterator</span> {
 <span class="org-keyword">public</span>:
  <span class="org-keyword">explicit</span> <span class="org-function-name">MemTableIterator</span>(<span class="org-constant">MemTable</span>::<span class="org-type">Table</span>* <span class="org-variable-name">table</span>) : iter_(table) { }

  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">Valid</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> iter_.Valid(); }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">k</span>) { iter_.Seek(EncodeKey(&amp;tmp_, k)); }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToFirst</span>() { iter_.SeekToFirst(); }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToLast</span>() { iter_.SeekToLast(); }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Next</span>() { iter_.Next(); }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Prev</span>() { iter_.Prev(); }
  <span class="org-keyword">virtual</span> <span class="org-type">Slice</span> <span class="org-function-name">key</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> GetLengthPrefixedSlice(iter_.key()); }
  <span class="org-keyword">virtual</span> <span class="org-type">Slice</span> <span class="org-function-name">value</span>() <span class="org-keyword">const</span> {
    <span class="org-type">Slice</span> <span class="org-variable-name">key_slice</span> = GetLengthPrefixedSlice(iter_.key());
    <span class="org-keyword">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }

  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">status</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK(); }

 <span class="org-keyword">private</span>:
  <span class="org-constant">MemTable</span>::<span class="org-constant">Table</span>::<span class="org-type">Iterator</span> <span class="org-variable-name">iter_</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">tmp_</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">For passing to EncodeKey</span>
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline219" class="outline-3">
<h3 id="orgheadline219"><span class="section-number-3">10.7</span> Log</h3>
<div class="outline-text-3" id="text-10-7">
</div><div id="outline-container-orgheadline206" class="outline-4">
<h4 id="orgheadline206"><span class="section-number-4">10.7.1</span> LogFormat</h4>
<div class="outline-text-4" id="text-10-7-1">
<p>
db/log_format.h 里面规定的是db log格式上面的一些常量和信息.内容非常少，但是可以给予我们一点启发
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">enum</span> <span class="org-type">RecordType</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">record&#31867;&#22411;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Zero is reserved for preallocated files</span>
  <span class="org-variable-name">kZeroType</span> = 0,

  <span class="org-variable-name">kFullType</span> = 1,

  <span class="org-comment-delimiter">// </span><span class="org-comment">For fragments</span>
  <span class="org-variable-name">kFirstType</span> = 2,
  <span class="org-variable-name">kMiddleType</span> = 3,
  <span class="org-variable-name">kLastType</span> = 4
};
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kMaxRecordType</span> = kLastType;

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kBlockSize</span> = 32768; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#20010;block&#22823;&#23567;.</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Header is checksum (4 bytes), type (1 byte), length (2 bytes).</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;EmitPhysicalRecord&#21487;&#20197;&#30475;&#21040;&#65292;&#23454;&#38469;&#23433;&#25490;&#26159;checksum,length,type.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kHeaderSize</span> = 4 + 1 + 2; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#20010;block&#30340;header&#26159;&#24590;&#20040;&#23433;&#25490;&#30340;.</span>
</pre>
</div>

<p>
下面LogWriter以及LogReader里面给出这个格式的实现，代码里面可以看出具体的实现。
但是幸运的是在level的文档里面也有这个format的说明。
</p>
<pre class="example">
The log file contents are a sequence of 32KB blocks.  The only
exception is that the tail of the file may contain a partial block.

Each block consists of a sequence of records:
   block := record* trailer?
   record :=
checksum: uint32// crc32c of type and data[]
length: uint16
type: uint8// One of FULL, FIRST, MIDDLE, LAST
data: uint8[length]

A record never starts within the last six bytes of a block (since it
won't fit).  Any leftover bytes here form the trailer, which must
consist entirely of zero bytes and must be skipped by readers.

Aside: if exactly seven bytes are left in the current block, and a new
non-zero length record is added, the writer must emit a FIRST record
(which contains zero bytes of user data) to fill up the trailing seven
bytes of the block and then emit all of the user data in subsequent
blocks.

More types may be added in the future.  Some Readers may skip record
types they do not understand, others may report that some data was
skipped.

FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4

The FULL record contains the contents of an entire user record.

FIRST, MIDDLE, LAST are types used for user records that have been
split into multiple fragments (typically because of block boundaries).
FIRST is the type of the first fragment of a user record, LAST is the
type of the last fragment of a user record, and MID is the type of all
interior fragments of a user record.

Example: consider a sequence of user records:
   A: length 1000
   B: length 97270
   C: length 8000
A will be stored as a FULL record in the first block.

B will be split into three fragments: first fragment occupies the rest
of the first block, second fragment occupies the entirety of the
second block, and the third fragment occupies a prefix of the third
block.  This will leave six bytes free in the third block, which will
be left empty as the trailer.

C will be stored as a FULL record in the fourth block.

===================

Some benefits over the recordio format:

(1) We do not need any heuristics for resyncing - just go to next
block boundary and scan.  If there is a corruption, skip to the next
block.  As a side-benefit, we do not get confused when part of the
contents of one log file are embedded as a record inside another log
file.

(2) Splitting at approximate boundaries (e.g., for mapreduce) is
simple: find the next block boundary and skip records until we
hit a FULL or FIRST record.

(3) We do not need extra buffering for large records.

Some downsides compared to recordio format:

(1) No packing of tiny records.  This could be fixed by adding a new
record type, so it is a shortcoming of the current implementation,
not necessarily the format.

(2) No compression.  Again, this could be fixed by adding new record types.
</pre>
</div>
</div>

<div id="outline-container-orgheadline210" class="outline-4">
<h4 id="orgheadline210"><span class="section-number-4">10.7.2</span> LogWriter</h4>
<div class="outline-text-4" id="text-10-7-2">
<p>
db/log_writer.h db log writer.这里我们需要结合前面的LogFormatter一起看看.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Writer</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a writer that will append data to "*dest".</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"*dest" must be initially empty.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"*dest" must remain live while this Writer is in use.</span>
  <span class="org-keyword">explicit</span> <span class="org-function-name">Writer</span>(<span class="org-type">WritableFile</span>* <span class="org-variable-name">dest</span>);
  ~<span class="org-function-name">Writer</span>();

  <span class="org-type">Status</span> <span class="org-function-name">AddRecord</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">slice</span>);

 <span class="org-keyword">private</span>:
  <span class="org-type">WritableFile</span>* <span class="org-variable-name">dest_</span>;
  <span class="org-type">int</span> <span class="org-variable-name">block_offset_</span>;       <span class="org-comment-delimiter">// </span><span class="org-comment">Current offset in block.&#22312;&#24403;&#21069;block&#30340;&#20301;&#32622;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">crc32c values for all supported record types.  These are</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">pre-computed to reduce the overhead of computing the crc of the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">record type stored in the header.</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">type_crc_</span>[kMaxRecordType + 1]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21508;&#31181;&#31867;&#22411;&#30340;crc32c.</span>

  <span class="org-type">Status</span> <span class="org-function-name">EmitPhysicalRecord</span>(<span class="org-type">RecordType</span> <span class="org-variable-name">type</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ptr</span>, <span class="org-type">size_t</span> <span class="org-variable-name">length</span>);
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline207"></a>Writer<br  /><div class="outline-text-5" id="text-10-7-2-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">Writer</span>::<span class="org-function-name">Writer</span>(<span class="org-type">WritableFile</span>* <span class="org-variable-name">dest</span>)
    : dest_(dest),
      block_offset_(0) {
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt;= kMaxRecordType; i++) {
    <span class="org-type">char</span> <span class="org-variable-name">t</span> = <span class="org-keyword">static_cast</span>&lt;<span class="org-type">char</span>&gt;(i); <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;&#31867;&#22411;&#35745;&#31639;&#30340;CRC32C.</span>
    type_crc_[i] = <span class="org-constant">crc32c</span>::Value(&amp;t, 1);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline208"></a>AddRecord<br  /><div class="outline-text-5" id="text-10-7-2-2">
<p>
我们这里看看每条Log到底是怎么写入的.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">Writer</span>::<span class="org-function-name">AddRecord</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">slice</span>) {
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ptr</span> = slice.data();
  <span class="org-type">size_t</span> <span class="org-variable-name">left</span> = slice.size();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Fragment the record if necessary and emit it.  Note that if slice</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">is empty, we still want to iterate once to emit a single</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">zero-length record</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;Slice&#21097;&#20313;&#38271;&#24230;&#20026;0&#30340;&#35805;&#37027;&#20040;&#20381;&#28982;&#38656;&#35201;&#36755;&#20986;&#19968;&#26465;&#35760;&#24405;.</span>
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">begin</span> = <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#20026;&#22836;&#37096;.</span>
  <span class="org-keyword">do</span> {
    <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">leftover</span> = kBlockSize - block_offset_; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;block&#21097;&#20313;&#22810;&#23569;&#20869;&#23481;.</span>
    assert(leftover &gt;= 0);
    <span class="org-keyword">if</span> (leftover &lt; kHeaderSize) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36275;&#20197;&#23384;&#25918;&#19979;Header.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Switch to a new block</span>
      <span class="org-keyword">if</span> (leftover &gt; 0) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Fill the trailer (literal below relies on kHeaderSize being 7)</span>
        assert(kHeaderSize == 7);
        dest_-&gt;Append(Slice(<span class="org-string">"\x00\x00\x00\x00\x00\x00"</span>, leftover)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21097;&#20313;&#30340;&#37096;&#20998;&#22635;&#20805;0x00.</span>
      }
      block_offset_ = 0; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29616;&#22312;blcok_offset==0&#37325;&#26032;&#24320;&#36767;&#20102;&#19968;&#22359;&#20869;&#23481;.</span>
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Invariant: we never leave &lt; kHeaderSize bytes in a block.</span>
    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= 0);

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#21097;&#20313;&#22810;&#23569;&#20869;&#23481;.</span>
    <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">avail</span> = kBlockSize - block_offset_ - kHeaderSize;
    <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">fragment_length</span> = (left &lt; avail) ? left : avail;

    <span class="org-type">RecordType</span> <span class="org-variable-name">type</span>;
    <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-variable-name">end</span> = (left == fragment_length); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26159;&#21542;&#20026;&#35760;&#24405;&#30340;&#23614;&#37096;.</span>
    <span class="org-keyword">if</span> (begin &amp;&amp; end) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23436;&#20840;&#35760;&#24405;&#37027;&#20040;FullType.</span>
      type = kFullType;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (begin) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21482;&#26159;&#24320;&#22836;,FirstType.</span>
      type = kFirstType;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (end) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;&#24320;&#22836;&#20294;&#26159;&#32467;&#23614;LastType.</span>
      type = kLastType;
    } <span class="org-keyword">else</span> {
      type = kMiddleType; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;MiddleType.</span>
    }

    s = EmitPhysicalRecord(type, ptr, fragment_length); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20010;&#37096;&#20998;&#36755;&#20986;.</span>
    ptr += fragment_length;
    left -= fragment_length;
    begin = <span class="org-constant">false</span>;
  } <span class="org-keyword">while</span> (s.ok() &amp;&amp; left &gt; 0);
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline209"></a>EmitPhysicalRecord<br  /><div class="outline-text-5" id="text-10-7-2-3">
<p>
我们在上面AddRecord里面看到了调用EmitPhysicalRecord.我们这里看看实现.参考在LogFormatter里面的注释.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">Writer</span>::<span class="org-function-name">EmitPhysicalRecord</span>(<span class="org-type">RecordType</span> <span class="org-variable-name">t</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">ptr</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>) {
  assert(n &lt;= 0xffff);  <span class="org-comment-delimiter">// </span><span class="org-comment">Must fit in two bytes</span>
  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Format the header</span>
  <span class="org-type">char</span> <span class="org-variable-name">buf</span>[kHeaderSize];
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#23384;&#22312;&#24046;&#21035;&#65292;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#34920;&#31034;type.</span>
  buf[4] = <span class="org-keyword">static_cast</span>&lt;<span class="org-type">char</span>&gt;(n &amp; 0xff); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20302;&#20301;.</span>
  buf[5] = <span class="org-keyword">static_cast</span>&lt;<span class="org-type">char</span>&gt;(n &gt;&gt; 8); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39640;&#20301;.&#36825;&#26679;&#21487;&#20197;&#23567;&#31471;&#26041;&#24335;&#35835;&#21462;.</span>
  buf[6] = <span class="org-keyword">static_cast</span>&lt;<span class="org-type">char</span>&gt;(t);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Compute the crc of the record type and the payload.</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">crc</span> = <span class="org-constant">crc32c</span>::Extend(type_crc_[t], ptr, n); <span class="org-comment-delimiter">// </span><span class="org-comment">&#38024;&#23545;ptr&#36827;&#34892;CRC32&#21152;&#23494;.</span>
  crc = <span class="org-constant">crc32c</span>::Mask(crc);                 <span class="org-comment-delimiter">// </span><span class="org-comment">Adjust for storage</span>
  EncodeFixed32(buf, crc); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23384;&#25918;&#22312;header&#37096;&#20998;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Write the header and the payload</span>
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = dest_-&gt;Append(Slice(buf, kHeaderSize)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#20889;&#20837;Header&#37096;&#20998;.</span>
  <span class="org-keyword">if</span> (s.ok()) {
    s = dest_-&gt;Append(Slice(ptr, n)); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#36861;&#21152;&#25968;&#25454;&#37096;&#20998;.</span>
    <span class="org-keyword">if</span> (s.ok()) {
      s = dest_-&gt;Flush();
    }
  }
  block_offset_ += kHeaderSize + n;
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline218" class="outline-4">
<h4 id="orgheadline218"><span class="section-number-4">10.7.3</span> LogReader</h4>
<div class="outline-text-4" id="text-10-7-3">
<p>
db/log_reader.h db log reader.这里我们需要结合前面的LogReader以及LogFormatter一起看看.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Reader</span> {
 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Interface for reporting errors.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27719;&#25253;&#38169;&#35823;&#25509;&#21475;.</span>
  <span class="org-keyword">class</span> <span class="org-type">Reporter</span> {
   <span class="org-keyword">public</span>:
    <span class="org-keyword">virtual</span> ~<span class="org-function-name">Reporter</span>();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Some corruption was detected.  "size" is the approximate number</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">of bytes dropped due to the corruption.</span>
    <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Corruption</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>, <span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">status</span>) = 0;
  };

  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a reader that will return log records from "*file".</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"*file" must remain live while this Reader is in use.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If "reporter" is non-NULL, it is notified whenever some data is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">dropped due to a detected corruption.  "*reporter" must remain</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">live while this Reader is in use.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If "checksum" is true, verify checksums if available.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The Reader will start reading at the first record located at physical</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">position &gt;= initial_offset within the file.</span>
  <span class="org-function-name">Reader</span>(<span class="org-type">SequentialFile</span>* <span class="org-variable-name">file</span>, <span class="org-type">Reporter</span>* <span class="org-variable-name">reporter</span>, <span class="org-type">bool</span> <span class="org-variable-name">checksum</span>,
         <span class="org-type">uint64_t</span> <span class="org-variable-name">initial_offset</span>);

  ~<span class="org-function-name">Reader</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Read the next record into *record.  Returns true if read</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">successfully, false if we hit end of the input.  May use</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"*scratch" as temporary storage.  The contents filled in *record</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">will only be valid until the next mutating operation on this</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">reader or the next mutation to *scratch.</span>
  <span class="org-type">bool</span> <span class="org-function-name">ReadRecord</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">record</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">scratch</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns the physical offset of the last record returned by ReadRecord.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Undefined before the first call to ReadRecord.</span>
  <span class="org-type">uint64_t</span> <span class="org-function-name">LastRecordOffset</span>();

 <span class="org-keyword">private</span>:
  <span class="org-type">SequentialFile</span>* <span class="org-keyword">const</span> <span class="org-variable-name">file_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#39034;&#24207;&#35835;&#21462;&#25991;&#20214;&#23545;&#35937;.</span>
  <span class="org-type">Reporter</span>* <span class="org-keyword">const</span> <span class="org-variable-name">reporter_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25253;&#21578;&#38169;&#35823;&#23545;&#35937;.</span>
  <span class="org-type">bool</span> <span class="org-keyword">const</span> <span class="org-variable-name">checksum_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26816;&#26597;CRC32C.</span>
  <span class="org-type">char</span>* <span class="org-keyword">const</span> <span class="org-variable-name">backing_store_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">block buffer.</span>
  <span class="org-type">Slice</span> <span class="org-variable-name">buffer_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">record buffer.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#34920;&#31034;&#19978;&#27425;&#35835;&#21462;block&#26159;&#21542;&#21040;&#36798;&#23614;&#37096;.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">eof_</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Last Read() indicated EOF by returning &lt; kBlockSize</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Offset of the last record returned by ReadRecord.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">last_record_offset_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19978;&#27425;ReadRecord&#23436;&#25104;&#20043;&#21518;&#30340;&#25991;&#20214;&#20559;&#31227;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Offset of the first location past the end of buffer_.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">end_of_buffer_offset_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#21040;buffer_&#20043;&#21518;&#39034;&#24207;&#25991;&#20214;&#20559;&#31227;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Offset at which to start looking for the first record to return</span>
  uint64_t <span class="org-keyword">const</span> <span class="org-variable-name">initial_offset_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;&#35835;&#21462;&#30340;offset.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Extend record types with the following special values</span>
  <span class="org-keyword">enum</span> {
    <span class="org-variable-name">kEof</span> = kMaxRecordType + 1,
    <span class="org-comment-delimiter">// </span><span class="org-comment">Returned whenever we find an invalid physical record.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Currently there are three situations in which this happens:</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">* The record has an invalid CRC (ReadPhysicalRecord reports a drop)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">* The record is a 0-length record (No drop is reported)</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">* The record is below constructor's initial_offset (No drop is reported)</span>
    <span class="org-variable-name">kBadRecord</span> = kMaxRecordType + 2
  };

  <span class="org-comment-delimiter">// </span><span class="org-comment">Skips all blocks that are completely before "initial_offset_".</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true on success. Handles reporting.</span>
  <span class="org-type">bool</span> <span class="org-function-name">SkipToInitialBlock</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return type, or one of the preceding special values</span>
  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-function-name">ReadPhysicalRecord</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">result</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Reports dropped bytes to the reporter.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">buffer_ must be updated to remove the dropped bytes prior to invocation.</span>
  <span class="org-type">void</span> <span class="org-function-name">ReportCorruption</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">reason</span>);
  <span class="org-type">void</span> <span class="org-function-name">ReportDrop</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>, <span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">reason</span>);
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline211"></a>Reader<br  /><div class="outline-text-5" id="text-10-7-3-1">
<p>
构造函数非常简单，注意这里开辟的backing_store_，可以猜想到这个backing_store是读取block内容临时开辟.
对于这些字段的含义可能第一眼看上去不太明白，这个分析代码应该可以看到每个字段的含义。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">Reader</span>::<span class="org-function-name">Reader</span>(<span class="org-type">SequentialFile</span>* <span class="org-variable-name">file</span>, <span class="org-type">Reporter</span>* <span class="org-variable-name">reporter</span>, <span class="org-type">bool</span> <span class="org-variable-name">checksum</span>,
               <span class="org-type">uint64_t</span> <span class="org-variable-name">initial_offset</span>)
    : file_(file),
      reporter_(reporter),
      checksum_(checksum),
      backing_store_(<span class="org-keyword">new</span> <span class="org-type">char</span>[kBlockSize]),
      buffer_(),
      eof_(<span class="org-constant">false</span>),
      last_record_offset_(0),
      end_of_buffer_offset_(0),
      initial_offset_(initial_offset) {
}
</pre>
</div>
</div></li>

<li><a id="orgheadline212"></a>ReadPhysicalRecord<br  /><div class="outline-text-5" id="text-10-7-3-2">
<p>
从文件里面读取一个物理块大小出来kBlockSize.并且解析内容存放在bakcing_store_里面，同时返回type.
这里很多细节都没有仔细看,只是理解大致的意思.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-constant">Reader</span>::<span class="org-function-name">ReadPhysicalRecord</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">result</span>) {
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    <span class="org-keyword">if</span> (buffer_.size() &lt; kHeaderSize) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20043;&#21069;&#35835;&#21462;&#30340;&#20869;&#23481;&#19981;&#22815;kHeaderSize&#22823;&#23567;&#30340;&#35805;.</span>
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>eof_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19978;&#27425;&#35835;&#21462;&#27809;&#26377;&#21040;&#26411;&#23614;&#30340;&#35805;&#65292;&#37027;&#20040;&#35748;&#20026;&#19978;&#27425;&#35835;&#21462;&#26080;&#25928;&#65292;&#30452;&#25509;&#24573;&#30053;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Last read was a full read, so this is a trailer to skip</span>
        buffer_.clear();
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#24573;&#30053;&#20043;&#21518;&#37325;&#26032;&#35835;&#21462;&#19968;&#22359;.</span>
        <span class="org-type">Status</span> <span class="org-variable-name">status</span> = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#20462;&#27491;&#35835;&#21462;&#20559;&#31227;.&#24403;&#21069;&#35835;&#21462;&#20559;&#31227;.</span>
        end_of_buffer_offset_ += buffer_.size();
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>status.ok()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#35835;&#21462;&#22833;&#36133;&#30340;&#35805;.</span>
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = <span class="org-constant">true</span>;
          <span class="org-keyword">return</span> kEof;
        } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (buffer_.size() &lt; kBlockSize) {
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#25104;&#21151;&#20294;&#26159;&#24050;&#32463;&#36798;&#21040;&#32467;&#23614;&#20102;.eof_=true</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#37325;&#26032;&#21028;&#26029;&#35835;&#21462;&#30340;&#26159;&#21542;&#20026;&#27491;&#30830;&#30340;&#35760;&#24405;.</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#27491;&#30830;&#35835;&#21462;&#30340;&#35805;(&lt;kHeaderSize).&#20250;&#36827;&#20837;&#19979;&#38754;&#37027;&#20010;&#38169;&#35823;&#36923;&#36753;.</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#36827;&#20837;&#27491;&#24120;&#36923;&#36753;.</span>
          eof_ = <span class="org-constant">true</span>;
        }
        <span class="org-keyword">continue</span>;
      } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (buffer_.size() == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26159;&#30830;&#23454;&#27809;&#26377;&#20219;&#20309;&#35760;&#24405;&#23384;&#22312;&#20102;.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">End of file</span>
        <span class="org-keyword">return</span> kEof;
      } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25991;&#20214;&#26411;&#23614;&#35835;&#21462;&#22833;&#36133;(&#25130;&#26029;)</span>
        <span class="org-type">size_t</span> <span class="org-variable-name">drop_size</span> = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, <span class="org-string">"truncated record at end of file"</span>);
        <span class="org-keyword">return</span> kEof;
      }
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20551;&#35774;&#21040;&#36825;&#37324;&#30340;&#35805;&#25105;&#20204;&#37117;&#24050;&#32463;&#35835;&#21462;&#20102;&#19968;&#20010;&#23436;&#25972;&#30340;block&#20102;.&#25105;&#20204;&#39318;&#20808;&#35299;&#26512;&#22836;&#37096;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Parse the header</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">header</span> = buffer_.data();
    <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">a</span> = <span class="org-keyword">static_cast</span>&lt;uint32_t&gt;(header[4]) &amp; 0xff;
    <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">b</span> = <span class="org-keyword">static_cast</span>&lt;uint32_t&gt;(header[5]) &amp; 0xff;
    <span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">type</span> = header[6]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#25454;&#31867;&#22411;&#21644;&#38271;&#24230;.</span>
    <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">length</span> = a | (b &lt;&lt; 8);
    <span class="org-keyword">if</span> (kHeaderSize + length &gt; buffer_.size()) {
      <span class="org-type">size_t</span> <span class="org-variable-name">drop_size</span> = buffer_.size();
      buffer_.clear();
      ReportCorruption(drop_size, <span class="org-string">"bad record length"</span>);
      <span class="org-keyword">return</span> kBadRecord;
    }

    <span class="org-keyword">if</span> (type == kZeroType &amp;&amp; length == 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Skip zero length record without reporting any drops since</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">such records are produced by the mmap based writing code in</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">env_posix.cc that preallocates file regions.</span>
      buffer_.clear();
      <span class="org-keyword">return</span> kBadRecord;
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26816;&#26597;crc&#26657;&#39564;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Check crc</span>
    <span class="org-keyword">if</span> (checksum_) {
      <span class="org-type">uint32_t</span> <span class="org-variable-name">expected_crc</span> = <span class="org-constant">crc32c</span>::Unmask(DecodeFixed32(header));
      <span class="org-type">uint32_t</span> <span class="org-variable-name">actual_crc</span> = <span class="org-constant">crc32c</span>::Value(header + 6, 1 + length); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20570;crc32c&#38656;&#35201;&#21253;&#21547;type&#23383;&#27573;.</span>
      <span class="org-keyword">if</span> (actual_crc != expected_crc) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Drop the rest of the buffer since "length" itself may have</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">been corrupted and if we trust it, we could find some</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">fragment of a real log record that just happens to look</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">like a valid log record.</span>
        <span class="org-type">size_t</span> <span class="org-variable-name">drop_size</span> = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, <span class="org-string">"checksum mismatch"</span>);
        <span class="org-keyword">return</span> kBadRecord;
      }
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;buffer_&#36825;&#37324;&#20570;&#19968;&#20010;&#26657;&#39564;.</span>
    buffer_.remove_prefix(kHeaderSize + length);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Skip physical record that started before initial_offset_</span>
    <span class="org-keyword">if</span> (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length &lt;
        initial_offset_) {
      result-&gt;clear();
      <span class="org-keyword">return</span> kBadRecord;
    }

    *result = Slice(header + kHeaderSize, length);
    <span class="org-keyword">return</span> type;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline213"></a>ReadRecord<br  /><div class="outline-text-5" id="text-10-7-3-3">
<p>
ReadRecord读取的是一条逻辑记录.底层调用ReadPhysicalRecord将多条物理记录结合起来.实话说里面具体逻辑没有看懂，
但是大致意思算是明白了。对于FullType来说的话record里面使用backing_store内存，而对于First/Middle/Last来说的话
里面使用的是scratch分配的内存.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">Reader</span>::<span class="org-function-name">ReadRecord</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">record</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">scratch</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36824;&#27809;&#26377;&#36339;&#36807;initial offset&#30340;&#35805;</span>
  <span class="org-keyword">if</span> (last_record_offset_ &lt; initial_offset_) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>SkipToInitialBlock()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#20989;&#25968;&#21518;&#38754;&#20250;&#20998;&#26512;.</span>
      <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }
  }

  scratch-&gt;clear(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;scratch&#20197;&#21450;record&#28165;&#31354;</span>
  record-&gt;clear(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#29468;&#38169;&#30340;&#35805;&#65292;&#37027;&#20040;record&#37324;&#38754;&#31649;&#29702;&#30340;&#26159;scratch&#30340;&#20869;&#23384;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#26159;&#20043;&#21518;&#20250;&#21457;&#29616;&#20854;&#23454;record&#37324;&#38754;&#20063;&#21487;&#33021;&#21547;&#26377;backing_store&#30340;&#20869;&#23481;.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">in_fragmented_record</span> = <span class="org-constant">false</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Record offset of the logical record that we're reading</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">0 is a dummy value to make compilers happy</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">prospective_record_offset</span> = 0;

  <span class="org-type">Slice</span> <span class="org-variable-name">fragment</span>;
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    <span class="org-type">uint64_t</span> <span class="org-variable-name">physical_record_offset</span> = end_of_buffer_offset_ - buffer_.size();
    <span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">record_type</span> = ReadPhysicalRecord(&amp;fragment); <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#19968;&#20010;block.</span>
    <span class="org-keyword">switch</span> (record_type) {
      <span class="org-keyword">case</span> kFullType:
        <span class="org-keyword">if</span> (in_fragmented_record) {
          <span class="org-comment-delimiter">// </span><span class="org-comment">Handle bug in earlier versions of log::Writer where</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">it could emit an empty kFirstType record at the tail end</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">of a block followed by a kFullType or kFirstType record</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">at the beginning of the next block.</span>
          <span class="org-keyword">if</span> (scratch-&gt;empty()) {
            in_fragmented_record = <span class="org-constant">false</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24573;&#30053;&#36825;&#31181;&#38169;&#35823;.&#21487;&#33021;&#26159;&#32771;&#34385;&#20860;&#23481;.</span>
          } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;&#21040;FullType&#20294;&#26159;&#21364;&#26377;fragmented&#30340;&#34920;&#31034;.</span>
            ReportCorruption(scratch-&gt;size(), <span class="org-string">"partial record without end(1)"</span>);
          }
        }
        prospective_record_offset = physical_record_offset;
        scratch-&gt;clear();
        *record = fragment; <span class="org-comment-delimiter">// </span><span class="org-comment">&#30452;&#25509;&#32473;record.&#36825;&#37324;record&#25345;&#26377;backing_store&#25968;&#25454;.</span>
        last_record_offset_ = prospective_record_offset;
        <span class="org-keyword">return</span> <span class="org-constant">true</span>;

      <span class="org-keyword">case</span> kFirstType:
        <span class="org-keyword">if</span> (in_fragmented_record) {
          <span class="org-comment-delimiter">// </span><span class="org-comment">Handle bug in earlier versions of log::Writer where</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">it could emit an empty kFirstType record at the tail end</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">of a block followed by a kFullType or kFirstType record</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">at the beginning of the next block.</span>
          <span class="org-keyword">if</span> (scratch-&gt;empty()) {
            in_fragmented_record = <span class="org-constant">false</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24573;&#30053;&#36825;&#31181;&#38169;&#35823;,&#21487;&#33021;&#26159;&#32771;&#34385;&#20860;&#23481;.</span>
          } <span class="org-keyword">else</span> {
            ReportCorruption(scratch-&gt;size(), <span class="org-string">"partial record without end(2)"</span>);
          }
        }
        prospective_record_offset = physical_record_offset;
        scratch-&gt;assign(fragment.data(), fragment.size());
        in_fragmented_record = <span class="org-constant">true</span>;
        <span class="org-keyword">break</span>;

      <span class="org-keyword">case</span> kMiddleType:
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>in_fragmented_record) {
          ReportCorruption(fragment.size(),
                           <span class="org-string">"missing start of fragmented record(1)"</span>);
        } <span class="org-keyword">else</span> {
          scratch-&gt;append(fragment.data(), fragment.size());
        }
        <span class="org-keyword">break</span>;

      <span class="org-keyword">case</span> kLastType:
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>in_fragmented_record) {
          ReportCorruption(fragment.size(),
                           <span class="org-string">"missing start of fragmented record(2)"</span>);
        } <span class="org-keyword">else</span> {
          scratch-&gt;append(fragment.data(), fragment.size());
          *record = Slice(*scratch);
          last_record_offset_ = prospective_record_offset;
          <span class="org-keyword">return</span> <span class="org-constant">true</span>;
        }
        <span class="org-keyword">break</span>;

      <span class="org-keyword">case</span> kEof:
        <span class="org-keyword">if</span> (in_fragmented_record) {
          ReportCorruption(scratch-&gt;size(), <span class="org-string">"partial record without end(3)"</span>);
          scratch-&gt;clear();
        }
        <span class="org-keyword">return</span> <span class="org-constant">false</span>;

      <span class="org-keyword">case</span> kBadRecord:
        <span class="org-keyword">if</span> (in_fragmented_record) {
          ReportCorruption(scratch-&gt;size(), <span class="org-string">"error in middle of record"</span>);
          in_fragmented_record = <span class="org-constant">false</span>;
          scratch-&gt;clear();
        }
        <span class="org-keyword">break</span>;

      <span class="org-keyword">default</span>: {
        <span class="org-type">char</span> <span class="org-variable-name">buf</span>[40];
        snprintf(buf, <span class="org-keyword">sizeof</span>(buf), <span class="org-string">"unknown record type %u"</span>, record_type);
        ReportCorruption(
            (fragment.size() + (in_fragmented_record ? scratch-&gt;size() : 0)),
            buf);
        in_fragmented_record = <span class="org-constant">false</span>;
        scratch-&gt;clear();
        <span class="org-keyword">break</span>;
      }
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline214"></a>SkipToInitialBlock<br  /><div class="outline-text-5" id="text-10-7-3-4">
<p>
跳过开头的部分.实际上只是跳过按照kBlockSize整数块部分。这个部分不需要用户主动调用.在ReadRecord里面调用.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-constant">Reader</span>::<span class="org-function-name">SkipToInitialBlock</span>() {
  <span class="org-type">size_t</span> <span class="org-variable-name">offset_in_block</span> = initial_offset_ % kBlockSize;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">block_start_location</span> = initial_offset_ - offset_in_block;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Don't search a block if we'd be in the trailer</span>
  <span class="org-keyword">if</span> (offset_in_block &gt; kBlockSize - 6) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#19981;&#22826;&#26126;&#30333;&#26159;&#20160;&#20040;&#24847;&#24605;.&#20026;&#20160;&#20040;&#26159;6.</span>
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }

  end_of_buffer_offset_ = block_start_location;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Skip to start of first block that can contain the initial record</span>
  <span class="org-keyword">if</span> (block_start_location &gt; 0) {
    <span class="org-type">Status</span> <span class="org-variable-name">skip_status</span> = file_-&gt;Skip(block_start_location);
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>skip_status.ok()) {
      ReportDrop(block_start_location, skip_status); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#38754;&#20250;&#20998;&#26512;.</span>
      <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }
  }

  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline215"></a>ReportDrop<br  /><div class="outline-text-5" id="text-10-7-3-5">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Reader</span>::<span class="org-function-name">ReportDrop</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>, <span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">reason</span>) {
  <span class="org-keyword">if</span> (reporter_ != <span class="org-constant">NULL</span> &amp;&amp;
      end_of_buffer_offset_ - buffer_.size() - bytes &gt;= initial_offset_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#21518;&#38754;&#36825;&#20010;&#26465;&#20214;&#27809;&#26377;&#30475;&#25026;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24212;&#35813;&#26159;&#21028;&#26029;&#22914;&#26524;&#36824;&#27809;&#26377;&#24320;&#22987;&#35835;&#30340;&#35805;&#37027;&#20040;&#19981;&#20250;&#25253;&#21578;&#38169;&#35823;.</span>
    reporter_-&gt;Corruption(bytes, reason);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline216"></a>ReportCorruption<br  /><div class="outline-text-5" id="text-10-7-3-6">
<p>
这个过程非常简单就是调用ReportDrop.然后使用Status::Corruption封装.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Reader</span>::<span class="org-function-name">ReportCorruption</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">reason</span>) {
  ReportDrop(bytes, <span class="org-constant">Status</span>::Corruption(reason));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline217"></a>LastRecordOffset<br  /><div class="outline-text-5" id="text-10-7-3-7">
<p>
上次调用ReadRecord之后的文件偏移是多少
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">uint64_t</span> <span class="org-constant">Reader</span>::<span class="org-function-name">LastRecordOffset</span>() {
  <span class="org-keyword">return</span> last_record_offset_;
}
</pre>
</div>
</div></li></ol>
</div>
</div>

<div id="outline-container-orgheadline298" class="outline-3">
<h3 id="orgheadline298"><span class="section-number-3">10.8</span> Table</h3>
<div class="outline-text-3" id="text-10-8">
</div><div id="outline-container-orgheadline220" class="outline-4">
<h4 id="orgheadline220"><span class="section-number-4">10.8.1</span> TableFormat</h4>
<div class="outline-text-4" id="text-10-8-1">
<p>
我们在分析后面的接口之前最好首先看看table文件的组织格式是怎么样的。这些table都是排好序的所以查询特别快。
对于这些table通常称为sstable(sorted string table).关于table格式在leveldb/doc/table_format.txt里面有说明.
本质上我们可认为sstable是一个二级索引文件.首先读取footer.得到metaindex block和index block位置.然后读取index block
或者是metaindex block(上面存在排序k进行二分查找)，然后读取data block(k排序然后进行二分查找).
</p>
<pre class="example">
File format
===========

  &lt;beginning_of_file&gt;
  [data block 1]
  [data block 2]
  ...
  [data block N]
  [meta block 1]
  ...
  [meta block K]
  [metaindex block]
  [index block]
  [Footer]        (fixed size; starts at file_size - sizeof(Footer))
  &lt;end_of_file&gt;

The file contains internal pointers.  Each such pointer is called
a BlockHandle and contains the following information:
offset:    varint64
size:    varint64

(1) The sequence of key/value pairs in the file are stored in sorted
order and partitioned into a sequence of data blocks.  These blocks
come one after another at the beginning of the file.  Each data block
is formatted according to the code in block_builder.cc, and then
optionally compressed.

(2) After the data blocks we store a bunch of meta blocks.  The
supported meta block types are described below.  More meta block types
may be added in the future.  Each meta block is again formatted using
block_builder.cc and then optionally compressed.

(3) A "metaindex" block.  It contains one entry for every other meta
block where the key is the name of the meta block and the value is a
BlockHandle pointing to that meta block.

(4) An "index" block.  This block contains one entry per data block,
where the key is a string &gt;= last key in that data block and before
the first key in the successive data block.  The value is the
BlockHandle for the data block.

(6) At the very end of the file is a fixed length footer that contains
the BlockHandle of the metaindex and index blocks as well as a magic number.
       metaindex_handle:       char[p];    // Block handle for metaindex
index_handle:       char[q];    // Block handle for index
padding:       char[40-p-q]; // 0 bytes to make fixed length
       // (40==2*BlockHandle::kMaxEncodedLength)
magic:       fixed64;    // == 0xdb4775248b80fb57

"stats" Meta Block
------------------

This meta block contains a bunch of stats.  The key is the name
of the statistic.  The value contains the statistic.
TODO(postrelease): record following stats.
  data size
  index size
  key size (uncompressed)
  value size (uncompressed)
  number of entries
  number of data blocks
</pre>
</div>
</div>

<div id="outline-container-orgheadline221" class="outline-4">
<h4 id="orgheadline221"><span class="section-number-4">10.8.2</span> BuildTable</h4>
<div class="outline-text-4" id="text-10-8-2">
<p>
db/builder.h BuildTable过程非常简单就是构造一个sstable.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-function-name">BuildTable</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>,
                  <span class="org-type">Env</span>* <span class="org-variable-name">env</span>,
                  <span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>,
                  <span class="org-type">TableCache</span>* <span class="org-variable-name">table_cache</span>,
                  <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span>,
                  <span class="org-type">FileMetaData</span>* <span class="org-variable-name">meta</span>) {
  <span class="org-type">Status</span> <span class="org-variable-name">s</span>;
  meta-&gt;file_size = 0;
  iter-&gt;SeekToFirst();

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">fname</span> = TableFileName(dbname, meta-&gt;number); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;number&#36825;&#20010;&#23383;&#27573;&#21547;&#20041;.</span>
  <span class="org-keyword">if</span> (iter-&gt;Valid()) {
    <span class="org-type">WritableFile</span>* <span class="org-variable-name">file</span>;
    s = env-&gt;NewWritableFile(fname, &amp;file); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#26032;&#30340;&#25991;&#20214;.</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
      <span class="org-keyword">return</span> s;
    }

    <span class="org-type">TableBuilder</span>* <span class="org-variable-name">builder</span> = <span class="org-keyword">new</span> <span class="org-type">TableBuilder</span>(options, file);
    meta-&gt;smallest.DecodeFrom(iter-&gt;key()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#36941;&#21382;iter&#37324;&#38754;&#30340;&#23545;&#35937;.&#36825;&#37324;&#20250;&#35760;&#24405;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#23567;&#21644;&#26368;&#22823;&#30340;key&#35760;&#24405;&#22312;meta&#37324;&#38754;.</span>
    <span class="org-keyword">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) {
      <span class="org-type">Slice</span> <span class="org-variable-name">key</span> = iter-&gt;key();
      meta-&gt;largest.DecodeFrom(key);
      builder-&gt;Add(key, iter-&gt;value());
    }

    <span class="org-comment-delimiter">// </span><span class="org-comment">Finish and check for builder errors</span>
    <span class="org-keyword">if</span> (s.ok()) {
      s = builder-&gt;Finish(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;&#20837;index&#20197;&#21450;footer&#37096;&#20998;.</span>
      <span class="org-keyword">if</span> (s.ok()) {
        meta-&gt;file_size = builder-&gt;FileSize();
        assert(meta-&gt;file_size &gt; 0);
      }
    } <span class="org-keyword">else</span> {
      builder-&gt;Abandon();
    }
    <span class="org-keyword">delete</span> builder;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Finish and check for file errors</span>
    <span class="org-keyword">if</span> (s.ok()) {
      s = file-&gt;Sync();
    }
    <span class="org-keyword">if</span> (s.ok()) {
      s = file-&gt;Close();
    }
    <span class="org-keyword">delete</span> file;
    file = <span class="org-constant">NULL</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20250;&#23558;&#36825;&#20010;sstable&#21152;&#20837;&#21040;TableCache&#37324;&#38754;.</span>
    <span class="org-keyword">if</span> (s.ok()) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Verify that the table is usable</span>
      <span class="org-type">Iterator</span>* <span class="org-variable-name">it</span> = table_cache-&gt;NewIterator(ReadOptions(),
                                              meta-&gt;number,
                                              meta-&gt;file_size);
      s = it-&gt;status();
      <span class="org-keyword">delete</span> it;
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Check for input iterator errors</span>
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>iter-&gt;status().ok()) {
    s = iter-&gt;status();
  }

  <span class="org-keyword">if</span> (s.ok() &amp;&amp; meta-&gt;file_size &gt; 0) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Keep it</span>
  } <span class="org-keyword">else</span> {
    env-&gt;DeleteFile(fname);
  }
  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline225" class="outline-4">
<h4 id="orgheadline225"><span class="section-number-4">10.8.3</span> TableCache</h4>
<div class="outline-text-4" id="text-10-8-3">
<p>
db/table_cache.cc TableCache的工作非常简单，就是针对Table对象以及Table::Iterator对象进行cache.
这样底层的话可以防止过多的文件打开。了解这个功能之后代码就非常好阅读了。我们首先看看TableCache结构.
对于Cache的key使用uint64_t file_number来进行标记.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">TableCache</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">TableCache</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>, <span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-variable-name">options</span>, <span class="org-type">int</span> <span class="org-variable-name">entries</span>);
  ~<span class="org-function-name">TableCache</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return an iterator for the specified file number (the corresponding</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">file length must be exactly "file_size" bytes).  If "tableptr" is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">non-NULL, also sets "*tableptr" to point to the Table object</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">underlying the returned iterator, or NULL if no Table object underlies</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the returned iterator.  The returned "*tableptr" object is owned by</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the cache and should not be deleted, and is valid for as long as the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">returned iterator is live.</span>
  Iterator* NewIterator(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                        <span class="org-type">uint64_t</span> <span class="org-variable-name">file_number</span>,
                        <span class="org-type">uint64_t</span> <span class="org-variable-name">file_size</span>,
                        <span class="org-type">Table</span>** <span class="org-variable-name">tableptr</span> = <span class="org-constant">NULL</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Evict any entry for the specified file number</span>
  <span class="org-type">void</span> <span class="org-function-name">Evict</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">file_number</span>);

 <span class="org-keyword">private</span>:
  <span class="org-type">Env</span>* <span class="org-keyword">const</span> <span class="org-variable-name">env_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24213;&#23618;env</span>
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">dbname_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#24320;db&#21517;&#31216;.</span>
  <span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-variable-name">options_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25171;&#24320;options.</span>
  <span class="org-type">Cache</span>* <span class="org-variable-name">cache_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Cache&#23545;&#35937;.</span>
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline222"></a>TableCache<br  /><div class="outline-text-5" id="text-10-8-3-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">TableCache</span>::<span class="org-function-name">TableCache</span>(<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">string</span>&amp; <span class="org-variable-name">dbname</span>,
                       <span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-variable-name">options</span>,
                       <span class="org-type">int</span> <span class="org-variable-name">entries</span>)
    : env_(options-&gt;env),
      dbname_(dbname),
      options_(options),
      <span class="org-comment-delimiter">// </span><span class="org-comment">entries&#34920;&#31034;Cache&#30340;capacity.</span>
      cache_(NewLRUCache(entries)) {
}

<span class="org-constant">TableCache</span>::~<span class="org-function-name">TableCache</span>() {
  <span class="org-keyword">delete</span> cache_;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline223"></a>Evict<br  /><div class="outline-text-5" id="text-10-8-3-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TableCache</span>::<span class="org-function-name">Evict</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">file_number</span>) {
  <span class="org-type">char</span> <span class="org-variable-name">buf</span>[<span class="org-keyword">sizeof</span>(file_number)];
  EncodeFixed64(buf, file_number);
  cache_-&gt;Erase(Slice(buf, <span class="org-keyword">sizeof</span>(buf)));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline224"></a>NewIterator<br  /><div class="outline-text-5" id="text-10-8-3-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-type">TableAndFile</span> {
  <span class="org-type">RandomAccessFile</span>* <span class="org-variable-name">file</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;file&#21644;table&#32465;&#23450;.</span>
  <span class="org-type">Table</span>* <span class="org-variable-name">table</span>;
};

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">DeleteEntry</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">void</span>* <span class="org-variable-name">value</span>) {
  <span class="org-type">TableAndFile</span>* <span class="org-variable-name">tf</span> = <span class="org-keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(value);
  <span class="org-keyword">delete</span> tf-&gt;table;
  <span class="org-keyword">delete</span> tf-&gt;file;
  <span class="org-keyword">delete</span> tf;
}

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">UnrefEntry</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg1</span>, <span class="org-type">void</span>* <span class="org-variable-name">arg2</span>) {
  <span class="org-type">Cache</span>* <span class="org-variable-name">cache</span> = <span class="org-keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg1);
  <span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-variable-name">h</span> = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-constant">Cache</span>::Handle*&gt;(arg2);
  cache-&gt;Release(h);
}

<span class="org-type">Iterator</span>* <span class="org-constant">TableCache</span>::<span class="org-function-name">NewIterator</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                                  <span class="org-type">uint64_t</span> <span class="org-variable-name">file_number</span>,
                                  <span class="org-type">uint64_t</span> <span class="org-variable-name">file_size</span>,
                                  <span class="org-type">Table</span>** <span class="org-variable-name">tableptr</span>) {
  <span class="org-keyword">if</span> (tableptr != <span class="org-constant">NULL</span>) {
    *tableptr = <span class="org-constant">NULL</span>;
  }

  <span class="org-type">char</span> <span class="org-variable-name">buf</span>[<span class="org-keyword">sizeof</span>(file_number)];
  EncodeFixed64(buf, file_number); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#25454;file_number&#20316;&#20026;key&#26597;&#35810;.</span>
  <span class="org-type">Slice</span> <span class="org-variable-name">key</span>(buf, <span class="org-keyword">sizeof</span>(buf));
  <span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-variable-name">handle</span> = cache_-&gt;Lookup(key); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#22312;cache&#37324;&#38754;&#26597;&#25214;.</span>
  <span class="org-keyword">if</span> (handle == <span class="org-constant">NULL</span>) {
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">fname</span> = TableFileName(dbname_, file_number);
    <span class="org-type">RandomAccessFile</span>* <span class="org-variable-name">file</span> = <span class="org-constant">NULL</span>;
    <span class="org-type">Table</span>* <span class="org-variable-name">table</span> = <span class="org-constant">NULL</span>;
    <span class="org-type">Status</span> <span class="org-variable-name">s</span> = env_-&gt;NewRandomAccessFile(fname, &amp;file);
    <span class="org-keyword">if</span> (s.ok()) {
      s = <span class="org-constant">Table</span>::Open(*options_, file, file_size, &amp;table);
    }

    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
      assert(table == <span class="org-constant">NULL</span>);
      <span class="org-keyword">delete</span> file;
      <span class="org-comment-delimiter">// </span><span class="org-comment">We do not cache error results so that if the error is transient,</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">or somebody repairs the file, we recover automatically.</span>
      <span class="org-keyword">return</span> NewErrorIterator(s);
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;&#19968;&#20010;cache item</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;charge=1&#37027;&#20040;capacity&#23601;&#34920;&#31034;&#20010;&#25968;.</span>
    <span class="org-type">TableAndFile</span>* <span class="org-variable-name">tf</span> = <span class="org-keyword">new</span> <span class="org-type">TableAndFile</span>;
    tf-&gt;file = file;
    tf-&gt;table = table;
    handle = cache_-&gt;Insert(key, tf, 1, &amp;DeleteEntry);
  }

  <span class="org-type">Table</span>* <span class="org-variable-name">table</span> = <span class="org-keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;
  <span class="org-type">Iterator</span>* <span class="org-variable-name">result</span> = table-&gt;NewIterator(options);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;cleanup&#20989;&#25968;&#26159;&#20943;&#23569;&#24341;&#29992;&#35745;&#25968;.</span>
  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);
  <span class="org-keyword">if</span> (tableptr != <span class="org-constant">NULL</span>) {
    *tableptr = table;
  }
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline234" class="outline-4">
<h4 id="orgheadline234"><span class="section-number-4">10.8.4</span> Table</h4>
<div class="outline-text-4" id="text-10-8-4">
<p>
table/table.cc 这个接口在include/leveldb/table.h里面已经给出了.我们这里就是看看具体实现.
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline226"></a>Rep<br  /><div class="outline-text-5" id="text-10-8-4-1">
<p>
Rep是Table内部的数据结构.这样实现了之后那么头文件里面可以不包含任何实现了.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-constant">Table</span>::<span class="org-type">Rep</span> {
  ~<span class="org-function-name">Rep</span>() {
    <span class="org-keyword">delete</span> index_block;
  }

  <span class="org-type">Options</span> <span class="org-variable-name">options</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">status</span>;
  <span class="org-type">RandomAccessFile</span>* <span class="org-variable-name">file</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">cache_id</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">todo:&#22312;BlockReader&#37324;&#38754;&#20316;&#20026;cache key&#30340;&#19968;&#37096;&#20998;&#23384;&#22312;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38382;&#39064;&#26159;&#36825;&#20010;cache_id&#20027;&#35201;&#26159;&#29992;&#26469;&#35299;&#20915;&#20160;&#20040;&#38382;&#39064;&#30340;&#21602;?</span>

  <span class="org-type">BlockHandle</span> <span class="org-variable-name">metaindex_handle</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Handle to metaindex_block: saved from footer</span>
  <span class="org-type">Block</span>* <span class="org-variable-name">index_block</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20445;&#23384;data index&#30340;block.</span>
};
</pre>
</div>
</div></li>

<li><a id="orgheadline227"></a>Open<br  /><div class="outline-text-5" id="text-10-8-4-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">Table</span>::<span class="org-function-name">Open</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>,
                   <span class="org-type">RandomAccessFile</span>* <span class="org-variable-name">file</span>,
                   <span class="org-type">uint64_t</span> <span class="org-variable-name">size</span>,
                   <span class="org-type">Table</span>** <span class="org-variable-name">table</span>) {
  *table = <span class="org-constant">NULL</span>;
  <span class="org-keyword">if</span> (size &lt; <span class="org-constant">Footer</span>::kEncodedLength) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;&#25991;&#20214;&#22823;&#23567;&#32943;&#23450;&#38656;&#35201;&#19968;&#20010;footer&#23545;&#35937;.</span>
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::InvalidArgument(<span class="org-string">"file is too short to be an sstable"</span>);
  }

  <span class="org-type">char</span> <span class="org-variable-name">footer_space</span>[<span class="org-constant">Footer</span>::kEncodedLength]; <span class="org-comment-delimiter">// </span><span class="org-comment">footer&#31354;&#38388;.</span>
  <span class="org-type">Slice</span> <span class="org-variable-name">footer_input</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;footer.</span>
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = file-&gt;Read(size - <span class="org-constant">Footer</span>::kEncodedLength, <span class="org-constant">Footer</span>::kEncodedLength,
                        &amp;footer_input, footer_space);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) <span class="org-keyword">return</span> s;

  <span class="org-type">Footer</span> <span class="org-variable-name">footer</span>;
  s = footer.DecodeFrom(&amp;footer_input);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) <span class="org-keyword">return</span> s;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Read the index block</span>
  <span class="org-type">Block</span>* <span class="org-variable-name">index_block</span> = <span class="org-constant">NULL</span>;
  <span class="org-keyword">if</span> (s.ok()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35835;&#21462;index block.</span>
    s = ReadBlock(file, ReadOptions(), footer.index_handle(), &amp;index_block);
  }

  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">We've successfully read the footer and the index block: we're</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">ready to serve requests.</span>
    <span class="org-type">Rep</span>* <span class="org-variable-name">rep</span> = <span class="org-keyword">new</span> <span class="org-constant">Table</span>::<span class="org-type">Rep</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">new&#21019;&#24314;Rep&#23545;&#35937;&#28982;&#21518;&#26500;&#36896;Table&#23545;&#35937;.</span>
    rep-&gt;options = options;
    rep-&gt;file = file;
    rep-&gt;metaindex_handle = footer.metaindex_handle();
    rep-&gt;index_block = index_block;
    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : 0);
    *table = <span class="org-keyword">new</span> <span class="org-type">Table</span>(rep);
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">if</span> (index_block) <span class="org-keyword">delete</span> index_block;
  }

  <span class="org-keyword">return</span> s;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline228"></a>ApproximateOffsetOf<br  /><div class="outline-text-5" id="text-10-8-4-3">
<p>
根据key找到kv在file的偏移.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">uint64_t</span> <span class="org-constant">Table</span>::<span class="org-function-name">ApproximateOffsetOf</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> {
  <span class="org-type">Iterator</span>* <span class="org-variable-name">index_iter</span> =
      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);
  index_iter-&gt;Seek(key); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;iterator seek&#21040;kv&#30340;index&#30340;&#20301;&#32622;.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">result</span>;
  <span class="org-keyword">if</span> (index_iter-&gt;Valid()) {
    <span class="org-type">BlockHandle</span> <span class="org-variable-name">handle</span>;
    <span class="org-type">Slice</span> <span class="org-variable-name">input</span> = index_iter-&gt;value();
    <span class="org-type">Status</span> <span class="org-variable-name">s</span> = handle.DecodeFrom(&amp;input); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;index&#36825;&#20010;BlockHandle&#20013;&#30693;&#36947;&#25968;&#25454;&#30340;&#20559;&#31227;.</span>
    <span class="org-keyword">if</span> (s.ok()) {
      result = handle.offset();
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Strange: we can't decode the block handle in the index block.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">We'll just return the offset of the metaindex block, which is</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">close to the whole file size for this case.</span>
      result = rep_-&gt;metaindex_handle.offset();
    }
  } <span class="org-keyword">else</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">key is past the last key in the file.  Approximate the offset</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">by returning the offset of the metaindex block (which is</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">right near the end of the file).</span>
    result = rep_-&gt;metaindex_handle.offset();
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#25214;&#19981;&#21040;&#36825;&#20010;key&#30340;&#35805;&#65292;&#37027;&#20040;&#36820;&#22238;metaindex block&#30340;&#20559;&#31227;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26159;meta block&#30340;&#26368;&#21518;&#20301;&#32622;.</span>
  <span class="org-keyword">delete</span> index_iter;
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline229"></a>NewIterator<br  /><div class="outline-text-5" id="text-10-8-4-4">
<p>
NewIterator创建的是TwoLevelIterator.意思非常简单因为需要读取两次才能够读到内容.首先读取index block,
然后读取具体的data block.关于TwoLevelIterator的实现会在后面分析.建议首先分析TwoLevelIterator
然后分析BlockReader.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Iterator</span>* <span class="org-constant">Table</span>::<span class="org-function-name">NewIterator</span>(<span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>) <span class="org-keyword">const</span> {
  <span class="org-keyword">return</span> NewTwoLevelIterator(
      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),
      &amp;<span class="org-constant">Table</span>::BlockReader, <span class="org-keyword">const_cast</span>&lt;Table*&gt;(<span class="org-keyword">this</span>), options);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline230"></a>DeleteBlock<br  /><div class="outline-text-5" id="text-10-8-4-5">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">DeleteBlock</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>, <span class="org-type">void</span>* <span class="org-variable-name">ignored</span>) {
  <span class="org-keyword">delete</span> <span class="org-keyword">reinterpret_cast</span>&lt;Block*&gt;(arg); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20316;&#20026;Block&#30452;&#25509;delete.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline231"></a>DeleteCachedBlock<br  /><div class="outline-text-5" id="text-10-8-4-6">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">DeleteCachedBlock</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">void</span>* <span class="org-variable-name">value</span>) {
  <span class="org-type">Block</span>* <span class="org-variable-name">block</span> = <span class="org-keyword">reinterpret_cast</span>&lt;Block*&gt;(value); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20316;&#20026;Block&#30452;&#25509;&#21024;&#38500;.</span>
  <span class="org-keyword">delete</span> block;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline232"></a>ReleaseBlock<br  /><div class="outline-text-5" id="text-10-8-4-7">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">ReleaseBlock</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>, <span class="org-type">void</span>* <span class="org-variable-name">h</span>) {
  <span class="org-type">Cache</span>* <span class="org-variable-name">cache</span> = <span class="org-keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg);
  <span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-variable-name">handle</span> = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-constant">Cache</span>::Handle*&gt;(h);
  cache-&gt;Release(handle);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline233"></a>BlockReader<br  /><div class="outline-text-5" id="text-10-8-4-8">
<p>
BlockReader任务就是通过读取index_value给定的位置然后读取对应的Block位置并且返回BlockIterator对象.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Convert an index iterator value (i.e., an encoded BlockHandle)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">into an iterator over the contents of the corresponding block.</span>
<span class="org-type">Iterator</span>* <span class="org-constant">Table</span>::<span class="org-function-name">BlockReader</span>(<span class="org-type">void</span>* <span class="org-variable-name">arg</span>,
                             <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                             <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">index_value</span>) {
  <span class="org-type">Table</span>* <span class="org-variable-name">table</span> = <span class="org-keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);
  <span class="org-type">Cache</span>* <span class="org-variable-name">block_cache</span> = table-&gt;rep_-&gt;options.block_cache;
  <span class="org-type">Block</span>* <span class="org-variable-name">block</span> = <span class="org-constant">NULL</span>;
  <span class="org-constant">Cache</span>::<span class="org-type">Handle</span>* <span class="org-variable-name">cache_handle</span> = <span class="org-constant">NULL</span>;

  <span class="org-type">BlockHandle</span> <span class="org-variable-name">handle</span>;
  <span class="org-type">Slice</span> <span class="org-variable-name">input</span> = index_value;
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = handle.DecodeFrom(&amp;input); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20808;&#25214;&#21040;offset&#21644;size.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">We intentionally allow extra stuff in index_value so that we</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">can add more features in the future.</span>

  <span class="org-keyword">if</span> (s.ok()) {
    <span class="org-keyword">if</span> (block_cache != <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23384;&#22312;Cache&#30340;&#35805;.</span>
      <span class="org-type">char</span> <span class="org-variable-name">cache_key_buffer</span>[16];
      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;handle.offset&#21644;cache_id&#20570;&#19968;&#20010;&#31614;&#21517;&#26597;&#35810;.</span>
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      <span class="org-type">Slice</span> <span class="org-variable-name">key</span>(cache_key_buffer, <span class="org-keyword">sizeof</span>(cache_key_buffer));
      cache_handle = block_cache-&gt;Lookup(key);
      <span class="org-keyword">if</span> (cache_handle != <span class="org-constant">NULL</span>) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#23384;&#22312;&#36825;&#20010;&#23545;&#35937;&#30340;&#35805;.</span>
        block = <span class="org-keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#36825;&#20010;&#23545;&#35937;&#30340;&#35805;.&#37027;&#20040;&#30452;&#25509;&#35835;&#21462;&#23545;&#35937;.</span>
        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;block);
        <span class="org-keyword">if</span> (s.ok() &amp;&amp; options.fill_cache) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26597;&#21040;&#32467;&#26524;&#25918;&#21040;cache&#30340;&#35805;.</span>
          cache_handle = block_cache-&gt;Insert( <span class="org-comment-delimiter">// </span><span class="org-comment">&#25554;&#20837;&#36825;&#20010;&#23545;&#35937;.</span>
              <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#20174;Cache&#20013;&#21024;&#38500;&#30340;&#22238;&#35843;&#23601;&#26159;&#30452;&#25509;delete.</span>
              key, block, block-&gt;size(), &amp;DeleteCachedBlock);
        }
      }
    } <span class="org-keyword">else</span> {
      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;block);
    }
  }

  <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span>;
  <span class="org-keyword">if</span> (block != <span class="org-constant">NULL</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#24471;&#21040;&#36825;&#20010;block&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#21019;&#24314;&#36825;&#20010;Iterator.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;&#26159;&#19968;&#20010;user comparator.</span>
    iter = block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);
    <span class="org-keyword">if</span> (cache_handle == <span class="org-constant">NULL</span>) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#25918;&#22312;cache&#37324;&#38754;&#30340;&#35805;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#24403;&#36825;&#20010;iterator&#22833;&#25928;&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#23558;Block&#21024;&#38500;.</span>
      iter-&gt;RegisterCleanup(&amp;DeleteBlock, block, <span class="org-constant">NULL</span>);
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#20351;&#29992;&#24341;&#29992;&#35745;&#25968;.&#25152;&#20197;ReleaseBlock&#37324;&#38754;&#26159;&#37319;&#29992;Release&#26041;&#24335;.</span>
      iter-&gt;RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);
    }
  } <span class="org-keyword">else</span> {
    iter = NewErrorIterator(s);
  }
  <span class="org-keyword">return</span> iter;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline242" class="outline-4">
<h4 id="orgheadline242"><span class="section-number-4">10.8.5</span> TableBuilder</h4>
<div class="outline-text-4" id="text-10-8-5">
<p>
table/table_builde.cc TableBuilder接口在之前include/leveldb/table_builder.h里面已经提供了。
这里我们具体看看TableBuilder的接口.关于table格式的话可以参考TableFormat这节.注意这里TableBuilder
只是将kv加入到了block并且写入了磁盘，但是对于index block并没有写入磁盘。
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline235"></a>Rep<br  /><div class="outline-text-5" id="text-10-8-5-1">
<p>
Rep是TableBuilder里面具体涉及到的字段.我们来看看这个结构
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">struct</span> <span class="org-constant">TableBuilder</span>::<span class="org-type">Rep</span> {
  <span class="org-type">Options</span> <span class="org-variable-name">options</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25968;&#25454;options.</span>
  <span class="org-type">Options</span> <span class="org-variable-name">index_block_options</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">index options.</span>
  <span class="org-type">WritableFile</span>* <span class="org-variable-name">file</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">sstable&#25991;&#20214;.</span>
  <span class="org-type">uint64_t</span> <span class="org-variable-name">offset</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#21521;&#36825;&#20010;file&#20889;&#20837;&#20102;&#22810;&#23569;&#25968;&#25454;.</span>
  <span class="org-type">Status</span> <span class="org-variable-name">status</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">file&#25805;&#20316;&#36820;&#22238;&#30340;status.</span>
  <span class="org-type">BlockBuilder</span> <span class="org-variable-name">data_block</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">data block.</span>
  <span class="org-type">BlockBuilder</span> <span class="org-variable-name">index_block</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">index block.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">last_key</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#19978;&#27425;&#25554;&#20837;&#30340;key.</span>
  <span class="org-type">int64_t</span> <span class="org-variable-name">num_entries</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24050;&#32463;&#25554;&#20837;&#20102;&#22810;&#23569;&#20010;kv.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">closed</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">Either Finish() or Abandon() has been called.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">We do not emit the index entry for a block until we have seen the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">first key for the next data block.  This allows us to use shorter</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">keys in the index block.  For example, consider a block boundary</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">between the keys "the quick brown fox" and "the who".  We can use</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"the r" as the key for the index block entry since it is &gt;= all</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">entries in the first block and &lt; all entries in subsequent</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">blocks.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Invariant: r-&gt;pending_index_entry is true only if data_block is empty.</span>
  <span class="org-type">bool</span> <span class="org-variable-name">pending_index_entry</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26159;&#21542;&#21018;&#25165;&#35843;&#29992;&#20102;Finish.</span>
  <span class="org-type">BlockHandle</span> <span class="org-variable-name">pending_handle</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Handle to add to index block</span>

  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">compressed_output</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20316;&#20026;compressed&#23384;&#25918;&#30340;&#20869;&#23481;.</span>

  <span class="org-function-name">Rep</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">opt</span>, <span class="org-type">WritableFile</span>* <span class="org-variable-name">f</span>)
      : options(opt),
        <span class="org-type">index_block_options</span>(<span class="org-variable-name">opt</span>),
        <span class="org-type">file</span>(<span class="org-variable-name">f</span>),
        offset(0),
        <span class="org-type">data_block</span>(&amp;<span class="org-variable-name">options</span>),
        <span class="org-type">index_block</span>(&amp;<span class="org-variable-name">index_block_options</span>),
        num_entries(0),
        closed(<span class="org-constant">false</span>),
        pending_index_entry(<span class="org-constant">false</span>) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37324;&#38754;&#23384;&#25918;&#30340;key&#26159;&#20840;&#37327;.</span>
    index_block_options.block_restart_interval = 1; <span class="org-comment-delimiter">// </span><span class="org-comment">index block option restart&#20026;1.</span>
  }
};
</pre>
</div>
</div></li>

<li><a id="orgheadline236"></a>ChangeOptions<br  /><div class="outline-text-5" id="text-10-8-5-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">TableBuilder</span>::<span class="org-function-name">ChangeOptions</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>&amp; <span class="org-variable-name">options</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Note: if more fields are added to Options, update</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">this function to catch changes that should not be allowed to</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">change in the middle of building a Table.</span>
  <span class="org-keyword">if</span> (options.comparator != rep_-&gt;options.comparator) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38656;&#35201;&#30830;&#20445;comparator&#23545;&#35937;&#27809;&#26377;&#21457;&#29983;&#25913;&#21464;.</span>
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::InvalidArgument(<span class="org-string">"changing comparator while building table"</span>);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Note that any live BlockBuilders point to rep_-&gt;options and therefore</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">will automatically pick up the updated options.</span>
  rep_-&gt;options = options;
  rep_-&gt;index_block_options = options;
  rep_-&gt;index_block_options.block_restart_interval = 1
  <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline237"></a>Add<br  /><div class="outline-text-5" id="text-10-8-5-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TableBuilder</span>::<span class="org-function-name">Add</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) {
  <span class="org-type">Rep</span>* <span class="org-variable-name">r</span> = rep_;
  assert(<span class="org-negation-char">!</span>r-&gt;closed);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ok()) <span class="org-keyword">return</span>;
  <span class="org-keyword">if</span> (r-&gt;num_entries &gt; 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#30830;&#20445;&#25353;&#29031;&#39034;&#24207;&#25805;&#20316;.</span>
    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; 0);
  }

  <span class="org-keyword">if</span> (r-&gt;pending_index_entry) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#36825;&#37324;&#26032;&#24320;&#36767;&#19968;&#20010;block&#30340;&#35805;&#23545;&#20110;&#31532;&#19968;&#22359;&#27809;&#26377;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#37027;&#20040;&#25105;&#20204;&#36825;&#37324;&#20570;&#19968;&#20010;index.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">index key&#26159;&#25353;&#29031;last_ley&#21644;key&#20043;&#38388;&#30340;FindShortestSeparator&#24471;&#21040;&#30340;</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#26679;&#21487;&#20197;&#20351;&#29992;&#20108;&#20998;&#27861;&#26469;&#36827;&#34892;&#25628;&#32034;.</span>
    assert(r-&gt;data_block.empty());
    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">handle_encoding</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#38405;&#35835;&#23436;Finish&#20250;&#21457;&#29616;&#36825;&#37324;handle_encoding&#23454;&#38469;&#19978;&#26159;&#23601;&#26159;last_key&#30340;&#20301;&#32622;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#20351;&#29992;FindShortestSeparator&#26356;&#21152;&#33410;&#30465;&#31354;&#38388;&#20316;&#20026;index_block&#37324;&#38754;&#30340;&#20869;&#23481;.:).</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20294;&#36825;&#37324;&#20063;&#20915;&#23450;&#20102;index_block&#30340;key&#19981;&#33021;&#22815;&#20316;&#20026;data block&#37324;&#38754;&#20934;&#30830;&#30340;key.</span>
    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);
    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));
    r-&gt;pending_index_entry = <span class="org-constant">false</span>;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26356;&#26032;last_key&#24182;&#19988;&#25554;&#20837;data block.</span>
  r-&gt;last_key.assign(key.data(), key.size());
  r-&gt;num_entries++;
  r-&gt;data_block.Add(key, value);

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24403;&#21069;&#30340;size&#36229;&#36807;block size&#30340;&#35805;&#37027;&#20040;&#23601;&#38656;&#35201;&#21047;&#26032;.</span>
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">estimated_block_size</span> = r-&gt;data_block.CurrentSizeEstimate();
  <span class="org-keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) {
    Flush();
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline238"></a>Flush<br  /><div class="outline-text-5" id="text-10-8-5-4">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TableBuilder</span>::<span class="org-function-name">Flush</span>() {
  <span class="org-type">Rep</span>* <span class="org-variable-name">r</span> = rep_;
  assert(<span class="org-negation-char">!</span>r-&gt;closed);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ok()) <span class="org-keyword">return</span>;
  <span class="org-keyword">if</span> (r-&gt;data_block.empty()) <span class="org-keyword">return</span>;
  assert(<span class="org-negation-char">!</span>r-&gt;pending_index_entry);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;data block&#20316;&#20026;Block&#20889;&#20837;&#28982;&#21518;&#23558;&#36825;&#20010;handle&#25918;&#22312;pengding_handle&#37324;&#38754;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20010;WriteBlock&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;&#20102;.</span>
  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);
  <span class="org-keyword">if</span> (ok()) {
    r-&gt;pending_index_entry = <span class="org-constant">true</span>;
    r-&gt;status = r-&gt;file-&gt;Flush();
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline239"></a>WriteBlock<br  /><div class="outline-text-5" id="text-10-8-5-5">
<p>
写入block的内容并且将block所在的位置交给handle.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TableBuilder</span>::<span class="org-function-name">WriteBlock</span>(<span class="org-type">BlockBuilder</span>* <span class="org-variable-name">block</span>, <span class="org-type">BlockHandle</span>* <span class="org-variable-name">handle</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">File format contains a sequence of blocks where each block has:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">block_data: uint8[n]</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">type: uint8</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">crc: uint32</span>
  assert(ok());
  <span class="org-type">Rep</span>* <span class="org-variable-name">r</span> = rep_;
  <span class="org-type">Slice</span> <span class="org-variable-name">raw</span> = block-&gt;Finish();

  <span class="org-type">Slice</span> <span class="org-variable-name">block_contents</span>;
  <span class="org-type">CompressionType</span> <span class="org-variable-name">type</span> = r-&gt;options.compression;
  <span class="org-comment-delimiter">// </span><span class="org-comment">TODO(postrelease): Support more compression options: zlib?</span>
  <span class="org-keyword">switch</span> (type) {
    <span class="org-keyword">case</span> kNoCompression:
      block_contents = raw;
      <span class="org-keyword">break</span>;

    <span class="org-keyword">case</span> kSnappyCompression: {
      <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">compressed</span> = &amp;r-&gt;compressed_output;
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#23581;&#35797;&#20351;&#29992;snappy compress.&#22914;&#26524;&#21387;&#32553;&#26356;&#22823;&#30340;&#35805;&#37027;&#20040;&#25918;&#24323;.</span>
      <span class="org-keyword">if</span> (<span class="org-constant">port</span>::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;
          compressed-&gt;size() &lt; raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Snappy not supported, or compressed less than 12.5%, so just</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">store uncompressed form</span>
        block_contents = raw;
        type = kNoCompression;
      }
      <span class="org-keyword">break</span>;
    }
  }
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;handle&#20026;block&#30340;&#20301;&#32622;.</span>
  handle-&gt;set_offset(r-&gt;offset);
  handle-&gt;set_size(block_contents.size());
  r-&gt;status = r-&gt;file-&gt;Append(block_contents);
  <span class="org-keyword">if</span> (r-&gt;status.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;&#20837;type&#21644;crc33c:).</span>
    <span class="org-type">char</span> <span class="org-variable-name">trailer</span>[kBlockTrailerSize];
    trailer[0] = type;
    <span class="org-type">uint32_t</span> <span class="org-variable-name">crc</span> = <span class="org-constant">crc32c</span>::Value(block_contents.data(), block_contents.size());
    crc = <span class="org-constant">crc32c</span>::Extend(crc, trailer, 1);  <span class="org-comment-delimiter">// </span><span class="org-comment">Extend crc to cover block type</span>
    EncodeFixed32(trailer+1, <span class="org-constant">crc32c</span>::Mask(crc));
    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));
    <span class="org-keyword">if</span> (r-&gt;status.ok()) {
      r-&gt;offset += block_contents.size() + kBlockTrailerSize;
    }
  }
  r-&gt;compressed_output.clear();
  block-&gt;Reset();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline240"></a>Finish<br  /><div class="outline-text-5" id="text-10-8-5-6">
<p>
Finish写入的TableFormat表述的最后面的index部分以及footer.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">TableBuilder</span>::<span class="org-function-name">Finish</span>() {
  <span class="org-type">Rep</span>* <span class="org-variable-name">r</span> = rep_;
  Flush();
  assert(<span class="org-negation-char">!</span>r-&gt;closed);
  r-&gt;closed = <span class="org-constant">true</span>;
  <span class="org-type">BlockHandle</span> <span class="org-variable-name">metaindex_block_handle</span>;
  <span class="org-type">BlockHandle</span> <span class="org-variable-name">index_block_handle</span>;
  <span class="org-keyword">if</span> (ok()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#23454;&#38469;&#19978;&#36825;&#20010;meta_index_block&#37096;&#20998;&#27809;&#26377;&#20219;&#20309;&#20869;&#23481;.</span>
    <span class="org-type">BlockBuilder</span> <span class="org-variable-name">meta_index_block</span>(&amp;r-&gt;options);
    <span class="org-comment-delimiter">// </span><span class="org-comment">TODO(postrelease): Add stats and other meta blocks</span>
    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;&#20837;&#20043;&#21518;&#28982;&#21518;&#24471;&#21040;handle.</span>
  }
  <span class="org-keyword">if</span> (ok()) {
    <span class="org-keyword">if</span> (r-&gt;pending_index_entry) {
      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);
      <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">handle_encoding</span>;
      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);
      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));
      r-&gt;pending_index_entry = <span class="org-constant">false</span>;
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#20889;&#20837;index block.</span>
    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);
  }
  <span class="org-keyword">if</span> (ok()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#26368;&#21518;&#23558;footer&#37096;&#20998;&#20889;&#20837;.</span>
    <span class="org-type">Footer</span> <span class="org-variable-name">footer</span>;
    footer.set_metaindex_handle(metaindex_block_handle);
    footer.set_index_handle(index_block_handle);
    <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">footer_encoding</span>;
    footer.EncodeTo(&amp;footer_encoding);
    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);
    <span class="org-keyword">if</span> (r-&gt;status.ok()) {
      r-&gt;offset += footer_encoding.size();
    }
  }
  <span class="org-keyword">return</span> r-&gt;status;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline241"></a>Abandon<br  /><div class="outline-text-5" id="text-10-8-5-7">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#25805;&#20316;&#38750;&#24120;&#31616;&#21333;&#23601;&#26159;&#25918;&#24323;&#26500;&#24314;.</span>
<span class="org-type">void</span> <span class="org-constant">TableBuilder</span>::<span class="org-function-name">Abandon</span>() {
  <span class="org-type">Rep</span>* <span class="org-variable-name">r</span> = rep_;
  assert(<span class="org-negation-char">!</span>r-&gt;closed);
  r-&gt;closed = <span class="org-constant">true</span>;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline249" class="outline-4">
<h4 id="orgheadline249"><span class="section-number-4">10.8.6</span> BlockBuilder</h4>
<div class="outline-text-4" id="text-10-8-6">
<p>
table/block_builder.h 从提供的接口来看的话，BlockBuilder功能应该是将多个有序的kv写到一个连续内存块内部。
我们首先看看结构然后具体分析里面的方法.提供的Reset接口允许BlockBuilder重复使用.底层针对key的prefix部分进行了压缩.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">BlockBuilder</span> {
 <span class="org-keyword">public</span>:
  <span class="org-keyword">explicit</span> <span class="org-function-name">BlockBuilder</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-variable-name">options</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Reset the contents as if the BlockBuilder was just constructed.</span>
  <span class="org-type">void</span> <span class="org-function-name">Reset</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Finish() has not been callled since the last call to Reset().</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: key is larger than any previously added key</span>
  <span class="org-type">void</span> <span class="org-function-name">Add</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#30830;&#20445;key&#30340;&#26377;&#24207;&#24615;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Finish building the block and return a slice that refers to the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">block contents.  The returned slice will remain valid for the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">lifetime of this builder or until Reset() is called.</span>
  <span class="org-type">Slice</span> <span class="org-function-name">Finish</span>(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23436;&#25104;&#20043;&#21518;&#36820;&#22238;&#20889;&#20837;&#30340;buffer.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns an estimate of the current (uncompressed) size of the block</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we are building.</span>
  <span class="org-type">size_t</span> <span class="org-function-name">CurrentSizeEstimate</span>() <span class="org-keyword">const</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;block buffer&#22823;&#23567;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return true iff no entries have been added since the last Reset()</span>
  <span class="org-type">bool</span> <span class="org-function-name">empty</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> buffer_.empty();
  }

 <span class="org-keyword">private</span>:
  <span class="org-keyword">const</span> <span class="org-type">Options</span>*        <span class="org-variable-name">options_</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span>           <span class="org-variable-name">buffer_</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">Destination buffer</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">uint32_t</span>&gt; <span class="org-variable-name">restarts_</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">Restart points</span>
  <span class="org-type">int</span>                   <span class="org-variable-name">counter_</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">Number of entries emitted since restart</span>
  <span class="org-type">bool</span>                  <span class="org-variable-name">finished_</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">Has Finish() been called?</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span>           <span class="org-variable-name">last_key_</span>;
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline243"></a>PrefixCompressed<br  /><div class="outline-text-5" id="text-10-8-6-1">
<p>
我们首先看看BlockBuilder是如何针对key进行prefix-compressed的.对于每K个key的话会保存一个完整key,然后对于
剩余的K-1个key采用prefix-compressed的方式压缩。共享的部分长度叫做shared_bytes,非共享的部分叫做unshared_bytes.
对于保存这些完整的key的点，叫做restarts.这个非常好理解。然后从下面注释可以看到restarts的信息保存在最后.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">When we store a key, we drop the prefix shared with the previous</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">string.  This helps reduce the space requirement significantly.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Furthermore, once every K keys, we do not apply the prefix</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">compression and store the entire key.  We call this a "restart</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">point".  The tail end of the block stores the offsets of all of the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">restart points, and can be used to do a binary search when looking</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">for a particular key.  Values are stored as-is (without compression)</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">immediately following the corresponding key.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">An entry for a particular key-value pair has the form:</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">shared_bytes: varint32</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">unshared_bytes: varint32</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">value_length: varint32</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">key_delta: char[unshared_bytes]</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">value: char[value_length]</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">shared_bytes == 0 for restart points.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The trailer of the block has the form:</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">restarts: uint32[num_restarts]</span>
<span class="org-comment-delimiter">//     </span><span class="org-comment">num_restarts: uint32</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">restarts[i] contains the offset within the block of the ith restart point.</span>
</pre>
</div>
</div></li>

<li><a id="orgheadline244"></a>BlockBuilder<br  /><div class="outline-text-5" id="text-10-8-6-2">
<p>
构造函数非常简单.这里options-&gt;block_restrat_interval可能就是之前说的参数K
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">BlockBuilder</span>::<span class="org-function-name">BlockBuilder</span>(<span class="org-keyword">const</span> <span class="org-type">Options</span>* <span class="org-variable-name">options</span>)
    : options_(options),
      restarts_(),
      counter_(0),
      finished_(<span class="org-constant">false</span>) {
  assert(options-&gt;block_restart_interval &gt;= 1);
  restarts_.push_back(0);       <span class="org-comment-delimiter">// </span><span class="org-comment">First restart point is at offset 0</span>
}
</pre>
</div>
<p>
我们这里注意到0就是restarts一个点.
</p>
</div></li>

<li><a id="orgheadline245"></a>Reset<br  /><div class="outline-text-5" id="text-10-8-6-3">
<p>
Reset和构造函数非常简单.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">BlockBuilder</span>::<span class="org-function-name">Reset</span>() {
  buffer_.clear();
  restarts_.clear();
  restarts_.push_back(0);       <span class="org-comment-delimiter">// </span><span class="org-comment">First restart point is at offset 0</span>
  counter_ = 0;
  finished_ = <span class="org-constant">false</span>;
  last_key_.clear();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline246"></a>CurrentSizeEstimate<br  /><div class="outline-text-5" id="text-10-8-6-4">
<p>
按照PrefixCompressed里面的注释来看的话，长度应该就是按照下面的代码计算出来的
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">size_t</span> <span class="org-constant">BlockBuilder</span>::<span class="org-function-name">CurrentSizeEstimate</span>() <span class="org-keyword">const</span> {
  <span class="org-keyword">return</span> (buffer_.size() +                        <span class="org-comment-delimiter">// </span><span class="org-comment">Raw data buffer</span>
          restarts_.size() * <span class="org-keyword">sizeof</span>(uint32_t) +   <span class="org-comment-delimiter">// </span><span class="org-comment">Restart array</span>
          <span class="org-keyword">sizeof</span>(uint32_t));                      <span class="org-comment-delimiter">// </span><span class="org-comment">Restart array length</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline247"></a>Finish<br  /><div class="outline-text-5" id="text-10-8-6-5">
<p>
Finish的工作就是将restarts的信息全部写入到block buffer的结尾吧.同时将buffer_包装称为Slice返回.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Slice</span> <span class="org-constant">BlockBuilder</span>::<span class="org-function-name">Finish</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Append restart array</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; restarts_.size(); i++) {
    PutFixed32(&amp;buffer_, restarts_[i]);
  }
  PutFixed32(&amp;buffer_, restarts_.size());
  finished_ = <span class="org-constant">true</span>;
  <span class="org-keyword">return</span> Slice(buffer_);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline248"></a>Add<br  /><div class="outline-text-5" id="text-10-8-6-6">
<p>
我们这里仔细看看prefix-compressed是相对哪一个key来进行压缩的.阅读代码会发现是针对last_key来进行的.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">BlockBuilder</span>::<span class="org-function-name">Add</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) {
  <span class="org-type">Slice</span> <span class="org-variable-name">last_key_piece</span>(last_key_);
  assert(<span class="org-negation-char">!</span>finished_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#25105;&#20204;&#19981;&#20801;&#35768;finished.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;counter_&#26159;&#33258;restart&#30340;&#35805;&#37027;&#20040;&#20250;reset0.&#25152;&#20197;&#24212;&#35813;&#26159;&lt;=.</span>
  assert(counter_ &lt;= options_-&gt;block_restart_interval);
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#26377;&#20869;&#23481;&#30340;&#35805;&#65292;&#37027;&#20040;&#36825;&#37324;&#38656;&#35201;&#39564;&#35777;key&#26159;&#21542;&#26377;&#24207;.</span>
  assert(buffer_.empty() <span class="org-comment-delimiter">// </span><span class="org-comment">No values yet?</span>
         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; 0);
  <span class="org-type">size_t</span> <span class="org-variable-name">shared</span> = 0;
  <span class="org-keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">See how much sharing to do with previous string</span>
    <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">min_length</span> = <span class="org-constant">std</span>::min(last_key_piece.size(), key.size());
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;prefix compress&#38024;&#23545;last_key&#26469;&#20570;&#30340;.</span>
    <span class="org-keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  } <span class="org-keyword">else</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Restart compression</span>
    restarts_.push_back(buffer_.size()); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;restart&#23384;&#25918;&#30340;&#26159;&#23383;&#33410;&#20559;&#31227;&#32780;&#19981;&#26159;counter.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22240;&#20026;&#35760;&#24405;counter&#37027;&#20040;&#22312;read&#30340;&#26102;&#20505;&#27809;&#26377;&#21150;&#27861;&#36824;&#21407;&#65292;&#22240;&#20026;kv&#37117;&#26159;&#21464;&#38271;&#30340;.</span>
    counter_ = 0;
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;restart point&#30340;&#35805;&#65292;&#37027;&#20040;shared&#30340;&#37096;&#20998;&#24212;&#35813;&#26159;0.</span>
  }
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">non_shared</span> = key.size() - shared;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span>
  PutVarint32(&amp;buffer_, shared);
  PutVarint32(&amp;buffer_, non_shared);
  PutVarint32(&amp;buffer_, value.size());

  <span class="org-comment-delimiter">// </span><span class="org-comment">Add string delta to buffer_ followed by value</span>
  buffer_.append(key.data() + shared, non_shared);
  buffer_.append(value.data(), value.size());

  <span class="org-comment-delimiter">// </span><span class="org-comment">Update state</span>
  last_key_.resize(shared);
  last_key_.append(key.data() + shared, non_shared);
  assert(Slice(last_key_) == key);
  counter_++;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline253" class="outline-4">
<h4 id="orgheadline253"><span class="section-number-4">10.8.7</span> Block</h4>
<div class="outline-text-4" id="text-10-8-7">
<p>
table/block.h Block可以认为是BlockBuilder的Reader对象，解析BlockBuilder生成的Block.提供访问接口是遍历。
首先我们看看具体接口.可以看到解析的就是一个完整的Block对象.
</p>
<div class="org-src-container">

<pre class="src src-C+">class Block {
 public:
  // Initialize the block with the specified contents.
  // Takes ownership of data[] and will delete[] it when done.
  Block(const char* data, size_t size);

  ~Block();

  size_t size() const { return size_; }
  Iterator* NewIterator(const Comparator* comparator); // 访问接口方式是遍历.

 private:
  uint32_t NumRestarts() const;

  const char* data_;
  size_t size_;
  uint32_t restart_offset_;     // Offset in data_ of restart array
  // restart数组的偏移.每个restart都是4个字节.
  class Iter; // 内部实现.
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline250"></a>NumRestarts<br  /><div class="outline-text-5" id="text-10-8-7-1">
<p>
从之前的BloclBuilder知道restart个数在最后面的4字节
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">uint32_t</span> <span class="org-constant">Block</span>::<span class="org-function-name">NumRestarts</span>() <span class="org-keyword">const</span> {
  assert(size_ &gt;= 2*<span class="org-keyword">sizeof</span>(uint32_t));
  <span class="org-keyword">return</span> DecodeFixed32(data_ + size_ - <span class="org-keyword">sizeof</span>(uint32_t));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline251"></a>Block<br  /><div class="outline-text-5" id="text-10-8-7-2">
<p>
注意这里data已经由这个Block来托管了.在析构函数里面会释放data_
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-constant">Block</span>::<span class="org-function-name">Block</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span>, <span class="org-type">size_t</span> <span class="org-variable-name">size</span>)
    : data_(data),
      size_(size) {
  <span class="org-keyword">if</span> (size_ &lt; <span class="org-keyword">sizeof</span>(uint32_t)) {
    size_ = 0;  <span class="org-comment-delimiter">// </span><span class="org-comment">Error marker</span>
  } <span class="org-keyword">else</span> {
    restart_offset_ = size_ - (1 + NumRestarts()) * <span class="org-keyword">sizeof</span>(uint32_t); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#26368;&#21518;&#38754;&#26377;&#19968;&#20010;uint32&#34920;&#31034;restart&#20010;&#25968;.</span>
    <span class="org-keyword">if</span> (restart_offset_ &gt; size_ - <span class="org-keyword">sizeof</span>(uint32_t)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;restart_offset_&#23384;&#22312;&#38382;&#39064;&#30340;&#35805;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">The size is too small for NumRestarts() and therefore</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">restart_offset_ wrapped around.</span>
      size_ = 0;
    }
  }
}

<span class="org-constant">Block</span>::~<span class="org-function-name">Block</span>() {
  <span class="org-keyword">delete</span>[] data_;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline252"></a>NewIterator<br  /><div class="outline-text-5" id="text-10-8-7-3">
<p>
创建一个迭代器.采用了工厂方法创建了具体类.关于这个具体类在后面会被称为BlockIterator来进行分析.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Iterator</span>* <span class="org-constant">Block</span>::<span class="org-function-name">NewIterator</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">cmp</span>) {
  <span class="org-keyword">if</span> (size_ &lt; 2*<span class="org-keyword">sizeof</span>(uint32_t)) {
    <span class="org-keyword">return</span> NewErrorIterator(<span class="org-constant">Status</span>::Corruption(<span class="org-string">"bad block contents"</span>));
  }
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">num_restarts</span> = NumRestarts();
  <span class="org-keyword">if</span> (num_restarts == 0) {
    <span class="org-keyword">return</span> NewEmptyIterator();
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">Iter</span>(cmp, data_, restart_offset_, num_restarts);  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21019;&#24314;BlockIterator.</span>
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline265" class="outline-4">
<h4 id="orgheadline265"><span class="section-number-4">10.8.8</span> BlockIterator</h4>
<div class="outline-text-4" id="text-10-8-8">
<p>
table/block.cc BlockIterator本身完成的功能很简单就是Block的遍历器，我们首先看看结构
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-constant">Block</span>::<span class="org-type">Iter</span> : <span class="org-keyword">public</span> Iterator {
 <span class="org-keyword">private</span>:
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-keyword">const</span> <span class="org-variable-name">comparator_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27604;&#36739;&#23545;&#35937;.</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-keyword">const</span> <span class="org-variable-name">data_</span>;      <span class="org-comment-delimiter">// </span><span class="org-comment">underlying block contents</span>
  uint32_t <span class="org-keyword">const</span> <span class="org-variable-name">restarts_</span>;     <span class="org-comment-delimiter">// </span><span class="org-comment">Offset of restart array (list of fixed32)</span>
  uint32_t <span class="org-keyword">const</span> <span class="org-variable-name">num_restarts_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Number of uint32_t entries in restart array</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">current_ is offset in data_ of current entry.  &gt;= restarts_ if !Valid</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">current_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#30340;data_&#20301;&#32622;.</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">restart_index_</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">Index of restart block in which current_ falls</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">key_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;key&#38656;&#35201;&#21333;&#29420;&#20445;&#23384;,&#22240;&#20026;&#25105;&#20204;&#20351;&#29992;&#20102;prefix-compressed.</span>
  <span class="org-type">Slice</span> <span class="org-variable-name">value_</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">status_</span>;
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline254"></a>BlockIterator<br  /><div class="outline-text-5" id="text-10-8-8-1">
<p>
构造函数非常简单
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-function-name">Iter</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">comparator</span>,
     <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span>,
     <span class="org-type">uint32_t</span> <span class="org-variable-name">restarts</span>,
     <span class="org-type">uint32_t</span> <span class="org-variable-name">num_restarts</span>)
    : comparator_(comparator),
      data_(data),
      restarts_(restarts),
      num_restarts_(num_restarts),
      current_(restarts_),
      restart_index_(num_restarts_) {
  assert(num_restarts_ &gt; 0);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline255"></a>NextEntryOffset<br  /><div class="outline-text-5" id="text-10-8-8-2">
<p>
得到下一个entry的偏移.直接使用value_的偏移和大小即可计算出来
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Return the offset in data_ just past the end of the current entry.</span>
<span class="org-keyword">inline</span> <span class="org-type">uint32_t</span> <span class="org-function-name">NextEntryOffset</span>() <span class="org-keyword">const</span> {
  <span class="org-keyword">return</span> (value_.data() + value_.size()) - data_;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline256"></a>GetRestartPoint<br  /><div class="outline-text-5" id="text-10-8-8-3">
<p>
得到某个index的restart offset.这个直接访问最后的restart可以得到.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">uint32_t</span> <span class="org-function-name">GetRestartPoint</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">index</span>) {
  assert(index &lt; num_restarts_);
  <span class="org-keyword">return</span> DecodeFixed32(data_ + restarts_ + index * <span class="org-keyword">sizeof</span>(uint32_t));
}
</pre>
</div>
</div></li>

<li><a id="orgheadline257"></a>SeekToRestartPoint<br  /><div class="outline-text-5" id="text-10-8-8-4">
<p>
这个接口的语义是到某个restart point.我们需要调整restart_index_.这里value_为了可以调用NextEntryOffset.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">SeekToRestartPoint</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">index</span>) {
  key_.clear();
  restart_index_ = index;
  <span class="org-comment-delimiter">// </span><span class="org-comment">current_ will be fixed by ParseNextKey();</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">ParseNextKey() starts at the end of value_, so set value_ accordingly</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">offset</span> = GetRestartPoint(index);
  value_ = Slice(data_ + offset, 0);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline258"></a>Next<br  /><div class="outline-text-5" id="text-10-8-8-5">
<p>
Next底层调用了ParseNextKey.后面我们会仔细看看ParseNextKey.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Next</span>() {
  assert(Valid());
  ParseNextKey();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline259"></a>SeekToFirst<br  /><div class="outline-text-5" id="text-10-8-8-6">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToFirst</span>() {
  SeekToRestartPoint(0); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21040;restart0.</span>
  ParseNextKey(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#35299;&#26512;&#19979;&#19968;&#20010;&#20803;&#32032;&#21363;&#21487;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline260"></a>SeekToLast<br  /><div class="outline-text-5" id="text-10-8-8-7">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToLast</span>() {
  SeekToRestartPoint(num_restarts_ - 1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#21040;&#26368;&#21518;&#19968;&#20010;restart.</span>
  <span class="org-keyword">while</span> (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; restarts_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#19968;&#30452;&#35299;&#26512;&#21040;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Keep skipping</span>
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline261"></a>ParseNextKey<br  /><div class="outline-text-5" id="text-10-8-8-8">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">bool</span> <span class="org-function-name">ParseNextKey</span>() {
  current_ = NextEntryOffset(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#19979;&#19968;&#20010;entry offset.</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">p</span> = data_ + current_;
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">limit</span> = data_ + restarts_;  <span class="org-comment-delimiter">// </span><span class="org-comment">Restarts come right after data</span>
  <span class="org-keyword">if</span> (p &gt;= limit) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21040;&#36798;&#32467;&#23614;&#30340;&#35805;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">No more entries to return.  Mark as invalid.</span>
    current_ = restarts_;
    restart_index_ = num_restarts_;
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Decode next entry</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">shared</span>, <span class="org-variable-name">non_shared</span>, <span class="org-variable-name">value_length</span>;
  p = DecodeEntry(p, limit, &amp;shared, &amp;non_shared, &amp;value_length); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;p&#35299;&#26512;key&#20986;&#26469;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21516;&#26102;&#24212;&#35813;&#21462;&#20986;&#20102;prefix&#37096;&#20998;.</span>
  <span class="org-keyword">if</span> (p == <span class="org-constant">NULL</span> || key_.size() &lt; shared) {
    CorruptionError();
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  } <span class="org-keyword">else</span> {
    key_.resize(shared);
    key_.append(p, non_shared); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21152;&#20837;&#21518;&#38754;&#30340;&#37096;&#20998;</span>
    value_ = Slice(p + non_shared, value_length);
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#21028;&#26029;&#19979;&#19968;&#20010;restart point&#26159;&#21542;&gt;=current_.</span>
    <span class="org-keyword">while</span> (restart_index_ + 1 &lt; num_restarts_ &amp;&amp;
           GetRestartPoint(restart_index_ + 1) &lt; current_) {
      ++restart_index_; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#38656;&#35201;&#36827;&#20837;&#19979;&#19968;&#20010;restart point.</span>
    }
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline262"></a>DecodeEntry<br  /><div class="outline-text-5" id="text-10-8-8-9">
<p>
从头部decode出shared,non_shared以及value_length.这里面为了加快判断的话有一个技巧.返回的是下一个要读取的地址.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">inline</span> <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-function-name">DecodeEntry</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">p</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">limit</span>,
                                      <span class="org-type">uint32_t</span>* <span class="org-variable-name">shared</span>,
                                      <span class="org-type">uint32_t</span>* <span class="org-variable-name">non_shared</span>,
                                      <span class="org-type">uint32_t</span>* <span class="org-variable-name">value_length</span>) {
  <span class="org-keyword">if</span> (limit - p &lt; 3) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  *shared = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>*&gt;(p)[0];
  *non_shared = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>*&gt;(p)[1];
  *value_length = <span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">char</span>*&gt;(p)[2];
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#33267;&#23569;&#23384;&#22312;3&#20010;&#23383;&#33410;.&#20294;&#26159;&#22914;&#26524;&#20219;&#24847;3&#20010;&#23383;&#33410;&lt;128&#30340;&#35805;&#65292;&#34920;&#31034;&#27599;&#20010;&#37096;&#20998;&#37117;&#26159;1&#20010;&#23383;&#33410;.</span>
  <span class="org-keyword">if</span> ((*shared | *non_shared | *value_length) &lt; 128) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Fast path: all three values are encoded in one byte each</span>
    p += 3;
  } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#36825;&#20010;fast path&#30340;&#35805;&#37027;&#20040;&#20998;&#21035;&#21462;&#20986;3&#20010;&#21464;&#38271;uint32.</span>
    <span class="org-keyword">if</span> ((p = GetVarint32Ptr(p, limit, shared)) == <span class="org-constant">NULL</span>) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    <span class="org-keyword">if</span> ((p = GetVarint32Ptr(p, limit, non_shared)) == <span class="org-constant">NULL</span>) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
    <span class="org-keyword">if</span> ((p = GetVarint32Ptr(p, limit, value_length)) == <span class="org-constant">NULL</span>) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  }

  <span class="org-keyword">if</span> (<span class="org-keyword">static_cast</span>&lt;uint32_t&gt;(limit - p) &lt; (*non_shared + *value_length)) {
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
  }
  <span class="org-keyword">return</span> p;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline263"></a>Prev<br  /><div class="outline-text-5" id="text-10-8-8-10">
<p>
Prev相对于Next有一点低效.首先遍历找到restart point,然后在这个restart range里面遍历.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Prev</span>() {
  assert(Valid());

  <span class="org-comment-delimiter">// </span><span class="org-comment">Scan backwards to a restart point before current_</span>
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">original</span> = current_;
  <span class="org-keyword">while</span> (GetRestartPoint(restart_index_) &gt;= original) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#25214;&#21040;restart range.</span>
    <span class="org-keyword">if</span> (restart_index_ == 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">No more entries</span>
      current_ = restarts_;
      restart_index_ = num_restarts_;
      <span class="org-keyword">return</span>;
    }
    restart_index_--;
  }

  SeekToRestartPoint(restart_index_); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#36339;&#21040;&#36825;&#20010;restart range.</span>
  <span class="org-keyword">do</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;&#36825;&#20010;restart range&#37324;&#38754;&#36941;&#21382;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Loop until end of current entry hits the start of original entry</span>
  } <span class="org-keyword">while</span> (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; original);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline264"></a>Seek<br  /><div class="outline-text-5" id="text-10-8-8-11">
<p>
Seek非常简单，首先在restart point地方因为里面存放都是有序的完整的key.那么可以restart point
这些地方进行二分查找.然后在restart range里面通过遍历查找.还算是比较高效吧。注意这里如果没有找到的话，
返回的是第一个&gt;=target的对象.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">target</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Binary search in restart array to find the first restart point</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">with a key &gt;= target</span>
  <span class="org-type">uint32_t</span> <span class="org-variable-name">left</span> = 0;
  <span class="org-type">uint32_t</span> <span class="org-variable-name">right</span> = num_restarts_ - 1;
  <span class="org-keyword">while</span> (left &lt; right) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22312;restart&#36825;&#20123;&#37096;&#20998;&#20108;&#20998;&#26597;&#25214;.</span>
    <span class="org-type">uint32_t</span> <span class="org-variable-name">mid</span> = (left + right + 1) / 2;
    <span class="org-type">uint32_t</span> <span class="org-variable-name">region_offset</span> = GetRestartPoint(mid);
    <span class="org-type">uint32_t</span> <span class="org-variable-name">shared</span>, <span class="org-variable-name">non_shared</span>, <span class="org-variable-name">value_length</span>;
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">key_ptr</span> = DecodeEntry(data_ + region_offset,
                                      data_ + restarts_,
                                      &amp;shared, &amp;non_shared, &amp;value_length);
    <span class="org-keyword">if</span> (key_ptr == <span class="org-constant">NULL</span> || (shared != 0)) {
      CorruptionError();
      <span class="org-keyword">return</span>;
    }
    <span class="org-type">Slice</span> <span class="org-variable-name">mid_key</span>(key_ptr, non_shared);
    <span class="org-keyword">if</span> (Compare(mid_key, target) &lt; 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Key at "mid" is smaller than "target".  Therefore all</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">blocks before "mid" are uninteresting.</span>
      left = mid;
    } <span class="org-keyword">else</span> {
      <span class="org-comment-delimiter">// </span><span class="org-comment">Key at "mid" is &gt;= "target".  Therefore all blocks at or</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">after "mid" are uninteresting.</span>
      right = mid - 1;
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Linear search (within restart block) for first key &gt;= target</span>
  SeekToRestartPoint(left); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20174;&#36825;&#20010;&#37096;&#20998;&#24320;&#22987;&#36941;&#21382;&#26597;&#25214;.</span>
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ParseNextKey()) {
      <span class="org-keyword">return</span>;
    }
    <span class="org-keyword">if</span> (Compare(key_, target) &gt;= 0) {
      <span class="org-keyword">return</span>;
    }
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline268" class="outline-4">
<h4 id="orgheadline268"><span class="section-number-4">10.8.9</span> BlockHandle</h4>
<div class="outline-text-4" id="text-10-8-9">
<p>
table/format.h BlockHandle用于压缩和解压文件信息.包括两个字段offset和size.不是很麻烦
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">BlockHandle is a pointer to the extent of a file that stores a data</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">block or a meta block.</span>
<span class="org-keyword">class</span> <span class="org-type">BlockHandle</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">BlockHandle</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">The offset of the block in the file.</span>
  <span class="org-type">uint64_t</span> <span class="org-function-name">offset</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> offset_; }
  <span class="org-type">void</span> <span class="org-function-name">set_offset</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">offset</span>) { offset_ = offset; }

  <span class="org-comment-delimiter">// </span><span class="org-comment">The size of the stored block</span>
  <span class="org-type">uint64_t</span> <span class="org-function-name">size</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> size_; }
  <span class="org-type">void</span> <span class="org-function-name">set_size</span>(<span class="org-type">uint64_t</span> <span class="org-variable-name">size</span>) { size_ = size; }

  <span class="org-type">void</span> <span class="org-function-name">EncodeTo</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>) <span class="org-keyword">const</span>;
  <span class="org-type">Status</span> <span class="org-function-name">DecodeFrom</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">input</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Maximum encoding length of a BlockHandle</span>
  <span class="org-keyword">enum</span> { <span class="org-variable-name">kMaxEncodedLength</span> = 10 + 10 }; <span class="org-comment-delimiter">// </span><span class="org-comment">uint64&#26368;&#22823;&#21387;&#32553;&#22823;&#23567;&#20026;10&#23383;&#33410;.</span>

 <span class="org-keyword">private</span>:
  <span class="org-type">uint64_t</span> <span class="org-variable-name">offset_</span>;
  <span class="org-type">uint64_t</span> <span class="org-variable-name">size_</span>;
};
<span class="org-keyword">inline</span> <span class="org-constant">BlockHandle</span>::<span class="org-function-name">BlockHandle</span>()
    : offset_(~<span class="org-keyword">static_cast</span>&lt;uint64_t&gt;(0)), <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#20540;&#38750;&#24120;&#22823;.</span>
      size_(~<span class="org-keyword">static_cast</span>&lt;uint64_t&gt;(0)) {
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline266"></a>EncodeTo<br  /><div class="outline-text-5" id="text-10-8-9-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">BlockHandle</span>::<span class="org-function-name">EncodeTo</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Sanity check that all fields have been set</span>
  assert(offset_ != ~<span class="org-keyword">static_cast</span>&lt;uint64_t&gt;(0));
  assert(size_ != ~<span class="org-keyword">static_cast</span>&lt;uint64_t&gt;(0));
  PutVarint64(dst, offset_);
  PutVarint64(dst, size_);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline267"></a>DecodeFrom<br  /><div class="outline-text-5" id="text-10-8-9-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">BlockHandle</span>::<span class="org-function-name">DecodeFrom</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">input</span>) {
  <span class="org-keyword">if</span> (GetVarint64(input, &amp;offset_) &amp;&amp;
      GetVarint64(input, &amp;size_)) {
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"bad block handle"</span>);
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline271" class="outline-4">
<h4 id="orgheadline271"><span class="section-number-4">10.8.10</span> Footer</h4>
<div class="outline-text-4" id="text-10-8-10">
<p>
db/format.h Footer里面打包称为定长信息.从注释上说保存在各个table文件末尾.现在还不知道具体有什么用途.
(但是阅读完TableFormat这节之后应该知道这两个字段的含义).前面两个BlockHandle使用变长打包但是空出了MaxEncodedLength.
最后8个字节使用
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">kTableMagicNumber was picked by running</span>
<span class="org-comment-delimiter">//    </span><span class="org-comment">echo http://code.google.com/p/leveldb/ | sha1sum</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">and taking the leading 64 bits.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">kTableMagicNumber</span> = 0xdb4775248b80fb57ull;
</pre>
</div>
<p>
使用这个魔术数字比较有意思。我们来看看大致的结构.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Footer encapsulates the fixed information stored at the tail</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">end of every table file.</span>
<span class="org-keyword">class</span> <span class="org-type">Footer</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Footer</span>() { }

  <span class="org-comment-delimiter">// </span><span class="org-comment">The block handle for the metaindex block of the table</span>
  <span class="org-keyword">const</span> <span class="org-type">BlockHandle</span>&amp; <span class="org-function-name">metaindex_handle</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> metaindex_handle_; }
  <span class="org-type">void</span> <span class="org-function-name">set_metaindex_handle</span>(<span class="org-keyword">const</span> <span class="org-type">BlockHandle</span>&amp; <span class="org-variable-name">h</span>) { metaindex_handle_ = h; }

  <span class="org-comment-delimiter">// </span><span class="org-comment">The block handle for the index block of the table</span>
  <span class="org-keyword">const</span> <span class="org-type">BlockHandle</span>&amp; <span class="org-function-name">index_handle</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> index_handle_;
  }
  <span class="org-type">void</span> <span class="org-function-name">set_index_handle</span>(<span class="org-keyword">const</span> <span class="org-type">BlockHandle</span>&amp; <span class="org-variable-name">h</span>) {
    index_handle_ = h;
  }

  <span class="org-type">void</span> <span class="org-function-name">EncodeTo</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>) <span class="org-keyword">const</span>;
  <span class="org-type">Status</span> <span class="org-function-name">DecodeFrom</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">input</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Encoded length of a Footer.  Note that the serialization of a</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Footer will always occupy exactly this many bytes.  It consists</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">of two block handles and a magic number.</span>
  <span class="org-keyword">enum</span> {
    <span class="org-variable-name">kEncodedLength</span> = 2*<span class="org-constant">BlockHandle</span>::kMaxEncodedLength + 8 <span class="org-comment-delimiter">// </span><span class="org-comment">&#22266;&#23450;&#38271;&#24230;.</span>
  };

 <span class="org-keyword">private</span>:
  <span class="org-type">BlockHandle</span> <span class="org-variable-name">metaindex_handle_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">metaindex handle.</span>
  <span class="org-type">BlockHandle</span> <span class="org-variable-name">index_handle_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">index handle.</span>
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline269"></a>EncodeTo<br  /><div class="outline-text-5" id="text-10-8-10-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">Footer</span>::<span class="org-function-name">EncodeTo</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>) <span class="org-keyword">const</span> {
<span class="org-preprocessor">#if</span><span class="org-negation-char"><span class="org-preprocessor">n</span></span><span class="org-preprocessor">def</span> NDEBUG
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">original_size</span> = dst-&gt;size();
<span class="org-preprocessor">#endif</span>
  metaindex_handle_.EncodeTo(dst);
  index_handle_.EncodeTo(dst);
  dst-&gt;resize(2 * <span class="org-constant">BlockHandle</span>::kMaxEncodedLength);  <span class="org-comment-delimiter">// </span><span class="org-comment">Padding</span>
  PutFixed32(dst, <span class="org-keyword">static_cast</span>&lt;uint32_t&gt;(kTableMagicNumber &amp; 0xffffffffu));
  PutFixed32(dst, <span class="org-keyword">static_cast</span>&lt;uint32_t&gt;(kTableMagicNumber &gt;&gt; 32));
  assert(dst-&gt;size() == original_size + kEncodedLength);
}
</pre>
</div>
</div></li>

<li><a id="orgheadline270"></a>DecodeFrom<br  /><div class="outline-text-5" id="text-10-8-10-2">
<p>
这里input作为输入，头部是EncodeTo的内容后面可能带有其他数据。解析完成之后将剩余返回给input.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-constant">Footer</span>::<span class="org-function-name">DecodeFrom</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">input</span>) {
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">magic_ptr</span> = input-&gt;data() + kEncodedLength - 8;
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">magic_lo</span> = DecodeFixed32(magic_ptr);
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">magic_hi</span> = DecodeFixed32(magic_ptr + 4);
  <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">magic</span> = ((<span class="org-keyword">static_cast</span>&lt;uint64_t&gt;(magic_hi) &lt;&lt; 32) |
                          (<span class="org-keyword">static_cast</span>&lt;uint64_t&gt;(magic_lo)));
  <span class="org-keyword">if</span> (magic != kTableMagicNumber) {
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::InvalidArgument(<span class="org-string">"not an sstable (bad magic number)"</span>);
  }

  <span class="org-type">Status</span> <span class="org-variable-name">result</span> = metaindex_handle_.DecodeFrom(input);
  <span class="org-keyword">if</span> (result.ok()) {
    result = index_handle_.DecodeFrom(input);
  }
  <span class="org-keyword">if</span> (result.ok()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">We skip over any leftover data (just padding for now) in "input"</span>
    <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">end</span> = magic_ptr + 8;
    *input = Slice(end, input-&gt;data() + input-&gt;size() - end);
  }
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline272" class="outline-4">
<h4 id="orgheadline272"><span class="section-number-4">10.8.11</span> ReadBlock</h4>
<div class="outline-text-4" id="text-10-8-11">
<p>
table/format.cc ReadBlock应该是从随机文件里面读取Block出来.对于这个Block的位置的话由handle提供.
注意每个Block后面还有crc和type.这个可以参考TableBuilder实现。然后将读取的Block二进制构造Block对象返回。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">1-byte type + 32-bit crc</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">type&#34920;&#31034;&#20351;&#29992;&#20160;&#20040;&#21387;&#32553;&#26041;&#24335;.</span>
<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">kBlockTrailerSize</span> = 5;
</pre>
</div>

<p>
下面看看具体实现代码
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Status</span> <span class="org-function-name">ReadBlock</span>(<span class="org-type">RandomAccessFile</span>* <span class="org-variable-name">file</span>,
                 <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
                 <span class="org-keyword">const</span> <span class="org-type">BlockHandle</span>&amp; <span class="org-variable-name">handle</span>,
                 <span class="org-type">Block</span>** <span class="org-variable-name">block</span>) {
  *block = <span class="org-constant">NULL</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Read the block contents as well as the type/crc footer.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">See table_builder.cc for the code that built this structure.</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">n</span> = <span class="org-keyword">static_cast</span>&lt;size_t&gt;(handle.size());
  <span class="org-type">char</span>* <span class="org-variable-name">buf</span> = <span class="org-keyword">new</span> <span class="org-type">char</span>[n + kBlockTrailerSize];
  <span class="org-type">Slice</span> <span class="org-variable-name">contents</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">s</span> = file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>s.ok()) {
    <span class="org-keyword">delete</span>[] buf;
    <span class="org-keyword">return</span> s;
  }
  <span class="org-keyword">if</span> (contents.size() != n + kBlockTrailerSize) {
    <span class="org-keyword">delete</span>[] buf;
    <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"truncated block read"</span>);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26657;&#39564;CRC32C</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Check the crc of the type and the block contents</span>
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span> = contents.data();    <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer to where Read put the data</span>
  <span class="org-keyword">if</span> (options.verify_checksums) {
    <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">crc</span> = <span class="org-constant">crc32c</span>::Unmask(DecodeFixed32(data + n + 1));
    <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">actual</span> = <span class="org-constant">crc32c</span>::Value(data, n + 1);
    <span class="org-keyword">if</span> (actual != crc) {
      <span class="org-keyword">delete</span>[] buf;
      s = <span class="org-constant">Status</span>::Corruption(<span class="org-string">"block checksum mismatch"</span>);
      <span class="org-keyword">return</span> s;
    }
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#26681;&#25454;type&#21028;&#26029;&#20351;&#29992;&#20160;&#20040;&#21387;&#32553;&#26041;&#24335;.</span>
  <span class="org-keyword">switch</span> (data[n]) {
    <span class="org-keyword">case</span> kNoCompression:
      <span class="org-keyword">if</span> (data != buf) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">File implementation gave us pointer to some other data.</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">Copy into buf[].</span>
        memcpy(buf, data, n + kBlockTrailerSize);
      }

      <span class="org-comment-delimiter">// </span><span class="org-comment">Ok</span>
      <span class="org-keyword">break</span>;
    <span class="org-keyword">case</span> kSnappyCompression: {
      <span class="org-comment-delimiter">// </span><span class="org-comment">... // &#36825;&#37324;&#25105;&#25925;&#24847;&#30465;&#21435;&#20102;.&#25105;&#20204;&#36825;&#37324;&#26242;&#26102;&#19981;&#20851;&#31995;&#36825;&#20010;&#36923;&#36753;</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;Snappy&#26469;&#35299;&#21387;&#32553;.</span>
      <span class="org-keyword">break</span>;
    }
    <span class="org-keyword">default</span>:
      <span class="org-keyword">delete</span>[] buf;
      <span class="org-keyword">return</span> <span class="org-constant">Status</span>::Corruption(<span class="org-string">"bad block type"</span>);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36820;&#22238;Block&#23545;&#35937;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Block&#23545;&#35937;&#21487;&#20197;&#36890;&#36807;&#36845;&#20195;&#22120;&#26469;&#36827;&#34892;&#35775;&#38382;.</span>
  *block = <span class="org-keyword">new</span> <span class="org-type">Block</span>(buf, n);  <span class="org-comment-delimiter">// </span><span class="org-comment">Block takes ownership of buf[]</span>
  <span class="org-keyword">return</span> <span class="org-constant">Status</span>::OK();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline273" class="outline-4">
<h4 id="orgheadline273"><span class="section-number-4">10.8.12</span> IteratorWrapper</h4>
<div class="outline-text-4" id="text-10-8-12">
<p>
table/iterator_wrapper.h IteratorWrapper就是Iterator的装饰者。对于Valid,Key进行了缓存.
这个其实还是比较有必要的.因为有些iterator取key和valid代价比较大.不过似乎对于虚函数没有节省开销，
因为内部存放的还是Iterator对象而不是模板。阅读完了TwoLevelIterator就会发现，这个类存在原因，
主要是为了管理Iterator对象的管理。比如Set的时候会将原来的Iterator对象释放，析构函数会将持有的Iterator释放。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">A internal wrapper class with an interface similar to Iterator that</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">caches the valid() and key() results for an underlying iterator.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">This can help avoid virtual function calls and also gives better</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">cache locality.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline274" class="outline-4">
<h4 id="orgheadline274"><span class="section-number-4">10.8.13</span> EmptyIterator</h4>
<div class="outline-text-4" id="text-10-8-13">
<p>
EmptyIterator用来构造返回错误或者是空的Iterator.提供了两个函数
</p>
<ul class="org-ul">
<li>NewEmptyIterator</li>
<li>NewErrorIterator</li>
</ul>
<p>
来进行构造。具体实现放在了table/iterator.cc里面
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">EmptyIterator</span> : <span class="org-keyword">public</span> <span class="org-type">Iterator</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">EmptyIterator</span>(<span class="org-keyword">const</span> <span class="org-type">Status</span>&amp; <span class="org-variable-name">s</span>) : status_(s) { }
  <span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">Valid</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> <span class="org-constant">false</span>; }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">target</span>) { }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToFirst</span>() { }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToLast</span>() { }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Next</span>() { assert(<span class="org-constant">false</span>); }
  <span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Prev</span>() { assert(<span class="org-constant">false</span>); }
  <span class="org-type">Slice</span> <span class="org-function-name">key</span>() <span class="org-keyword">const</span> { assert(<span class="org-constant">false</span>); <span class="org-keyword">return</span> Slice(); }
  <span class="org-type">Slice</span> <span class="org-function-name">value</span>() <span class="org-keyword">const</span> { assert(<span class="org-constant">false</span>); <span class="org-keyword">return</span> Slice(); }
  <span class="org-keyword">virtual</span> <span class="org-type">Status</span> <span class="org-function-name">status</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> status_; }
 <span class="org-keyword">private</span>:
  <span class="org-type">Status</span> <span class="org-variable-name">status_</span>;
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline285" class="outline-4">
<h4 id="orgheadline285"><span class="section-number-4">10.8.14</span> TwoLevelIterator</h4>
<div class="outline-text-4" id="text-10-8-14">
<p>
table/two_level_iterator.h TwoLevelIterator是一个二级Iterator配合sstable二级索引文件使用的。
通过工厂方法来进行构造所以接口非常简单。主要还是看TwoLevelIterator里面的实现。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Return a new two level iterator.  A two-level iterator contains an</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">index iterator whose values point to a sequence of blocks where</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">each block is itself a sequence of key,value pairs.  The returned</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">two-level iterator yields the concatenation of all key/value pairs</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">in the sequence of blocks.  Takes ownership of "index_iter" and</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">will delete it when no longer needed.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Uses a supplied function to convert an index_iter value into</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">an iterator over the contents of the corresponding block.</span>
<span class="org-keyword">extern</span> <span class="org-type">Iterator</span>* <span class="org-function-name">NewTwoLevelIterator</span>(
    <span class="org-type">Iterator</span>* <span class="org-variable-name">index_iter</span>, <span class="org-comment-delimiter">// </span><span class="org-comment">index block iterator.</span>
    <span class="org-type">Iterator</span>* (*<span class="org-variable-name">block_function</span>)(
        <span class="org-type">void</span>* <span class="org-variable-name">arg</span>,
        <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>,
        <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">index_value</span>),
    <span class="org-type">void</span>* <span class="org-variable-name">arg</span>,
    <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>);
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline275"></a>NewTwoLevelIterator<br  /><div class="outline-text-5" id="text-10-8-14-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">Iterator</span>* <span class="org-function-name">NewTwoLevelIterator</span>(
    <span class="org-type">Iterator</span>* <span class="org-variable-name">index_iter</span>,
    <span class="org-type">BlockFunction</span> <span class="org-variable-name">block_function</span>,
    <span class="org-type">void</span>* <span class="org-variable-name">arg</span>,
    <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#38750;&#24120;&#31616;&#21333;&#23601;&#26159;&#21019;&#24314;&#23545;&#35937;.</span>
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">TwoLevelIterator</span>(index_iter, block_function, arg, options);
}
</pre>
</div>

<p>
然后我们看看TwoLevelIterator的结构以及构造函数实现。接下来我们看看几个主要的接口。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">typedef</span> <span class="org-type">Iterator</span>* (*<span class="org-type">BlockFunction</span>)(<span class="org-type">void</span>*, <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp;, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp;);

<span class="org-keyword">class</span> <span class="org-type">TwoLevelIterator</span>: <span class="org-keyword">public</span> <span class="org-type">Iterator</span> {
 <span class="org-keyword">private</span>:
  <span class="org-type">BlockFunction</span> <span class="org-variable-name">block_function_</span>;
  <span class="org-type">void</span>* <span class="org-variable-name">arg_</span>;
  <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span> <span class="org-variable-name">options_</span>;
  <span class="org-type">Status</span> <span class="org-variable-name">status_</span>;
  <span class="org-type">IteratorWrapper</span> <span class="org-variable-name">index_iter_</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;key,value&#36825;&#26679;&#30340;&#26041;&#27861;&#30452;&#25509;&#32473;data_iter_&#20195;&#29702;&#21363;&#21487;.</span>
  <span class="org-type">IteratorWrapper</span> <span class="org-variable-name">data_iter_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">May be NULL</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If data_iter_ is non-NULL, then "data_block_handle_" holds the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">"index_value" passed to block_function_ to create the data_iter_.</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">data_block_handle_</span>;
};

<span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">TwoLevelIterator</span>(
    <span class="org-type">Iterator</span>* <span class="org-variable-name">index_iter</span>,
    <span class="org-type">BlockFunction</span> <span class="org-variable-name">block_function</span>,
    <span class="org-type">void</span>* <span class="org-variable-name">arg</span>,
    <span class="org-keyword">const</span> <span class="org-type">ReadOptions</span>&amp; <span class="org-variable-name">options</span>)
    : block_function_(block_function),
      arg_(arg),
      options_(options),
      index_iter_(index_iter),
      data_iter_(<span class="org-constant">NULL</span>) {
}
</pre>
</div>
</div></li>

<li><a id="orgheadline276"></a>Seek<br  /><div class="outline-text-5" id="text-10-8-14-2">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">target</span>) {
  index_iter_.Seek(target); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;&#36890;&#36807;index iter&#36827;&#34892;&#23450;&#20301;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#21487;&#33021;&#27809;&#26377;&#25214;&#21040;&#12290;BlockIterator::Seek&#34892;&#20026;&#26159;&#25214;&#21040;&gt;=target&#23545;&#35937;.</span>
  InitDataBlock(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21021;&#22987;&#21270;data_iter.</span>
  <span class="org-keyword">if</span> (data_iter_.iter() != <span class="org-constant">NULL</span>) data_iter_.Seek(target); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20351;&#29992;data_iter&#23450;&#20301;.</span>
  SkipEmptyDataBlocksForward(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#21069;&#30053;&#36807;&#31354;&#30333;&#35760;&#24405;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline277"></a>SeekToFirst<br  /><div class="outline-text-5" id="text-10-8-14-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">SeekToFirst</span>() {
  index_iter_.SeekToFirst(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;index inter.</span>
  InitDataBlock();
  <span class="org-keyword">if</span> (data_iter_.iter() != <span class="org-constant">NULL</span>) data_iter_.SeekToFirst(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;data iter.</span>
  SkipEmptyDataBlocksForward(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#21069;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline278"></a>SeekToLast<br  /><div class="outline-text-5" id="text-10-8-14-4">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">SeekToLast</span>() {
  index_iter_.SeekToLast(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#39318;&#20808;index iter.</span>
  InitDataBlock();
  <span class="org-keyword">if</span> (data_iter_.iter() != <span class="org-constant">NULL</span>) data_iter_.SeekToLast(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;data iter.</span>
  SkipEmptyDataBlocksBackward(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#21518;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline279"></a>Next<br  /><div class="outline-text-5" id="text-10-8-14-5">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">Next</span>() {
  assert(Valid());
  data_iter_.Next();
  SkipEmptyDataBlocksForward(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#21069;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.&#36825;&#20010;&#37096;&#20998;&#21487;&#33021;&#38656;&#35201;&#32771;&#34385;data_iter_&#22833;&#25928;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline280"></a>Prev<br  /><div class="outline-text-5" id="text-10-8-14-6">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">Prev</span>() {
  assert(Valid());
  data_iter_.Prev();
  SkipEmptyDataBlocksBackward(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21521;&#21518;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.&#36825;&#20010;&#37096;&#20998;&#21487;&#33021;&#38656;&#35201;&#32771;&#34385;data_iter_&#22833;&#25928;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline281"></a>InitDataBlock<br  /><div class="outline-text-5" id="text-10-8-14-7">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">InitDataBlock</span>() {
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>index_iter_.Valid()) {
    SetDataIterator(<span class="org-constant">NULL</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;index_iter&#24050;&#32463;&#22833;&#25928;&#30340;&#35805;.</span>
  } <span class="org-keyword">else</span> {
    <span class="org-type">Slice</span> <span class="org-variable-name">handle</span> = index_iter_.value();
    <span class="org-keyword">if</span> (data_iter_.iter() != <span class="org-constant">NULL</span> &amp;&amp; handle.compare(data_block_handle_) == 0) {
      <span class="org-comment-delimiter">// </span><span class="org-comment">data_iter_ is already constructed with this iterator, so</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">no need to change anything</span>
    } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#35843;&#29992;block_function&#26469;&#35835;&#21462;&#20855;&#20307;&#30340;data block.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#21487;&#20197;&#30475;&#21040;,block_function&#30340;&#29992;&#36884;&#23601;&#26159;&#35835;&#21462;handle</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#20854;&#20013;handle&#37324;&#38754;&#26159;&#23545;&#24212;data block&#25152;&#22312;&#30340;&#20301;&#32622;&#12290;</span>
      <span class="org-type">Iterator</span>* <span class="org-variable-name">iter</span> = (*block_function_)(arg_, options_, handle);
      <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;data block handle.:).</span>
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline282"></a>SetDataIterator<br  /><div class="outline-text-5" id="text-10-8-14-8">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">SetDataIterator</span>(<span class="org-type">Iterator</span>* <span class="org-variable-name">data_iter</span>) {
  <span class="org-keyword">if</span> (data_iter_.iter() != <span class="org-constant">NULL</span>) SaveError(data_iter_.status());
  data_iter_.Set(data_iter); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;IteratorWrapper&#36827;&#34892;Set&#30340;&#35805;&#21407;&#26469;&#20250;&#37322;&#25918;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#20063;&#35299;&#37322;&#20102;&#20026;&#20160;&#20040;&#25105;&#20204;&#38656;&#35201;IteratorWrapper&#23545;&#35937;&#23384;&#22312;.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline283"></a>SkipEmptyDataBlocksForward<br  /><div class="outline-text-5" id="text-10-8-14-9">
<p>
对于空的DataBlock的话那么!data_iter_.Valid().对于空的DataBlock可以跳过IndexBlock快速跨越。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">SkipEmptyDataBlocksForward</span>() {
  <span class="org-keyword">while</span> (data_iter_.iter() == <span class="org-constant">NULL</span> || <span class="org-negation-char">!</span>data_iter_.Valid()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Move to next block</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>index_iter_.Valid()) {
      SetDataIterator(<span class="org-constant">NULL</span>);
      <span class="org-keyword">return</span>;
    }
    index_iter_.Next();
    InitDataBlock();
    <span class="org-keyword">if</span> (data_iter_.iter() != <span class="org-constant">NULL</span>) data_iter_.SeekToFirst();
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline284"></a>SkipEmptyDataBlocksBackward<br  /><div class="outline-text-5" id="text-10-8-14-10">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">TwoLevelIterator</span>::<span class="org-function-name">SkipEmptyDataBlocksBackward</span>() {
  <span class="org-keyword">while</span> (data_iter_.iter() == <span class="org-constant">NULL</span> || <span class="org-negation-char">!</span>data_iter_.Valid()) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Move to next block</span>
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>index_iter_.Valid()) {
      SetDataIterator(<span class="org-constant">NULL</span>);
      <span class="org-keyword">return</span>;
    }
    index_iter_.Prev();
    InitDataBlock();
    <span class="org-keyword">if</span> (data_iter_.iter() != <span class="org-constant">NULL</span>) data_iter_.SeekToLast();
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline297" class="outline-4">
<h4 id="orgheadline297"><span class="section-number-4">10.8.15</span> MergingIterator</h4>
<div class="outline-text-4" id="text-10-8-15">
<p>
table/merger.cc 可以认为这个是一个Iterator的多路归并实现。但是巧妙的是将多路Iterator
归并称为一个Iterator进行遍历。从注释上面可以看到对于key不会进行去重。依然是一个工厂方法。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Return an iterator that provided the union of the data in</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">children[0,n-1].  Takes ownership of the child iterators and</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">will delete them when the result iterator is deleted.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">The result does no duplicate suppression.  I.e., if a particular</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">key is present in K child iterators, it will be yielded K times.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: n &gt;= 0</span>
<span class="org-keyword">extern</span> <span class="org-type">Iterator</span>* <span class="org-function-name">NewMergingIterator</span>(
    <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">comparator</span>, <span class="org-type">Iterator</span>** <span class="org-variable-name">children</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>);
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline286"></a>NewMergingIterator<br  /><div class="outline-text-5" id="text-10-8-15-1">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#25105;&#20204;&#38656;&#35201;&#25176;&#31649;list&#37324;&#38754;&#30340;Iterator&#23545;&#35937;.</span>
<span class="org-type">Iterator</span>* <span class="org-function-name">NewMergingIterator</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">cmp</span>, <span class="org-type">Iterator</span>** <span class="org-variable-name">list</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>) {
  assert(n &gt;= 0);
  <span class="org-keyword">if</span> (n == 0) {
    <span class="org-keyword">return</span> NewEmptyIterator(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;n==0&#37027;&#20040;&#26159;empty iterator.</span>
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (n == 1) {
    <span class="org-keyword">return</span> list[0]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;n==1&#30340;&#35805;&#37027;&#20040;&#21482;&#38656;&#35201;&#36820;&#22238;&#31532;&#19968;&#20010;&#21363;&#21487;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">&#36825;&#37324;&#24182;&#27809;&#26377;&#38382;&#39064;&#22240;&#20026;&#25105;&#20204;&#26368;&#21518;&#20250;&#30452;&#25509;delete&#36825;&#20010;&#23545;&#35937;&#30340;&#12290;</span>
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">MergingIterator</span>(cmp, list, n); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#23601;&#38656;&#35201;&#36827;&#34892;&#21512;&#24182;.</span>
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline287"></a>MergingIterator<br  /><div class="outline-text-5" id="text-10-8-15-2">
<p>
首先看看结构以及构造和析构函数.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">MergingIterator</span> : <span class="org-keyword">public</span> <span class="org-type">Iterator</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">MergingIterator</span>(<span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">comparator</span>, <span class="org-type">Iterator</span>** <span class="org-variable-name">children</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>)
      : comparator_(comparator),
        children_(<span class="org-keyword">new</span> <span class="org-type">IteratorWrapper</span>[n]),
        n_(n),
        current_(<span class="org-constant">NULL</span>),
        direction_(kForward) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++) {
      children_[i].Set(children[i]);
    }
  }

  <span class="org-keyword">virtual</span> ~<span class="org-function-name">MergingIterator</span>() {
    <span class="org-keyword">delete</span>[] children_;
  }

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">We might want to use a heap in case there are lots of children.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">For now we use a simple array since we expect a very small number</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">of children in leveldb.</span>
  <span class="org-keyword">const</span> <span class="org-type">Comparator</span>* <span class="org-variable-name">comparator_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27604;&#36739;&#22120;.</span>
  <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">children_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22810;&#36335;Iterator.</span>
  <span class="org-type">int</span> <span class="org-variable-name">n_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22810;&#23569;&#36335;.</span>
  <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">current_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;Iterator.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Which direction is the iterator moving?</span>
  <span class="org-keyword">enum</span> <span class="org-type">Direction</span> {
    <span class="org-variable-name">kForward</span>,
    <span class="org-variable-name">kReverse</span>
  };
  <span class="org-type">Direction</span> <span class="org-variable-name">direction_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#26041;&#21521;.</span>
};
</pre>
</div>
</div></li>

<li><a id="orgheadline288"></a>Key<br  /><div class="outline-text-5" id="text-10-8-15-3">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">Slice</span> <span class="org-function-name">key</span>() <span class="org-keyword">const</span> {
  assert(Valid());
  <span class="org-keyword">return</span> current_-&gt;key();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline289"></a>Value<br  /><div class="outline-text-5" id="text-10-8-15-4">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">Slice</span> <span class="org-function-name">value</span>() <span class="org-keyword">const</span> {
  assert(Valid());
  <span class="org-keyword">return</span> current_-&gt;value();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline290"></a>Seek<br  /><div class="outline-text-5" id="text-10-8-15-5">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">target</span>) {
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n_; i++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#20010;children&#37117;seek&#21040;&#36825;&#20010;target.</span>
    children_[i].Seek(target);
  }
  FindSmallest(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#23545;&#27604;&#19968;&#19979;&#26368;&#23567;&#30340;&#23545;&#35937;.&#35774;&#32622;&#20026;current.</span>
  direction_ = kForward; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35774;&#32622;&#19968;&#19979;&#26041;&#21521;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;Key,Value&#30340;&#35805;&#35843;&#29992;current&#36825;&#20010;Iterator.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline291"></a>SeekToFirst<br  /><div class="outline-text-5" id="text-10-8-15-6">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToFirst</span>() {
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n_; i++) {
    children_[i].SeekToFirst();
  }
  FindSmallest();
  direction_ = kForward;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline292"></a>SeekToLast<br  /><div class="outline-text-5" id="text-10-8-15-7">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">SeekToLast</span>() {
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n_; i++) {
    children_[i].SeekToLast();
  }
  FindLargest(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#25214;&#21040;&#26368;&#22823;&#30340;&#20316;&#20026;current_.</span>
  direction_ = kReverse;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline293"></a>Next<br  /><div class="outline-text-5" id="text-10-8-15-8">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Next</span>() {
  assert(Valid());

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;&#27491;&#26041;&#21521;&#30340;&#35805;.&#19981;&#36807;&#35273;&#24471;&#36825;&#20010;&#37096;&#20998;&#20195;&#30721;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36807;&#20063;&#27809;&#26377;&#26356;&#22909;&#30340;&#35299;&#20915;&#21150;&#27861;&#20102;&#12290;&#25105;&#35273;&#24471;&#36825;&#37324;&#30452;&#25509;assert&#23601;&#22909;&#20102;&#65292;&#19981;&#38656;&#35201;&#35843;&#25972;&#12290;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ensure that all children are positioned after key().</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If we are moving in the forward direction, it is already</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">true for all of the non-current_ children since current_ is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the smallest child and key() == current_-&gt;key().  Otherwise,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we explicitly position the non-current_ children.</span>
  <span class="org-keyword">if</span> (direction_ != kForward) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n_; i++) {
      <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">child</span> = &amp;children_[i];
      <span class="org-keyword">if</span> (child != current_) {
        child-&gt;Seek(key());
        <span class="org-keyword">if</span> (child-&gt;Valid() &amp;&amp;
            comparator_-&gt;Compare(key(), child-&gt;key()) == 0) {
          child-&gt;Next();
        }
      }
    }
    direction_ = kForward;
  }
  current_-&gt;Next();
  FindSmallest();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline294"></a>Prev<br  /><div class="outline-text-5" id="text-10-8-15-9">
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">Prev</span>() {
  assert(Valid());

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#19981;&#26159;&#21453;&#26041;&#21521;&#30340;&#35805;.&#19981;&#36807;&#35273;&#24471;&#36825;&#20010;&#37096;&#20998;&#20195;&#30721;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#19981;&#36807;&#20063;&#27809;&#26377;&#26356;&#22909;&#30340;&#35299;&#20915;&#21150;&#27861;&#20102;&#12290;&#25105;&#35273;&#24471;&#36825;&#37324;&#30452;&#25509;assert&#23601;&#22909;&#20102;&#65292;&#26681;&#26412;&#19981;&#38656;&#35201;&#35843;&#25972;&#12290;</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Ensure that all children are positioned before key().</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If we are moving in the reverse direction, it is already</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">true for all of the non-current_ children since current_ is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the largest child and key() == current_-&gt;key().  Otherwise,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">we explicitly position the non-current_ children.</span>
  <span class="org-keyword">if</span> (direction_ != kReverse) {
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n_; i++) {
      <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">child</span> = &amp;children_[i];
      <span class="org-keyword">if</span> (child != current_) {
        child-&gt;Seek(key());
        <span class="org-keyword">if</span> (child-&gt;Valid()) {
          <span class="org-comment-delimiter">// </span><span class="org-comment">Child is at first entry &gt;= key().  Step back one to be &lt; key()</span>
          child-&gt;Prev();
        } <span class="org-keyword">else</span> {
          <span class="org-comment-delimiter">// </span><span class="org-comment">Child has no entries &gt;= key().  Position at last entry.</span>
          child-&gt;SeekToLast();
        }
      }
    }
    direction_ = kReverse;
  }

  current_-&gt;Prev();
  FindLargest();
}
</pre>
</div>
</div></li>

<li><a id="orgheadline295"></a>FindSmallest<br  /><div class="outline-text-5" id="text-10-8-15-10">
<p>
从这些Iterator找到最小的Iterator作为current.算法naive.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">MergingIterator</span>::<span class="org-function-name">FindSmallest</span>() {
  <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">smallest</span> = <span class="org-constant">NULL</span>;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; n_; i++) {
    <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">child</span> = &amp;children_[i];
    <span class="org-keyword">if</span> (child-&gt;Valid()) {
      <span class="org-keyword">if</span> (smallest == <span class="org-constant">NULL</span>) {
        smallest = child;
      } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (comparator_-&gt;Compare(child-&gt;key(), smallest-&gt;key()) &lt; 0) {
        smallest = child;
      }
    }
  }
  current_ = smallest;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline296"></a>FindLargest<br  /><div class="outline-text-5" id="text-10-8-15-11">
<p>
从这些Iterator里面找到最大的Iterator作为current.算法naive.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-constant">MergingIterator</span>::<span class="org-function-name">FindLargest</span>() {
  <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">largest</span> = <span class="org-constant">NULL</span>;
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = n_-1; i &gt;= 0; i--) {
    <span class="org-type">IteratorWrapper</span>* <span class="org-variable-name">child</span> = &amp;children_[i];
    <span class="org-keyword">if</span> (child-&gt;Valid()) {
      <span class="org-keyword">if</span> (largest == <span class="org-constant">NULL</span>) {
        largest = child;
      } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (comparator_-&gt;Compare(child-&gt;key(), largest-&gt;key()) &gt; 0) {
        largest = child;
      }
    }
  }
  current_ = largest;
}
</pre>
</div>
</div></li></ol>
</div>
</div>

<div id="outline-container-orgheadline317" class="outline-3">
<h3 id="orgheadline317"><span class="section-number-3">10.9</span> Util</h3>
<div class="outline-text-3" id="text-10-9">
</div><div id="outline-container-orgheadline299" class="outline-4">
<h4 id="orgheadline299"><span class="section-number-4">10.9.1</span> Arena</h4>
<div class="outline-text-4" id="text-10-9-1">
<p>
util/arena.h[.cc] arena作为一个局部,对于逻辑来说存在生命周期的内存分配器.所有的内存都在这上面分配然后一次性释放.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">class</span> <span class="org-type">Arena</span> {
 <span class="org-keyword">public</span>:
  <span class="org-function-name">Arena</span>();
  ~<span class="org-function-name">Arena</span>();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return a pointer to a newly allocated memory block of "bytes" bytes.</span>
  <span class="org-type">char</span>* <span class="org-function-name">Allocate</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Allocate memory with the normal alignment guarantees provided by malloc</span>
  <span class="org-type">char</span>* <span class="org-function-name">AllocateAligned</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns an estimate of the total memory usage of data allocated</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">by the arena (including space allocated but not yet used for user</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">allocations).</span>
  <span class="org-type">size_t</span> <span class="org-function-name">MemoryUsage</span>() <span class="org-keyword">const</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#20998;&#37197;&#20869;&#23384;&#20197;&#21450;std::vector&#20998;&#37197;&#20869;&#23384;.</span>
    <span class="org-keyword">return</span> blocks_memory_ + blocks_.capacity() * <span class="org-keyword">sizeof</span>(<span class="org-type">char</span>*);
  }

 <span class="org-keyword">private</span>:
  <span class="org-type">char</span>* <span class="org-function-name">AllocateFallback</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#24403;&#21069;&#30340;block&#19981;&#22815;&#20998;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;new&#19968;&#20010;&#26032;&#30340;block.</span>
  <span class="org-type">char</span>* <span class="org-function-name">AllocateNewBlock</span>(<span class="org-type">size_t</span> <span class="org-variable-name">block_bytes</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">new&#26032;&#30340;block&#36923;&#36753;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Allocation state</span>
  <span class="org-type">char</span>* <span class="org-variable-name">alloc_ptr_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#20801;&#35768;&#20998;&#37197;&#30340;ptr</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">alloc_bytes_remaining_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#36824;&#26377;&#36830;&#32493;&#20869;&#23384;&#22320;&#22336;&#36824;&#26377;&#22810;&#23569;&#27809;&#26377;&#20998;&#37197;&#25481;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Array of new[] allocated memory blocks</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">char</span>*&gt; <span class="org-variable-name">blocks_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#29616;&#22312;&#20998;&#37197;&#20102;&#22810;&#23569;&#36830;&#32493;&#20869;&#23384;&#22320;&#22336;</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Bytes of memory in blocks allocated so far</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">blocks_memory_</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#20998;&#37197;&#20102;&#22810;&#23569;&#20869;&#23384;.</span>
};
</pre>
</div>
<p>
阅读完了这个接口基本上就能够猜想到怎么实现了.都是基于sample方式的内存分配,每次分配固定大小的block
然后在上面不断地进行切分。但是这里必须确保block内存大小足够大，不然不能够正常分配内存.
(#note: 不过阅读了后面实现，发现如果超过block的话按照本身大小分配，不会存在问题).
</p>

<p>
还是稍微看看实现吧
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">inline</span> <span class="org-type">char</span>* <span class="org-constant">Arena</span>::<span class="org-function-name">Allocate</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">The semantics of what to return are a bit messy if we allow</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">0-byte allocations, so we disallow them here (we don't need</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">them for our internal use).</span>
  assert(bytes &gt; 0);
  <span class="org-keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#30475;&#24403;&#21069;&#26159;&#21542;&#21487;&#20197;&#20998;&#37197;.</span>
    <span class="org-type">char</span>* <span class="org-variable-name">result</span> = alloc_ptr_;
    alloc_ptr_ += bytes;
    alloc_bytes_remaining_ -= bytes;
    <span class="org-keyword">return</span> result;
  }
  <span class="org-keyword">return</span> AllocateFallback(bytes);
}

<span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">kBlockSize</span> = 4096; <span class="org-comment-delimiter">// </span><span class="org-comment">block size&#26159;4K.</span>

<span class="org-constant">Arena</span>::<span class="org-function-name">Arena</span>() {
  blocks_memory_ = 0;
  alloc_ptr_ = <span class="org-constant">NULL</span>;  <span class="org-comment-delimiter">// </span><span class="org-comment">First allocation will allocate a block</span>
  alloc_bytes_remaining_ = 0;
}

<span class="org-constant">Arena</span>::~<span class="org-function-name">Arena</span>() {
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; blocks_.size(); i++) {
    <span class="org-keyword">delete</span>[] blocks_[i];
  }
}

<span class="org-type">char</span>* <span class="org-constant">Arena</span>::<span class="org-function-name">AllocateFallback</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>) {
  <span class="org-keyword">if</span> (bytes &gt; kBlockSize / 4) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#20998;&#37197;&#36229;&#36807;1K.&#37027;&#20040;&#30452;&#25509;&#20998;&#37197;&#21344;&#29992;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Object is more than a quarter of our block size.  Allocate it separately</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">to avoid wasting too much space in leftover bytes.</span>
    <span class="org-type">char</span>* <span class="org-variable-name">result</span> = AllocateNewBlock(bytes);
    <span class="org-keyword">return</span> result;
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">We waste the remaining space in the current block.</span>
  alloc_ptr_ = AllocateNewBlock(kBlockSize); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;&#20250;&#20998;&#37197;&#20986;&#26469;&#28982;&#21518;&#22312;&#36825;&#19978;&#38754;&#36827;&#34892;&#20999;&#20998;.</span>
  alloc_bytes_remaining_ = kBlockSize;

  <span class="org-type">char</span>* <span class="org-variable-name">result</span> = alloc_ptr_;
  alloc_ptr_ += bytes;
  alloc_bytes_remaining_ -= bytes;
  <span class="org-keyword">return</span> result;
}

<span class="org-type">char</span>* <span class="org-constant">Arena</span>::<span class="org-function-name">AllocateAligned</span>(<span class="org-type">size_t</span> <span class="org-variable-name">bytes</span>) {
  <span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">align</span> = <span class="org-keyword">sizeof</span>(<span class="org-type">void</span>*);    <span class="org-comment-delimiter">// </span><span class="org-comment">We'll align to pointer size</span>
  assert((align &amp; (align-1)) == 0);   <span class="org-comment-delimiter">// </span><span class="org-comment">Pointer size should be a power of 2</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">current_mod</span> = <span class="org-keyword">reinterpret_cast</span>&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align-1); <span class="org-comment-delimiter">// </span><span class="org-comment">&#38656;&#35201;&#32771;&#34385;&#24403;&#21069;&#22320;&#22336;&#26159;&#21542;&#23545;&#20854;.</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">slop</span> = (current_mod == 0 ? 0 : align - current_mod);
  <span class="org-type">size_t</span> <span class="org-variable-name">needed</span> = bytes + slop; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#23545;&#40784;&#25105;&#20204;&#21487;&#33021;&#38656;&#35201;&#20570;&#30340;&#20559;&#31227;.</span>
  <span class="org-type">char</span>* <span class="org-variable-name">result</span>;
  <span class="org-keyword">if</span> (needed &lt;= alloc_bytes_remaining_) {
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  } <span class="org-keyword">else</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">AllocateFallback always returned aligned memory</span>
    result = AllocateFallback(bytes);
  }
  assert((<span class="org-keyword">reinterpret_cast</span>&lt;uintptr_t&gt;(result) &amp; (align-1)) == 0);
  <span class="org-keyword">return</span> result;
}

<span class="org-type">char</span>* <span class="org-constant">Arena</span>::<span class="org-function-name">AllocateNewBlock</span>(<span class="org-type">size_t</span> <span class="org-variable-name">block_bytes</span>) {
  <span class="org-type">char</span>* <span class="org-variable-name">result</span> = <span class="org-keyword">new</span> <span class="org-type">char</span>[block_bytes];
  blocks_memory_ += block_bytes;
  blocks_.push_back(result);
  <span class="org-keyword">return</span> result;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline300" class="outline-4">
<h4 id="orgheadline300"><span class="section-number-4">10.9.2</span> Coding</h4>
<div class="outline-text-4" id="text-10-9-2">
<p>
util/coding.h[.cc] Coding主要是用来完成变长数据以及字符串还有Slice的序列化和反序列化的.主要方法包括下面这些
</p>
<ul class="org-ul">
<li>PutFixed32 写入定长uint32</li>
<li>PutFixed64 写入定长uint64</li>
<li>PutVarint32 写入变长uint32</li>
<li>PutVarint64 写入变长uint64</li>
<li>PutLengthPrefixedSlice 后面解释.</li>
<li>GetVarint32 读取变长uint32</li>
<li>GetVarint64 读取变长uint64</li>
<li>GetLengthPrefixedSlice 后面解释.</li>
<li>GetVarint32Ptr(p,limit,v) 将[p,limit)部分的内存解析为变长uint32放到v里面,返回下一个字节</li>
<li>GetVarint64Ptr(p,limit,v) 将[p,limit)部分的内存解析为变长uint64放到v里面,返回下一个字节</li>
<li>VarintLength 变长uint32/uint64长度</li>
<li>EncodeFixed32 PutFixed32 low-level</li>
<li>EncodeFixed64 PutFixed64 low-level</li>
<li>EncodeVarint32 PutVarint32 low-level</li>
<li>EncodeVarint64 PutVarint64 low-level</li>
<li>DecodeFixed32 读取定长uint32</li>
<li>DecodeFixed64 读取定长uint64</li>
<li>GetVarint32PtrFallback</li>
<li>GetVarint32Ptr 从[p,limit)读取uint32并且返回下一个字节.</li>
</ul>

<p>
编码方式有点类似于google::protobuf里面的变长整数打包。我们这里着重看看下面两个函数
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">void</span> <span class="org-function-name">PutLengthPrefixedSlice</span>(<span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">value</span>) {
  PutVarint32(dst, value.size());
  dst-&gt;append(value.data(), value.size());
}
<span class="org-type">bool</span> <span class="org-function-name">GetLengthPrefixedSlice</span>(<span class="org-type">Slice</span>* <span class="org-variable-name">input</span>, <span class="org-type">Slice</span>* <span class="org-variable-name">result</span>) {
  <span class="org-type">uint32_t</span> <span class="org-variable-name">len</span>;
  <span class="org-keyword">if</span> (GetVarint32(input, &amp;len) &amp;&amp;
      input-&gt;size() &gt;= len) {
    *result = Slice(input-&gt;data(), len);
    input-&gt;remove_prefix(len);
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
}
</pre>
</div>
<p>
PutLengthPrefixedSlice对于slice的存储，首先是放入uint32长度然后放入内容.
GetLengthPrefixedSlice从input首先取出长度，然后取出数据,并且将input跳过这些长度.
</p>
</div>
</div>

<div id="outline-container-orgheadline301" class="outline-4">
<h4 id="orgheadline301"><span class="section-number-4">10.9.3</span> Histogram</h4>
<div class="outline-text-4" id="text-10-9-3">
<p>
todo:
</p>
</div>
</div>

<div id="outline-container-orgheadline312" class="outline-4">
<h4 id="orgheadline312"><span class="section-number-4">10.9.4</span> SkipList</h4>
<div class="outline-text-4" id="text-10-9-4">
<p>
db/skiplist.h SkipList(跳表)之前在课本上看到过，但是当时觉得实在是没有太大的用途。现在仔细看看吧.
这里的SkipList附带了一个iterator.首先看看SkipList的结构.SkipList对于写的话是需要外部进行同步的，
对于读的话可以是多个读同时发起。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">class</span> <span class="org-type">SkipList</span> {
 <span class="org-keyword">private</span>:
  <span class="org-keyword">struct</span> <span class="org-type">Node</span>;

 <span class="org-keyword">public</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Create a new SkipList object that will use "cmp" for comparing keys,</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">and will allocate memory using "*arena".  Objects allocated in the arena</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">must remain allocated for the lifetime of the skiplist object.</span>
  <span class="org-keyword">explicit</span> <span class="org-function-name">SkipList</span>(<span class="org-type">Comparator</span> <span class="org-variable-name">cmp</span>, <span class="org-type">Arena</span>* <span class="org-variable-name">arena</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Insert key into the list.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: nothing that compares equal to key is currently in the list.</span>
  <span class="org-type">void</span> <span class="org-function-name">Insert</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true iff an entry that compares equal to key is in the list.</span>
  <span class="org-type">bool</span> <span class="org-function-name">Contains</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Iteration over the contents of a skip list</span>
  <span class="org-keyword">class</span> <span class="org-type">Iterator</span> {
   <span class="org-keyword">public</span>:
    <span class="org-comment-delimiter">// </span><span class="org-comment">Initialize an iterator over the specified list.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">The returned iterator is not valid.</span>
    <span class="org-keyword">explicit</span> <span class="org-function-name">Iterator</span>(<span class="org-keyword">const</span> <span class="org-type">SkipList</span>* <span class="org-variable-name">list</span>);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns true iff the iterator is positioned at a valid node.</span>
    <span class="org-type">bool</span> <span class="org-function-name">Valid</span>() <span class="org-keyword">const</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Returns the key at the current position.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Valid()</span>
    <span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-function-name">key</span>() <span class="org-keyword">const</span>;

    <span class="org-comment-delimiter">// </span><span class="org-comment">Advances to the next position.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Valid()</span>
    <span class="org-type">void</span> <span class="org-function-name">Next</span>();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Advances to the previous position.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">REQUIRES: Valid()</span>
    <span class="org-type">void</span> <span class="org-function-name">Prev</span>();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Advance to the first entry with a key &gt;= target</span>
    <span class="org-type">void</span> <span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">target</span>);

    <span class="org-comment-delimiter">// </span><span class="org-comment">Position at the first entry in list.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Final state of iterator is Valid() iff list is not empty.</span>
    <span class="org-type">void</span> <span class="org-function-name">SeekToFirst</span>();

    <span class="org-comment-delimiter">// </span><span class="org-comment">Position at the last entry in list.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Final state of iterator is Valid() iff list is not empty.</span>
    <span class="org-type">void</span> <span class="org-function-name">SeekToLast</span>();

   <span class="org-keyword">private</span>:
    <span class="org-keyword">const</span> <span class="org-type">SkipList</span>* <span class="org-variable-name">list_</span>;
    <span class="org-type">Node</span>* <span class="org-variable-name">node_</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Intentionally copyable</span>
  };

 <span class="org-keyword">private</span>:
  <span class="org-keyword">enum</span> { <span class="org-variable-name">kMaxHeight</span> = 12 }; <span class="org-comment-delimiter">// </span><span class="org-comment">&#36339;&#34920;&#26368;&#22823;&#39640;&#24230;&#26159;12.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Immutable after construction</span>
  Comparator <span class="org-keyword">const</span> <span class="org-variable-name">compare_</span>;
  <span class="org-type">Arena</span>* <span class="org-keyword">const</span> <span class="org-variable-name">arena_</span>;    <span class="org-comment-delimiter">// </span><span class="org-comment">Arena used for allocations of nodes</span>

  <span class="org-type">Node</span>* <span class="org-keyword">const</span> <span class="org-variable-name">head_</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Modified only by Insert().  Read racily by readers, but stale</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">values are ok.</span>
  <span class="org-constant">port</span>::<span class="org-type">AtomicPointer</span> <span class="org-variable-name">max_height_</span>;   <span class="org-comment-delimiter">// </span><span class="org-comment">Height of the entire list</span>

  <span class="org-keyword">inline</span> <span class="org-type">int</span> <span class="org-function-name">GetMaxHeight</span>() <span class="org-keyword">const</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">&#24403;&#21069;&#26368;&#22823;&#30340;skiplist&#39640;&#24230;.</span>
    <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span>&lt;intptr_t&gt;(max_height_.NoBarrier_Load());
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Read/written only by Insert().</span>
  <span class="org-type">Random</span> <span class="org-variable-name">rnd_</span>;

  <span class="org-type">Node</span>* <span class="org-function-name">NewNode</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">int</span> <span class="org-variable-name">height</span>);
  <span class="org-type">int</span> <span class="org-function-name">RandomHeight</span>();
  <span class="org-type">bool</span> <span class="org-function-name">Equal</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">b</span>) <span class="org-keyword">const</span> { <span class="org-keyword">return</span> (compare_(a, b) == 0); }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return true if key is greater than the data stored in "n"</span>
  <span class="org-type">bool</span> <span class="org-function-name">KeyIsAfterNode</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">Node</span>* <span class="org-variable-name">n</span>) <span class="org-keyword">const</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the earliest node that comes at or after key.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Return NULL if there is no such node.</span>
  <span class="org-comment-delimiter">//</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If prev is non-NULL, fills prev[level] with pointer to previous</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">node at "level" for every level in [0..max_height_-1].</span>
  <span class="org-type">Node</span>* <span class="org-function-name">FindGreaterOrEqual</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">Node</span>** <span class="org-variable-name">prev</span>) <span class="org-keyword">const</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the latest node with a key &lt; key.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Return head_ if there is no such node.</span>
  <span class="org-type">Node</span>* <span class="org-function-name">FindLessThan</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Return the last node in the list.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">Return head_ if list is empty.</span>
  <span class="org-type">Node</span>* <span class="org-function-name">FindLast</span>() <span class="org-keyword">const</span>;
};
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="orgheadline302"></a>RandomHeight<br  /><div class="outline-text-5" id="text-10-9-4-1">
<p>
随机产生一个SkipList的高度.从1开始每次以1/4的概率+1.
</p>
<ul class="org-ul">
<li>h=1 3/4</li>
<li>h=2 3/16</li>
<li>&#x2026;</li>
</ul>
<p>
主要就是有这么一个大概的概率就是,随机初始化的高度不会很大.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-type">int</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">RandomHeight</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Increase height with probability 1 in kBranching</span>
  <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">kBranching</span> = 4;
  <span class="org-type">int</span> <span class="org-variable-name">height</span> = 1;
  <span class="org-keyword">while</span> (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  assert(height &gt; 0);
  assert(height &lt;= kMaxHeight);
  <span class="org-keyword">return</span> height;
}
</pre>
</div>
</div></li>

<li><a id="orgheadline303"></a>KeyIsAfterNode<br  /><div class="outline-text-5" id="text-10-9-4-2">
<p>
可以认为是key的比较函数吧.拿key和当前某一个node进行比较，看看这个key是否应该存在这个node之后.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-type">bool</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">KeyIsAfterNode</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">Node</span>* <span class="org-variable-name">n</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">NULL n is considered infinite</span>
  <span class="org-keyword">return</span> (n != <span class="org-constant">NULL</span>) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20869;&#37096;&#30340;comparator.</span>
}
</pre>
</div>
</div></li>

<li><a id="orgheadline304"></a>FindGreaterOrEqual<br  /><div class="outline-text-5" id="text-10-9-4-3">
<p>
找到和key相当或者是&gt;key的第一个node.对跳表的原理稍微熟悉一些大概就可以看懂代码了.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">typename</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-type">Node</span>* <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">FindGreaterOrEqual</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">Node</span>** <span class="org-variable-name">prev</span>)
    <span class="org-keyword">const</span> {
  <span class="org-type">Node</span>* <span class="org-variable-name">x</span> = head_;
  <span class="org-type">int</span> <span class="org-variable-name">level</span> = GetMaxHeight() - 1; <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#29031;&#26368;&#39640;&#23618;&#30340;&#36339;&#34920;&#26597;&#25214;</span>
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    <span class="org-type">Node</span>* <span class="org-variable-name">next</span> = x-&gt;Next(level);
    <span class="org-keyword">if</span> (KeyIsAfterNode(key, next)) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;key&#22312;&#36825;&#20010;&#21518;&#38754;&#30340;&#35805;,&#37027;&#20040;&#32487;&#32493;&#25353;&#29031;&#36825;&#20010;&#39640;&#24230;.</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">Keep searching in this list</span>
      x = next;
    } <span class="org-keyword">else</span> {
      <span class="org-keyword">if</span> (prev != <span class="org-constant">NULL</span>) prev[level] = x; <span class="org-comment-delimiter">// </span><span class="org-comment">&#35760;&#24405;&#36825;&#20010;prev.</span>
      <span class="org-keyword">if</span> (level == 0) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#21040;&#20102;&#26368;&#19979;&#23618;&#30340;&#35805;.</span>
        <span class="org-keyword">return</span> next; <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#30340;&#36820;&#22238;&#20540;&#19981;&#19968;&#23450;Equal(key)</span>
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Switch to next list</span>
        level--; <span class="org-comment-delimiter">// </span><span class="org-comment">&#21542;&#21017;level--.</span>
      }
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline305"></a>Insert<br  /><div class="outline-text-5" id="text-10-9-4-4">
<p>
插入某一个key.恩,逻辑还算是比较简单吧
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-type">void</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">Insert</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">here since Insert() is externally synchronized.</span>
  Node* prev[kMaxHeight];
  <span class="org-type">Node</span>* <span class="org-variable-name">x</span> = FindGreaterOrEqual(key, prev); <span class="org-comment-delimiter">// </span><span class="org-comment">&#26597;&#25214;&#21040;key&#30340;previous&#30340;&#20869;&#23481;.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">Our data structure does not allow duplicate insertion</span>
  assert(x == <span class="org-constant">NULL</span> || <span class="org-negation-char">!</span>Equal(key, x-&gt;key));

  <span class="org-type">int</span> <span class="org-variable-name">height</span> = RandomHeight();
  <span class="org-keyword">if</span> (height &gt; GetMaxHeight()) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#38543;&#26426;&#20135;&#29983;&#39640;&#24230;.:&#25105;&#22312;&#24819;&#65292;&#26159;&#19981;&#26159;&#21482;&#26377;&#36825;&#20010;&#22320;&#26041;&#25165;&#20250;&#25913;&#21464;&#39640;&#24230;&#21602;?.</span>
    <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = GetMaxHeight(); i &lt; height; i++) {
      prev[i] = head_; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;&#27809;&#26377;&#30340;&#35805;&#65292;&#37027;&#20040;&#21021;&#22987;&#21270;&#20026;head_.</span>
    }
    <span class="org-comment-delimiter">//</span><span class="org-comment">fprintf(stderr, "Change height from %d to %d\n", max_height_, height);</span>

    <span class="org-comment-delimiter">// </span><span class="org-comment">It is ok to mutate max_height_ without any synchronization</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">with concurrent readers.  A concurrent reader that observes</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">the new value of max_height_ will see either the old value of</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">new level pointers from head_ (NULL), or a new value set in</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">the loop below.  In the former case the reader will</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">immediately drop to the next level since NULL sorts after all</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">keys.  In the latter case the reader will use the new node.</span>
    max_height_.NoBarrier_Store(<span class="org-keyword">reinterpret_cast</span>&lt;<span class="org-type">void</span>*&gt;(height));
  }

  x = NewNode(key, height); <span class="org-comment-delimiter">// </span><span class="org-comment">&#20135;&#29983;&#19968;&#20010;&#26032;&#30340;&#33410;&#28857;.</span>
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; height; i++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#28982;&#21518;&#25554;&#20837;&#32500;&#25252;&#22909;&#36825;&#20010;&#36339;&#34920;&#32467;&#26500;.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">NoBarrier_SetNext() suffices since we will add a barrier when</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">we publish a pointer to "x" in prev[i].</span>
    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));
    prev[i]-&gt;SetNext(i, x);
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline306"></a>Contains<br  /><div class="outline-text-5" id="text-10-9-4-5">
<p>
Contains用来判断跳表里面是否包含key
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-type">bool</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">Contains</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> {
  <span class="org-type">Node</span>* <span class="org-variable-name">x</span> = FindGreaterOrEqual(key, <span class="org-constant">NULL</span>);
  <span class="org-keyword">if</span> (x != <span class="org-constant">NULL</span> &amp;&amp; Equal(key, x-&gt;key)) {
    <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">&#22914;&#26524;!=NULL&#24182;&#19988;Equal&#30340;&#35805;&#37027;&#20040;&#36820;&#22238;true.</span>
  } <span class="org-keyword">else</span> {
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline307"></a>FindLessThan<br  /><div class="outline-text-5" id="text-10-9-4-6">
<p>
查找最后面一个less than key的这个node.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">typename</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-type">Node</span>*
<span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">FindLessThan</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>) <span class="org-keyword">const</span> {
  <span class="org-type">Node</span>* <span class="org-variable-name">x</span> = head_;
  <span class="org-type">int</span> <span class="org-variable-name">level</span> = GetMaxHeight() - 1;
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    assert(x == head_ || compare_(x-&gt;key, key) &lt; 0);
    <span class="org-type">Node</span>* <span class="org-variable-name">next</span> = x-&gt;Next(level);
    <span class="org-keyword">if</span> (next == <span class="org-constant">NULL</span> || compare_(next-&gt;key, key) &gt;= 0) {
      <span class="org-keyword">if</span> (level == 0) {
        <span class="org-keyword">return</span> x;
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Switch to next list</span>
        level--;
      }
    } <span class="org-keyword">else</span> {
      x = next;
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline308"></a>FindLast<br  /><div class="outline-text-5" id="text-10-9-4-7">
<p>
FindLast就是找到元素的最后一个节点.非常简单，首先在最高节点遍历然后不断地降低level遍历.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">typename</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-type">Node</span>* <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">FindLast</span>()
    <span class="org-keyword">const</span> {
  <span class="org-type">Node</span>* <span class="org-variable-name">x</span> = head_;
  <span class="org-type">int</span> <span class="org-variable-name">level</span> = GetMaxHeight() - 1;
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
    <span class="org-type">Node</span>* <span class="org-variable-name">next</span> = x-&gt;Next(level);
    <span class="org-keyword">if</span> (next == <span class="org-constant">NULL</span>) {
      <span class="org-keyword">if</span> (level == 0) {
        <span class="org-keyword">return</span> x;
      } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">Switch to next list</span>
        level--;
      }
    } <span class="org-keyword">else</span> {
      x = next;
    }
  }
}
</pre>
</div>
</div></li>

<li><a id="orgheadline309"></a>Node<br  /><div class="outline-text-5" id="text-10-9-4-8">
<p>
在看下面的函数之前我们先看看Node的实现.其实非常简单，而且似乎没有必要使用atomic的方式来操作。
因为这里面我们已经要求写需要外部加锁保证了.(#note: 后来想想还是有必要的,这里我们只是要求用户
在写的时候使用外部同步机保证，而读的时候没有。那么这样必须强制读取内存才可以保证正确,所以这里
需要Acquire_Load以及Release_Load).非常简单，就是持有key以及跳表指针.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">struct</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-type">Node</span> {
  <span class="org-keyword">explicit</span> <span class="org-function-name">Node</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">k</span>) : key(k) { }

  Key <span class="org-keyword">const</span> <span class="org-variable-name">key</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Accessors/mutators for links.  Wrapped in methods so we can</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">add the appropriate barriers as necessary.</span>
  <span class="org-type">Node</span>* <span class="org-function-name">Next</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>) {
    assert(n &gt;= 0);
    <span class="org-comment-delimiter">// </span><span class="org-comment">Use an 'acquire load' so that we observe a fully initialized</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">version of the returned Node.</span>
    <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].Acquire_Load());
  }
  <span class="org-type">void</span> <span class="org-function-name">SetNext</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">Node</span>* <span class="org-variable-name">x</span>) {
    assert(n &gt;= 0);
    <span class="org-comment-delimiter">// </span><span class="org-comment">Use a 'release store' so that anybody who reads through this</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">pointer observes a fully initialized version of the inserted node.</span>
    next_[n].Release_Store(x);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">No-barrier variants that can be safely used in a few locations.</span>
  <span class="org-type">Node</span>* <span class="org-function-name">NoBarrier_Next</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>) {
    assert(n &gt;= 0);
    <span class="org-keyword">return</span> <span class="org-keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].NoBarrier_Load());
  }
  <span class="org-type">void</span> <span class="org-function-name">NoBarrier_SetNext</span>(<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-type">Node</span>* <span class="org-variable-name">x</span>) {
    assert(n &gt;= 0);
    next_[n].NoBarrier_Store(x);
  }

 <span class="org-keyword">private</span>:
  <span class="org-comment-delimiter">// </span><span class="org-comment">Array of length equal to the node height.  next_[0] is lowest level link.</span>
  <span class="org-constant">port</span>::<span class="org-type">AtomicPointer</span> <span class="org-variable-name">next_</span>[1]; <span class="org-comment-delimiter">// </span><span class="org-comment">&#33267;&#23569;&#26377;&#19968;&#20010;next&#25351;&#38024;.</span>
};
</pre>
</div>
</div></li>

<li><a id="orgheadline310"></a>NewNode<br  /><div class="outline-text-5" id="text-10-9-4-9">
<p>
前面看完了Node的结构.然后Node分配就非常简单了.这里采用了inplacement new的方式来分配内存
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">typename</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-type">Node</span>*
<span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-function-name">NewNode</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">key</span>, <span class="org-type">int</span> <span class="org-variable-name">height</span>) {
  <span class="org-type">char</span>* <span class="org-variable-name">mem</span> = arena_-&gt;AllocateAligned(
      <span class="org-keyword">sizeof</span>(Node) + <span class="org-keyword">sizeof</span>(<span class="org-constant">port</span>::AtomicPointer) * (height - 1));
  <span class="org-keyword">return</span> <span class="org-keyword">new</span> (mem) <span class="org-type">Node</span>(key);
}
</pre>
</div>
<p>
注意这里只需要分配height-1的高度即可，因为在Node里面已经存在了1个链表指针.
</p>
</div></li>

<li><a id="orgheadline311"></a>Iterator<br  /><div class="outline-text-5" id="text-10-9-4-10">
<p>
了解了跳表的工作原理之后，对于其遍历器理解就非常简单了。代码也非常简单。但是阅读代码就会发现，
跳表的前向遍历功能不怎么样，因为没有维护prev指针。这里prev的方法是用过调用FindLessThan来实现的。
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">Iterator</span>(<span class="org-keyword">const</span> <span class="org-type">SkipList</span>* <span class="org-variable-name">list</span>) {
  list_ = list;
  node_ = <span class="org-constant">NULL</span>;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-type">bool</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">Valid</span>() <span class="org-keyword">const</span> {
  <span class="org-keyword">return</span> node_ != <span class="org-constant">NULL</span>;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">key</span>() <span class="org-keyword">const</span> {
  assert(Valid());
  <span class="org-keyword">return</span> node_-&gt;key;
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">Next</span>() {
  assert(Valid());
  node_ = node_-&gt;Next(0);
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">Prev</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Instead of using explicit "prev" links, we just search for the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">last node that falls before key.</span>
  assert(Valid());
  node_ = list_-&gt;FindLessThan(node_-&gt;key); <span class="org-comment-delimiter">// </span><span class="org-comment">&#21487;&#33021;&#24615;&#33021;&#20250;&#23384;&#22312;&#38382;&#39064;.&#25152;&#20197;&#26368;&#22909;&#19981;&#35201;&#21069;&#21521;&#36941;&#21382;.</span>
  <span class="org-keyword">if</span> (node_ == list_-&gt;head_) {
    node_ = <span class="org-constant">NULL</span>;
  }
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">Seek</span>(<span class="org-keyword">const</span> <span class="org-type">Key</span>&amp; <span class="org-variable-name">target</span>) {
  node_ = list_-&gt;FindGreaterOrEqual(target, <span class="org-constant">NULL</span>);
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">SeekToFirst</span>() {
  node_ = list_-&gt;head_-&gt;Next(0);
}

<span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Key</span>, <span class="org-keyword">class</span> <span class="org-type">Comparator</span>&gt;
<span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-constant">SkipList</span>&lt;<span class="org-type">Key</span>,<span class="org-type">Comparator</span>&gt;::<span class="org-constant">Iterator</span>::<span class="org-function-name">SeekToLast</span>() {
  node_ = list_-&gt;FindLast();
  <span class="org-keyword">if</span> (node_ == list_-&gt;head_) {
    node_ = <span class="org-constant">NULL</span>;
  }
}
</pre>
</div>
</div></li></ol>
</div>

<div id="outline-container-orgheadline313" class="outline-4">
<h4 id="orgheadline313"><span class="section-number-4">10.9.5</span> AtomicPointer</h4>
<div class="outline-text-4" id="text-10-9-5">
<p>
port/atomic_pointer.h 指针的存取都是原子操作.对于pointer来说，不管是32位还是64位的话都是原子操作的。但是这里必须考虑内存屏障。
对于leveldb还考虑到c++0x的原子操作库cstdatomic本身所提供的功能。我们都看看这个是如何实现的。
</p>

<p>
对于没有cstdatomic并且是x86CPU的话.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">AtomicPointer built using platform-specific MemoryBarrier()</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">Gcc on x86</span>
<span class="org-preprocessor">#elif</span> <span class="org-preprocessor">defined</span>(ARCH_CPU_X86_FAMILY) &amp;&amp; <span class="org-preprocessor">defined</span>(__GNUC__)
<span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">MemoryBarrier</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.</span>
  <span class="org-keyword">__asm__</span> __volatile__(<span class="org-string">""</span> : : : <span class="org-string">"memory"</span>);
}

<span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span>(LEVELDB_HAVE_MEMORY_BARRIER)
<span class="org-keyword">class</span> <span class="org-type">AtomicPointer</span> {
 <span class="org-keyword">private</span>:
  <span class="org-type">void</span>* <span class="org-variable-name">rep_</span>;
 <span class="org-keyword">public</span>:
  <span class="org-function-name">AtomicPointer</span>() { }
  <span class="org-keyword">explicit</span> <span class="org-function-name">AtomicPointer</span>(<span class="org-type">void</span>* <span class="org-variable-name">p</span>) : rep_(p) {}
  <span class="org-keyword">inline</span> <span class="org-type">void</span>* <span class="org-function-name">NoBarrier_Load</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> rep_; }
  <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">NoBarrier_Store</span>(<span class="org-type">void</span>* <span class="org-variable-name">v</span>) { rep_ = v; }
  <span class="org-keyword">inline</span> <span class="org-type">void</span>* <span class="org-function-name">Acquire_Load</span>() <span class="org-keyword">const</span> {
    <span class="org-type">void</span>* <span class="org-variable-name">result</span> = rep_;
    MemoryBarrier();
    <span class="org-keyword">return</span> result;
  }
  <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">Release_Store</span>(<span class="org-type">void</span>* <span class="org-variable-name">v</span>) {
    MemoryBarrier();
    rep_ = v;
  }
};
</pre>
</div>

<p>
对于有cstdatomic库的话.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-preprocessor">#elif</span> <span class="org-preprocessor">defined</span>(LEVELDB_CSTDATOMIC_PRESENT)
<span class="org-keyword">class</span> <span class="org-type">AtomicPointer</span> {
 <span class="org-keyword">private</span>:
  <span class="org-constant">std</span>::<span class="org-type">atomic</span>&lt;<span class="org-type">void</span>*&gt; <span class="org-variable-name">rep_</span>;
 <span class="org-keyword">public</span>:
  <span class="org-function-name">AtomicPointer</span>() { }
  <span class="org-keyword">explicit</span> <span class="org-function-name">AtomicPointer</span>(<span class="org-type">void</span>* <span class="org-variable-name">v</span>) : rep_(v) { }
  <span class="org-keyword">inline</span> <span class="org-type">void</span>* <span class="org-function-name">Acquire_Load</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> rep_.load(<span class="org-constant">std</span>::memory_order_acquire); <span class="org-comment-delimiter">// </span><span class="org-comment">memory order acquire</span>
  }
  <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">Release_Store</span>(<span class="org-type">void</span>* <span class="org-variable-name">v</span>) {
    rep_.store(v, <span class="org-constant">std</span>::memory_order_release); <span class="org-comment-delimiter">// </span><span class="org-comment">memory order release.</span>
  }
  <span class="org-keyword">inline</span> <span class="org-type">void</span>* <span class="org-function-name">NoBarrier_Load</span>() <span class="org-keyword">const</span> {
    <span class="org-keyword">return</span> rep_.load(<span class="org-constant">std</span>::memory_order_relaxed); <span class="org-comment-delimiter">// </span><span class="org-comment">memory order relaxed.</span>
  }
  <span class="org-keyword">inline</span> <span class="org-type">void</span> <span class="org-function-name">NoBarrier_Store</span>(<span class="org-type">void</span>* <span class="org-variable-name">v</span>) {
    rep_.store(v, <span class="org-constant">std</span>::memory_order_relaxed);
  }
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline314" class="outline-4">
<h4 id="orgheadline314"><span class="section-number-4">10.9.6</span> CRC32C</h4>
<div class="outline-text-4" id="text-10-9-6">
<p>
util/crc32c.cc CRC32C算法实现.注意这里Extend的第一个参数是初始值.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">Return the crc32c of concat(A, data[0,n-1]) where init_crc is the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">crc32c of some string A.  Extend() is often used to maintain the</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">crc32c of a stream of data.</span>
<span class="org-keyword">extern</span> <span class="org-type">uint32_t</span> <span class="org-function-name">Extend</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">init_crc</span>, <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>);

<span class="org-comment-delimiter">// </span><span class="org-comment">Return the crc32c of data[0,n-1]</span>
<span class="org-keyword">inline</span> <span class="org-type">uint32_t</span> <span class="org-function-name">Value</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>) {
  <span class="org-keyword">return</span> Extend(0, data, n);
}
</pre>
</div>

<p>
后面还有两个函数没有看懂存在的意义，但是本身算法并不麻烦.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">kMaskDelta</span> = 0xa282ead8ul;

<span class="org-comment-delimiter">// </span><span class="org-comment">Return a masked representation of crc.</span>
<span class="org-comment-delimiter">//</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">Motivation: it is problematic to compute the CRC of a string that</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">contains embedded CRCs.  Therefore we recommend that CRCs stored</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">somewhere (e.g., in files) should be masked before being stored.</span>
<span class="org-keyword">inline</span> <span class="org-type">uint32_t</span> <span class="org-function-name">Mask</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">crc</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Rotate right by 15 bits and add a constant.</span>
  <span class="org-keyword">return</span> ((crc &gt;&gt; 15) | (crc &lt;&lt; 17)) + kMaskDelta;
}

<span class="org-comment-delimiter">// </span><span class="org-comment">Return the crc whose masked representation is masked_crc.</span>
<span class="org-keyword">inline</span> <span class="org-type">uint32_t</span> <span class="org-function-name">Unmask</span>(<span class="org-type">uint32_t</span> <span class="org-variable-name">masked_crc</span>) {
  <span class="org-type">uint32_t</span> <span class="org-variable-name">rot</span> = masked_crc - kMaskDelta;
  <span class="org-keyword">return</span> ((rot &gt;&gt; 17) | (rot &lt;&lt; 15));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline315" class="outline-4">
<h4 id="orgheadline315"><span class="section-number-4">10.9.7</span> Hash</h4>
<div class="outline-text-4" id="text-10-9-7">
<p>
hash.cc提供了Hash算法，看上去有点类似于murmurhash.
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">uint32_t</span> <span class="org-function-name">Hash</span>(<span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">data</span>, <span class="org-type">size_t</span> <span class="org-variable-name">n</span>, <span class="org-type">uint32_t</span> <span class="org-variable-name">seed</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Similar to murmur hash</span>
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">m</span> = 0xc6a4a793;
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">r</span> = 24;
  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">limit</span> = data + n;
  <span class="org-type">uint32_t</span> <span class="org-variable-name">h</span> = seed ^ (n * m);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Pick up four bytes at a time</span>
  <span class="org-keyword">while</span> (data + 4 &lt;= limit) {
    <span class="org-type">uint32_t</span> <span class="org-variable-name">w</span> = DecodeFixed32(data);
    data += 4;
    h += w;
    h *= m;
    h ^= (h &gt;&gt; 16);
  }

  <span class="org-comment-delimiter">// </span><span class="org-comment">Pick up remaining bytes</span>
  <span class="org-keyword">switch</span> (limit - data) {
    <span class="org-keyword">case</span> 3:
      h += data[2] &lt;&lt; 16;
      <span class="org-comment-delimiter">// </span><span class="org-comment">fall through</span>
    <span class="org-keyword">case</span> 2:
      h += data[1] &lt;&lt; 8;
      <span class="org-comment-delimiter">// </span><span class="org-comment">fall through</span>
    <span class="org-keyword">case</span> 1:
      h += data[0];
      h *= m;
      h ^= (h &gt;&gt; r);
      <span class="org-keyword">break</span>;
  }
  <span class="org-keyword">return</span> h;
}
</pre>
</div>

<p>
之前一直纠结于这个seed应该如何来进行设置。其实现在自己也不知道:(.
在bloom.cc里面使用方式是：
</p>
<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">static</span> <span class="org-type">uint32_t</span> <span class="org-function-name">BloomHash</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>) {
  <span class="org-keyword">return</span> Hash(key.data(), key.size(), 0xbc9f1d34);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline316" class="outline-4">
<h4 id="orgheadline316"><span class="section-number-4">10.9.8</span> BloomFilterPolicy</h4>
<div class="outline-text-4" id="text-10-9-8">
<p>
第一次看接口有点混淆。为什么CreateFilter需要将生成的filter追加到dst里面呢?其实我猜想这个完全取决于应用，
可能应用在上层希望将filter的内存统一管理，然后一次释放。使用的时候可以选取某一个slice作为filter.
</p>

<p>
#note: 之前可能对于filter有点错误理解.觉得这个filter没有必要存放在磁盘上而应该全部在内存上面。
但是leveldb会针对若干个data block生成一个filter存放在磁盘上面。如果是这样接口就非常好理解了，
将所有的filter全部聚合在连续的内存上面写入table.
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-keyword">explicit</span> <span class="org-function-name">BloomFilterPolicy</span>(<span class="org-type">int</span> <span class="org-variable-name">bits_per_key</span>)
    : bits_per_key_(bits_per_key) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#35745;&#31639;&#20026;&#27599;&#20010;key&#29983;&#25104;&#22810;&#23569;&#20010;probe(&#26816;&#27979;&#28857;).</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bits_per_key*ln(2)</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">We intentionally round down to reduce probing cost a little bit</span>
  k_ = <span class="org-keyword">static_cast</span>&lt;size_t&gt;(bits_per_key * 0.69);  <span class="org-comment-delimiter">// </span><span class="org-comment">0.69 =~ ln(2)</span>
  <span class="org-keyword">if</span> (k_ &lt; 1) k_ = 1;
  <span class="org-keyword">if</span> (k_ &gt; 30) k_ = 30;
}

<span class="org-keyword">virtual</span> <span class="org-type">void</span> <span class="org-function-name">CreateFilter</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>* <span class="org-variable-name">keys</span>, <span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-constant">std</span>::<span class="org-type">string</span>* <span class="org-variable-name">dst</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Compute bloom filter size (in both bits and bytes)</span>
  <span class="org-type">size_t</span> <span class="org-variable-name">bits</span> = n * bits_per_key_; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20998;&#37197;&#22810;&#23569;&#20010;bits.</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">For small n, we can see a very high false positive rate.  Fix it</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">by enforcing a minimum bloom filter length.</span>
  <span class="org-keyword">if</span> (bits &lt; 64) bits = 64;

  <span class="org-type">size_t</span> <span class="org-variable-name">bytes</span> = (bits + 7) / 8; <span class="org-comment-delimiter">// </span><span class="org-comment">&#20570;&#19968;&#20010;round&#28982;&#21518;&#35745;&#31639;&#20998;&#37197;&#22810;&#23569;&#20010;bits.</span>
  bits = bytes * 8;

  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">init_size</span> = dst-&gt;size();
  dst-&gt;resize(init_size + bytes, 0); <span class="org-comment-delimiter">// </span><span class="org-comment">dst&#21069;&#38754;&#30340;&#37096;&#20998;&#19981;&#21516;&#36861;&#21152;bytes&#23383;&#33410;.</span>
  dst-&gt;push_back(<span class="org-keyword">static_cast</span>&lt;<span class="org-type">char</span>&gt;(k_));  <span class="org-comment-delimiter">// </span><span class="org-comment">Remember # of probes in filter // &#23558;&#36825;&#20010;probe&#20010;&#25968;&#35760;&#24405;&#22312;dst&#26411;&#23614;.</span>
  <span class="org-type">char</span>* <span class="org-variable-name">array</span> = &amp;(*dst)[init_size]; <span class="org-comment-delimiter">//</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; n; i++) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Use double-hashing to generate a sequence of hash values.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">See analysis in [Kirsch,Mitzenmacher 2006].</span>
    <span class="org-type">uint32_t</span> <span class="org-variable-name">h</span> = BloomHash(keys[i]);
    <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">delta</span> = (h &gt;&gt; 17) | (h &lt;&lt; 15);  <span class="org-comment-delimiter">// </span><span class="org-comment">Rotate right 17 bits</span>
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">j</span> = 0; j &lt; k_; j++) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#27599;&#27425;&#20570;key&#20010;&#28857;&#30340;probe.</span>
      <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">bitpos</span> = h % bits;
      array[bitpos/8] |= (1 &lt;&lt; (bitpos % 8));
      h += delta;
    }
  }
}

<span class="org-keyword">virtual</span> <span class="org-type">bool</span> <span class="org-function-name">KeyMayMatch</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">key</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">bloom_filter</span>) <span class="org-keyword">const</span> {
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">len</span> = bloom_filter.size(); <span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#20010;len&#21253;&#21547;&#20102;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#30340;probe.</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">&#21518;&#38754;&#37117;&#38750;&#24120;&#22909;&#29702;&#35299;.</span>
  <span class="org-keyword">if</span> (len &lt; 2) <span class="org-keyword">return</span> <span class="org-constant">false</span>;

  <span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">array</span> = bloom_filter.data();
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">bits</span> = (len - 1) * 8;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Use the encoded k so that we can read filters generated by</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">bloom filters created using different parameters.</span>
  <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">k</span> = array[len-1];
  <span class="org-keyword">if</span> (k &gt; 30) {
    <span class="org-comment-delimiter">// </span><span class="org-comment">Reserved for potentially new encodings for short bloom filters.</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Consider it a match.</span>
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
  }

  <span class="org-type">uint32_t</span> <span class="org-variable-name">h</span> = BloomHash(key);
  <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">delta</span> = (h &gt;&gt; 17) | (h &lt;&lt; 15);  <span class="org-comment-delimiter">// </span><span class="org-comment">Rotate right 17 bits</span>
  <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">j</span> = 0; j &lt; k; j++) {
    <span class="org-keyword">const</span> <span class="org-type">uint32_t</span> <span class="org-variable-name">bitpos</span> = h % bits;
    <span class="org-keyword">if</span> ((array[bitpos/8] &amp; (1 &lt;&lt; (bitpos % 8))) == 0) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    h += delta;
  }
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline320" class="outline-2">
<h2 id="orgheadline320"><span class="section-number-2">11</span> Discussion</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-orgheadline319" class="outline-3">
<h3 id="orgheadline319"><span class="section-number-3">11.1</span> leveldb通过iterator遍历，对于相同的key如何保证获取到最新的值（hpplinux)</h3>
<div class="outline-text-3" id="text-11-1">
<p>
<b>Question</b>
</p>

<pre class="example">
我在看LevelDB代码的时候遇到了一个问题，百思不得其解，也找不到可以探讨请教的人，所以冒昧的给您发了这封邮件，希望得到您的帮助。
我遇到的问题是这样的：
在
void Version::AddIterators(const ReadOptions&amp; options,
                           std::vector&lt;Iterator*&gt;* iters) {
  // Merge all level zero files together since they may overlap
  for (size_t i = 0; i &lt; files_[0].size(); i++) {
    iters-&gt;push_back(
        vset_-&gt;table_cache_-&gt;NewIterator(
            options, files_[0][i]-&gt;number, files_[0][i]-&gt;file_size));
  }
 
  // For levels &gt; 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level &lt; config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters-&gt;push_back(NewConcatenatingIterator(options, level));
    }
  }
}
 
中对于Level 0层是按照下标从0到N开始遍历的， 但是由于数据加入的时候老的文件在前，新的在后，所以这样的话在iters数组中
下标最小的不一定是最新的。
而在DBImpl::NewInternalIterator 中会把该函数的返回结果直接进行merging，而且原则是key相同的话选取丢弃后面出现的。
 
这样的策略的话会不会导致较老的数据被留下，较新的被删除 ？
</pre>

<hr  />

<p>
<b>Answer</b>
</p>

<p>
是这样的，你可以看到AddIterators这个部分是被DBImpl::NewInternalIterator调用的，得到所有的iterators之后，构造一个MergingIterator对象。
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-comment-delimiter">// </span><span class="org-comment">&#23545;&#20110;version&#26469;&#35828;&#21487;&#33021;&#23384;&#22312;&#24456;&#22810;&#25991;&#20214;&#38656;&#35201;&#36941;&#21382;.</span>
versions_-&gt;current()-&gt;AddIterators(options, &amp;list);
<span class="org-comment-delimiter">// </span><span class="org-comment">&#23558;&#36825;&#20123;&#20869;&#23481;&#26500;&#36896;&#31216;&#20026;&#19968;&#20010;merge iterator.</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">&#27880;&#24847;&#36825;&#37324;&#30340;&#20869;&#23481;&#37117;&#21152;&#20102;&#24341;&#29992;&#35745;&#25968;.</span>
<span class="org-type">Iterator</span>* <span class="org-variable-name">internal_iter</span> =
    NewMergingIterator(&amp;internal_comparator_, &amp;list[0], list.size());
</pre>
</div>

<p>
注意它这里提供的comparator是一个internal_comparator. 这个comparator不仅仅比较user key, 还比较sequence number. 因为sequence number是顺序分配的，所以新的kv得到更大的sequence number. 代码在这里：
</p>

<div class="org-src-container">

<pre class="src src-C++"><span class="org-type">int</span> <span class="org-constant">InternalKeyComparator</span>::<span class="org-function-name">Compare</span>(<span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">akey</span>, <span class="org-keyword">const</span> <span class="org-type">Slice</span>&amp; <span class="org-variable-name">bkey</span>) <span class="org-keyword">const</span> {
  <span class="org-comment-delimiter">// </span><span class="org-comment">Order by:</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">increasing user key (according to user-supplied comparator)</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">decreasing sequence number</span>
  <span class="org-comment-delimiter">//    </span><span class="org-comment">decreasing type (though sequence# should be enough to disambiguate)</span>
  <span class="org-type">int</span> <span class="org-variable-name">r</span> = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  <span class="org-keyword">if</span> (r == 0) {
    <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">anum</span> = DecodeFixed64(akey.data() + akey.size() - 8);
    <span class="org-keyword">const</span> <span class="org-type">uint64_t</span> <span class="org-variable-name">bnum</span> = DecodeFixed64(bkey.data() + bkey.size() - 8);
    <span class="org-keyword">if</span> (anum &gt; bnum) { <span class="org-comment-delimiter">// </span><span class="org-comment">&#25353;&#29031;sequence number&#27604;&#36739;.</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">&#20043;&#21069;&#25105;&#20204;&#22312;MemTableInserter&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;sequence number&#26159;&#19981;&#26029;&#22686;&#21152;&#30340;.</span>
      r = -1;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (anum &lt; bnum) {
      r = +1;
    }
  }
  <span class="org-keyword">return</span> r;
}
</pre>
</div>

<p>
然后这个就好解释问题了。首先每个iterator内部都是按照key做好排序的，多路iterator如果出现相同的key那么使用sequence number大的那个，这样就可以保证始终首先看到的是新值。
</p>
</div>
</div>
</div>
</div>
<!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'dirlt';var disqus_identifier = 'leveldb.html';var disqus_title = 'leveldb.html';var disqus_url = 'http://dirtysalt.github.io/leveldb.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
